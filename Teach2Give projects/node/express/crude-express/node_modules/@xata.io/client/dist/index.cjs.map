{"version":3,"file":"index.cjs","sources":["../src/schema/tracing.ts","../src/util/base64.ts","../src/util/buffer.ts","../src/util/lang.ts","../src/util/fetch.ts","../src/util/uuid.ts","../src/util/sse.ts","../src/version.ts","../src/api/errors.ts","../src/api/providers.ts","../src/api/fetcher.ts","../src/api/dataPlaneFetcher.ts","../src/api/dataPlaneComponents.ts","../src/api/controlPlaneFetcher.ts","../src/api/controlPlaneComponents.ts","../src/api/components.ts","../src/api/client.ts","../src/api/index.ts","../src/plugins.ts","../src/files/transformations.ts","../src/schema/files.ts","../src/schema/filters.ts","../src/schema/json.ts","../src/schema/pagination.ts","../src/schema/query.ts","../src/schema/record.ts","../src/schema/selection.ts","../src/schema/sorting.ts","../src/schema/repository.ts","../src/schema/operators.ts","../src/schema/index.ts","../src/files/index.ts","../src/search/index.ts","../src/sql/parameters.ts","../src/sql/index.ts","../src/transaction/index.ts","../src/client.ts","../src/serializer/index.ts","../src/util/environment.ts","../src/index.ts"],"sourcesContent":["export type AttributeDictionary = Record<string, string | number | boolean | undefined>;\n\nexport type TraceFunction = <T>(\n  name: string,\n  fn: (options: { name?: string; setAttributes: (attrs: AttributeDictionary) => void }) => T,\n  options?: AttributeDictionary\n) => Promise<T>;\n\nexport const defaultTrace: TraceFunction = async <T>(\n  name: string,\n  fn: (options: {\n    name?: string;\n    setAttributes: (attrs: Record<string, string | number | boolean | undefined>) => void;\n  }) => T,\n  _options?: Record<string, any>\n): Promise<T> => {\n  return await fn({\n    name,\n    setAttributes: () => {\n      return;\n    }\n  });\n};\n\nexport const TraceAttributes = {\n  KIND: 'xata.trace.kind',\n\n  VERSION: 'xata.sdk.version',\n\n  TABLE: 'xata.table',\n\n  HTTP_REQUEST_ID: 'http.request_id',\n  HTTP_STATUS_CODE: 'http.status_code',\n  HTTP_HOST: 'http.host',\n  HTTP_SCHEME: 'http.scheme',\n  HTTP_USER_AGENT: 'http.user_agent',\n  HTTP_METHOD: 'http.method',\n  HTTP_URL: 'http.url',\n  HTTP_ROUTE: 'http.route',\n  HTTP_TARGET: 'http.target',\n\n  CLOUDFLARE_RAY_ID: 'cf.ray'\n};\n","// Based from https://github.com/beatgammit/base64-js\n\nconst lookup: string[] = [];\nconst revLookup: number[] = [];\n\nconst code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\nfor (let i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i];\n  revLookup[code.charCodeAt(i)] = i;\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62;\nrevLookup['_'.charCodeAt(0)] = 63;\n\nfunction getLens(b64: string) {\n  const len = b64.length;\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4');\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  let validLen = b64.indexOf('=');\n  if (validLen === -1) validLen = len;\n\n  const placeHoldersLen = validLen === len ? 0 : 4 - (validLen % 4);\n\n  return [validLen, placeHoldersLen];\n}\n\n// base64 is 4/3 + up to two characters of the original data\nexport function byteLength(b64: string): number {\n  const lens = getLens(b64);\n  const validLen = lens[0];\n  const placeHoldersLen = lens[1];\n  return ((validLen + placeHoldersLen) * 3) / 4 - placeHoldersLen;\n}\n\nfunction _byteLength(_b64: string, validLen: number, placeHoldersLen: number): number {\n  return ((validLen + placeHoldersLen) * 3) / 4 - placeHoldersLen;\n}\n\nexport function toByteArray(b64: string): Uint8Array {\n  let tmp;\n  const lens = getLens(b64);\n  const validLen = lens[0];\n  const placeHoldersLen = lens[1];\n\n  const arr = new Uint8Array(_byteLength(b64, validLen, placeHoldersLen));\n\n  let curByte = 0;\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  const len = placeHoldersLen > 0 ? validLen - 4 : validLen;\n\n  let i;\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)];\n    arr[curByte++] = (tmp >> 16) & 0xff;\n    arr[curByte++] = (tmp >> 8) & 0xff;\n    arr[curByte++] = tmp & 0xff;\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4);\n    arr[curByte++] = tmp & 0xff;\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2);\n    arr[curByte++] = (tmp >> 8) & 0xff;\n    arr[curByte++] = tmp & 0xff;\n  }\n\n  return arr;\n}\n\nfunction tripletToBase64(num: number): string {\n  return lookup[(num >> 18) & 0x3f] + lookup[(num >> 12) & 0x3f] + lookup[(num >> 6) & 0x3f] + lookup[num & 0x3f];\n}\n\nfunction encodeChunk(uint8: Uint8Array | number[], start: number, end: number): string {\n  let tmp;\n  const output = [];\n  for (let i = start; i < end; i += 3) {\n    tmp = ((uint8[i] << 16) & 0xff0000) + ((uint8[i + 1] << 8) & 0xff00) + (uint8[i + 2] & 0xff);\n    output.push(tripletToBase64(tmp));\n  }\n  return output.join('');\n}\n\nexport function fromByteArray(uint8: Uint8Array | number[]): string {\n  let tmp;\n  const len = uint8.length;\n  const extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes\n  const parts = [];\n  const maxChunkLength = 16383; // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (let i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1];\n    parts.push(lookup[tmp >> 2] + lookup[(tmp << 4) & 0x3f] + '==');\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1];\n    parts.push(lookup[tmp >> 10] + lookup[(tmp >> 4) & 0x3f] + lookup[(tmp << 2) & 0x3f] + '=');\n  }\n\n  return parts.join('');\n}\n","/* eslint-disable prefer-rest-params, prefer-spread */\n\nimport * as base64 from './base64';\n\nexport const K_MAX_LENGTH = 0x7fffffff;\nexport const MAX_ARGUMENTS_LENGTH = 4096;\n\n// Based from https://github.com/feross/buffer\n// Re-used some type checking from https://gist.github.com/baileyherbert/799c9277429497a40c5f28599494d46f\nclass Buffer extends Uint8Array {\n  /**\n   * Allocates a new buffer containing the given `str`.\n   *\n   * @param str String to store in buffer.\n   * @param encoding Encoding to use, optional. Default is `utf8`.\n   */\n  constructor(str: string, encoding?: Encoding);\n\n  /**\n   * Allocates a new buffer of `size` octets.\n   *\n   * @param size Count of octets to allocate.\n   */\n  constructor(size: number);\n\n  /**\n   * Allocates a new buffer containing the given `array` of octets.\n   *\n   * @param array The octets to store.\n   */\n  constructor(array: Uint8Array);\n\n  /**\n   * Allocates a new buffer containing the given `array` of octet values.\n   *\n   * @param array\n   */\n  constructor(array: number[]);\n\n  /**\n   * Allocates a new buffer containing the given `array` of octet values.\n   *\n   * @param array\n   * @param encoding\n   */\n  constructor(array: number[], encoding: Encoding);\n\n  /**\n   * Copies the passed `buffer` data onto a new `Buffer` instance.\n   *\n   * @param buffer\n   */\n  constructor(buffer: Buffer);\n\n  /**\n   * When passed a reference to the .buffer property of a TypedArray instance, the newly created Buffer will share\n   * the same allocated memory as the TypedArray. The optional `byteOffset` and `length` arguments specify a memory\n   * range within the `arrayBuffer` that will be shared by the Buffer.\n   *\n   * @param buffer The .buffer property of a TypedArray or a new ArrayBuffer().\n   * @param byteOffset\n   * @param length\n   */\n  constructor(buffer: ArrayBuffer, byteOffset?: number, length?: number);\n\n  /**\n   * Constructs a new `Buffer` instance.\n   *\n   * @param value\n   * @param encodingOrOffset\n   * @param length\n   */\n  constructor(\n    value: string | number | Uint8Array | ArrayBuffer | number[] | Buffer,\n    encodingOrOffset?: Encoding | number,\n    length?: number\n  ) {\n    // Handle numbers\n    if (typeof value === 'number') {\n      // If the value is a number but an encoding was provided, there's a mistake -- throw an error\n      if (typeof encodingOrOffset === 'string') {\n        throw new TypeError('The first argument must be of type string, received type number');\n      }\n\n      // Make sure it's positive!!\n      if (value < 0) {\n        throw new RangeError('The buffer size cannot be negative');\n      }\n\n      super(value < 0 ? 0 : Buffer._checked(value) | 0);\n    }\n\n    // Handle strings\n    else if (typeof value === 'string') {\n      if (typeof encodingOrOffset !== 'string') {\n        encodingOrOffset = 'utf8';\n      }\n\n      if (!Buffer.isEncoding(encodingOrOffset)) {\n        throw new TypeError('Unknown encoding: ' + encodingOrOffset);\n      }\n\n      // Create the internal buffer\n      const length = Buffer.byteLength(value, encodingOrOffset) | 0;\n      super(length);\n\n      // Write the data\n      // We'll also make sure the expected number of bytes was written\n      // If not, something is wrong somewhere, and instead of ignoring it we should error!\n      const written = this.write(value, 0, this.length, encodingOrOffset);\n\n      if (written !== length) {\n        throw new TypeError(\n          'Number of bytes written did not match expected length (wrote ' + written + ', expected ' + length + ')'\n        );\n      }\n    }\n\n    // Handle views\n    else if (ArrayBuffer.isView(value)) {\n      // Create from a direct view\n      if (Buffer._isInstance(value, Uint8Array)) {\n        const copy = new Uint8Array(value);\n        const array = copy.buffer;\n        const byteOffset = copy.byteOffset;\n        const length = copy.byteLength;\n\n        if (byteOffset < 0 || array.byteLength < byteOffset) {\n          throw new RangeError('offset is outside of buffer bounds');\n        }\n\n        if (array.byteLength < byteOffset + (length || 0)) {\n          throw new RangeError('length is outside of buffer bounds');\n        }\n\n        // Create from the array buffer\n        super(new Uint8Array(array, byteOffset, length));\n      }\n\n      // Create from an array like\n      else {\n        const array = value as ArrayLike<number>;\n        const length = array.length < 0 ? 0 : Buffer._checked(array.length) | 0;\n\n        // Create the buffer\n        super(new Uint8Array(length));\n\n        // Allocate the bytes manually\n        for (let i = 0; i < length; i++) {\n          this[i] = array[i] & 255;\n        }\n      }\n    }\n\n    // Handle falsey values\n    else if (value == null) {\n      throw new TypeError(\n        'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n          'or Array-like Object. Received type ' +\n          typeof value\n      );\n    }\n\n    // Handle array buffers\n    else if (\n      Buffer._isInstance(value, ArrayBuffer) ||\n      (value && Buffer._isInstance((value as any).buffer, ArrayBuffer))\n    ) {\n      const array = value as Uint8Array;\n      const byteOffset = encodingOrOffset as number;\n\n      if (byteOffset < 0 || array.byteLength < byteOffset) {\n        throw new RangeError('offset is outside of buffer bounds');\n      }\n\n      if (array.byteLength < byteOffset + (length || 0)) {\n        throw new RangeError('length is outside of buffer bounds');\n      }\n\n      // Create from the array buffer\n      super(new Uint8Array(array, byteOffset, length));\n    }\n\n    // Handle arrays\n    else if (Array.isArray(value)) {\n      const array = value as ArrayLike<number>;\n      const length = array.length < 0 ? 0 : Buffer._checked(array.length) | 0;\n\n      // Create the buffer\n      super(new Uint8Array(length));\n\n      // Allocate the bytes manually\n      for (let i = 0; i < length; i++) {\n        this[i] = array[i] & 255;\n      }\n    }\n\n    // Throw an error for anything else\n    else {\n      throw new TypeError('Unable to determine the correct way to allocate buffer for type ' + typeof value);\n    }\n  }\n\n  /**\n   * Return JSON representation of the buffer.\n   */\n  public toJSON(): { type: 'Buffer'; data: number[] } {\n    return {\n      type: 'Buffer',\n      data: Array.prototype.slice.call(this)\n    };\n  }\n\n  /**\n   * Writes `string` to the buffer at `offset` according to the character encoding in `encoding`. The `length`\n   * parameter is the number of bytes to write. If the buffer does not contain enough space to fit the entire string,\n   * only part of `string` will be written. However, partially encoded characters will not be written.\n   *\n   * @param string String to write to `buf`.\n   * @param encoding The character encoding of `string`. Default: `utf8`.\n   */\n  public write(string: string, encoding?: Encoding): number;\n\n  /**\n   * Writes `string` to the buffer at `offset` according to the character encoding in `encoding`. The `length`\n   * parameter is the number of bytes to write. If the buffer does not contain enough space to fit the entire string,\n   * only part of `string` will be written. However, partially encoded characters will not be written.\n   *\n   * @param string String to write to `buf`.\n   * @param offset Number of bytes to skip before starting to write `string`. Default: `0`.\n   * @param length Maximum number of bytes to write: Default: `buf.length - offset`.\n   * @param encoding The character encoding of `string`. Default: `utf8`.\n   */\n  public write(string: string, offset?: number, length?: number, encoding?: Encoding): number;\n\n  /**\n   * Writes `string` to the buffer at `offset` according to the character encoding in `encoding`. The `length`\n   * parameter is the number of bytes to write. If the buffer does not contain enough space to fit the entire string,\n   * only part of `string` will be written. However, partially encoded characters will not be written.\n   *\n   * @param string String to write to `buf`.\n   * @param offset Number of bytes to skip before starting to write `string`. Default: `0`.\n   * @param length Maximum number of bytes to write: Default: `buf.length - offset`.\n   * @param encoding The character encoding of `string`. Default: `utf8`.\n   */\n  public write(string: string, offset?: number | Encoding, length?: number, encoding?: Encoding): number {\n    if (typeof offset === 'undefined') {\n      encoding = 'utf8';\n      length = this.length;\n      offset = 0;\n    } else if (typeof length === 'undefined' && typeof offset === 'string') {\n      encoding = offset;\n      length = this.length;\n      offset = 0;\n    } else if (typeof offset === 'number' && isFinite(offset)) {\n      offset = offset >>> 0;\n\n      if (typeof length === 'number' && isFinite(length)) {\n        length = length >>> 0;\n        encoding ??= 'utf8';\n      } else if (typeof length === 'string') {\n        encoding = length;\n        length = undefined;\n      }\n      // else {\n      // \tthrow new TypeError('Error forming arguments');\n      // }\n    } else {\n      throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');\n    }\n\n    const remaining = this.length - offset;\n\n    if (typeof length === 'undefined' || length > remaining) {\n      length = remaining;\n    }\n\n    if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n      throw new RangeError('Attempt to write outside buffer bounds');\n    }\n\n    // Default encoding to utf8\n    encoding ||= 'utf8';\n\n    switch (Buffer._getEncoding(encoding)) {\n      case 'hex':\n        return Buffer._hexWrite(this, string, offset, length);\n\n      case 'utf8':\n        return Buffer._utf8Write(this, string, offset, length);\n\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return Buffer._asciiWrite(this, string, offset, length);\n\n      case 'ucs2':\n      case 'utf16le':\n        return Buffer._ucs2Write(this, string, offset, length);\n\n      case 'base64':\n        return Buffer._base64Write(this, string, offset, length);\n    }\n  }\n\n  /**\n   * Decodes the buffer to a string according to the specified character encoding.\n   * Passing `start` and `end` will decode only a subset of the buffer.\n   *\n   * Note that if the encoding is `utf8` and a byte sequence in the input is not valid UTF-8, then each invalid byte\n   * will be replaced with `U+FFFD`.\n   *\n   * @param encoding\n   * @param start\n   * @param end\n   */\n  public toString(encoding?: Encoding, start?: number, end?: number): string {\n    const length = this.length;\n\n    if (length === 0) {\n      return '';\n    }\n\n    if (arguments.length === 0) {\n      return Buffer._utf8Slice(this, 0, length);\n    }\n\n    if (typeof start === 'undefined' || start < 0) {\n      start = 0;\n    }\n\n    if (start > this.length) {\n      return '';\n    }\n\n    if (typeof end === 'undefined' || end > this.length) {\n      end = this.length;\n    }\n\n    if (end <= 0) {\n      return '';\n    }\n\n    // Force coercion to uint32, this will also convert falsey valves to 0\n    end >>>= 0;\n    start >>>= 0;\n\n    if (end <= start) {\n      return '';\n    }\n\n    if (!encoding) {\n      encoding = 'utf8';\n    }\n\n    switch (Buffer._getEncoding(encoding)) {\n      case 'hex':\n        return Buffer._hexSlice(this, start, end);\n\n      case 'utf8':\n        return Buffer._utf8Slice(this, start, end);\n\n      case 'ascii':\n        return Buffer._asciiSlice(this, start, end);\n\n      case 'latin1':\n      case 'binary':\n        return Buffer._latin1Slice(this, start, end);\n\n      case 'ucs2':\n      case 'utf16le':\n        return Buffer._utf16leSlice(this, start, end);\n\n      case 'base64':\n        return Buffer._base64Slice(this, start, end);\n    }\n  }\n\n  /**\n   * Returns true if this buffer's is equal to the provided buffer, meaning they share the same exact data.\n   *\n   * @param otherBuffer\n   */\n  public equals(otherBuffer: Buffer): boolean {\n    if (!Buffer.isBuffer(otherBuffer)) {\n      throw new TypeError('Argument must be a Buffer');\n    }\n\n    if (this === otherBuffer) {\n      return true;\n    }\n\n    return Buffer.compare(this, otherBuffer) === 0;\n  }\n\n  /**\n   * Compares the buffer with `otherBuffer` and returns a number indicating whether the buffer comes before, after,\n   * or is the same as `otherBuffer` in sort order. Comparison is based on the actual sequence of bytes in each\n   * buffer.\n   *\n   * - `0` is returned if `otherBuffer` is the same as this buffer.\n   * - `1` is returned if `otherBuffer` should come before this buffer when sorted.\n   * - `-1` is returned if `otherBuffer` should come after this buffer when sorted.\n   *\n   * @param otherBuffer The buffer to compare to.\n   * @param targetStart The offset within `otherBuffer` at which to begin comparison.\n   * @param targetEnd The offset within `otherBuffer` at which to end comparison (exclusive).\n   * @param sourceStart The offset within this buffer at which to begin comparison.\n   * @param sourceEnd The offset within this buffer at which to end the comparison (exclusive).\n   */\n  public compare(\n    otherBuffer: Uint8Array,\n    targetStart?: number,\n    targetEnd?: number,\n    sourceStart?: number,\n    sourceEnd?: number\n  ): number {\n    if (Buffer._isInstance(otherBuffer, Uint8Array)) {\n      otherBuffer = Buffer.from(otherBuffer, otherBuffer.byteOffset, otherBuffer.byteLength);\n    }\n\n    if (!Buffer.isBuffer(otherBuffer)) {\n      throw new TypeError('Argument must be a Buffer or Uint8Array');\n    }\n\n    targetStart ??= 0;\n    targetEnd ??= otherBuffer ? otherBuffer.length : 0;\n    sourceStart ??= 0;\n    sourceEnd ??= this.length;\n\n    if (targetStart < 0 || targetEnd > otherBuffer.length || sourceStart < 0 || sourceEnd > this.length) {\n      throw new RangeError('Out of range index');\n    }\n\n    if (sourceStart >= sourceEnd && targetStart >= targetEnd) {\n      return 0;\n    }\n\n    if (sourceStart >= sourceEnd) {\n      return -1;\n    }\n\n    if (targetStart >= targetEnd) {\n      return 1;\n    }\n\n    targetStart >>>= 0;\n    targetEnd >>>= 0;\n    sourceStart >>>= 0;\n    sourceEnd >>>= 0;\n\n    if (this === otherBuffer) {\n      return 0;\n    }\n\n    let x = sourceEnd - sourceStart;\n    let y = targetEnd - targetStart;\n    const len = Math.min(x, y);\n\n    const thisCopy = this.slice(sourceStart, sourceEnd);\n    const targetCopy = otherBuffer.slice(targetStart, targetEnd);\n\n    for (let i = 0; i < len; ++i) {\n      if (thisCopy[i] !== targetCopy[i]) {\n        x = thisCopy[i];\n        y = targetCopy[i];\n\n        break;\n      }\n    }\n\n    if (x < y) return -1;\n    if (y < x) return 1;\n\n    return 0;\n  }\n\n  /**\n   * Copies data from a region of this buffer to a region in `targetBuffer`, even if the `targetBuffer` memory\n   * region overlaps with this buffer.\n   *\n   * @param targetBuffer The target buffer to copy into.\n   * @param targetStart The offset within `targetBuffer` at which to begin writing.\n   * @param sourceStart The offset within this buffer at which to begin copying.\n   * @param sourceEnd The offset within this buffer at which to end copying (exclusive).\n   */\n  public copy(targetBuffer: Uint8Array, targetStart?: number, sourceStart?: number, sourceEnd?: number): number {\n    if (!Buffer.isBuffer(targetBuffer)) throw new TypeError('argument should be a Buffer');\n    if (!sourceStart) sourceStart = 0;\n    if (!targetStart) targetStart = 0;\n    if (!sourceEnd && sourceEnd !== 0) sourceEnd = this.length;\n    if (targetStart >= targetBuffer.length) targetStart = targetBuffer.length;\n    if (!targetStart) targetStart = 0;\n    if (sourceEnd > 0 && sourceEnd < sourceStart) sourceEnd = sourceStart;\n\n    // Copy 0 bytes; we're done\n    if (sourceEnd === sourceStart) return 0;\n    if (targetBuffer.length === 0 || this.length === 0) return 0;\n\n    // Fatal error conditions\n    if (targetStart < 0) {\n      throw new RangeError('targetStart out of bounds');\n    }\n\n    if (sourceStart < 0 || sourceStart >= this.length) throw new RangeError('Index out of range');\n    if (sourceEnd < 0) throw new RangeError('sourceEnd out of bounds');\n\n    // Are we oob?\n    if (sourceEnd > this.length) sourceEnd = this.length;\n    if (targetBuffer.length - targetStart < sourceEnd - sourceStart) {\n      sourceEnd = targetBuffer.length - targetStart + sourceStart;\n    }\n\n    const len = sourceEnd - sourceStart;\n\n    if (this === targetBuffer && typeof Uint8Array.prototype.copyWithin === 'function') {\n      // Use built-in when available, missing from IE11\n      this.copyWithin(targetStart, sourceStart, sourceEnd);\n    } else {\n      Uint8Array.prototype.set.call(targetBuffer, this.subarray(sourceStart, sourceEnd), targetStart);\n    }\n\n    return len;\n  }\n\n  /**\n   * Returns a new `Buffer` that references the same memory as the original, but offset and cropped by the `start`\n   * and `end` indices. This is the same behavior as `buf.subarray()`.\n   *\n   * This method is not compatible with the `Uint8Array.prototype.slice()`, which is a superclass of Buffer. To copy\n   * the slice, use `Uint8Array.prototype.slice()`.\n   *\n   * @param start\n   * @param end\n   */\n  public slice(start?: number, end?: number): Buffer {\n    if (!start) {\n      start = 0;\n    }\n\n    const len = this.length;\n    start = ~~start;\n    end = end === undefined ? len : ~~end;\n\n    if (start < 0) {\n      start += len;\n\n      if (start < 0) {\n        start = 0;\n      }\n    } else if (start > len) {\n      start = len;\n    }\n\n    if (end < 0) {\n      end += len;\n\n      if (end < 0) {\n        end = 0;\n      }\n    } else if (end > len) {\n      end = len;\n    }\n\n    if (end < start) {\n      end = start;\n    }\n\n    const newBuf = this.subarray(start, end);\n\n    // Return an augmented `Uint8Array` instance\n    Object.setPrototypeOf(newBuf, Buffer.prototype);\n\n    return newBuf as Buffer;\n  }\n\n  /**\n   * Writes `byteLength` bytes of `value` to `buf` at the specified `offset` as little-endian. Supports up to 48 bits\n   * of accuracy. Behavior is undefined when value is anything other than an unsigned integer.\n   *\n   * @param value Number to write.\n   * @param offset Number of bytes to skip before starting to write.\n   * @param byteLength Number of bytes to write, between 0 and 6.\n   * @param noAssert\n   * @returns `offset` plus the number of bytes written.\n   */\n  public writeUIntLE(value: number, offset: number, byteLength: number, noAssert?: boolean): number {\n    value = +value;\n    offset = offset >>> 0;\n    byteLength = byteLength >>> 0;\n\n    if (!noAssert) {\n      const maxBytes = Math.pow(2, 8 * byteLength) - 1;\n      Buffer._checkInt(this, value, offset, byteLength, maxBytes, 0);\n    }\n\n    let mul = 1;\n    let i = 0;\n\n    this[offset] = value & 0xff;\n\n    while (++i < byteLength && (mul *= 0x100)) {\n      this[offset + i] = (value / mul) & 0xff;\n    }\n\n    return offset + byteLength;\n  }\n\n  /**\n   * Writes `byteLength` bytes of `value` to `buf` at the specified `offset` as big-endian. Supports up to 48 bits of\n   * accuracy. Behavior is undefined when `value` is anything other than an unsigned integer.\n   *\n   * @param value Number to write.\n   * @param offset Number of bytes to skip before starting to write.\n   * @param byteLength Number of bytes to write, between 0 and 6.\n   * @param noAssert\n   * @returns `offset` plus the number of bytes written.\n   */\n  public writeUIntBE(value: number, offset: number, byteLength: number, noAssert?: boolean): number {\n    value = +value;\n    offset = offset >>> 0;\n    byteLength = byteLength >>> 0;\n\n    if (!noAssert) {\n      const maxBytes = Math.pow(2, 8 * byteLength) - 1;\n      Buffer._checkInt(this, value, offset, byteLength, maxBytes, 0);\n    }\n\n    let i = byteLength - 1;\n    let mul = 1;\n\n    this[offset + i] = value & 0xff;\n\n    while (--i >= 0 && (mul *= 0x100)) {\n      this[offset + i] = (value / mul) & 0xff;\n    }\n\n    return offset + byteLength;\n  }\n\n  /**\n   * Writes `byteLength` bytes of `value` to `buf` at the specified `offset` as little-endian. Supports up to 48 bits\n   * of accuracy. Behavior is undefined when `value` is anything other than a signed integer.\n   *\n   * @param value Number to write.\n   * @param offset Number of bytes to skip before starting to write.\n   * @param byteLength Number of bytes to write, between 0 and 6.\n   * @param noAssert\n   * @returns `offset` plus the number of bytes written.\n   */\n  public writeIntLE(value: number, offset: number, byteLength: number, noAssert?: boolean): number {\n    value = +value;\n    offset = offset >>> 0;\n\n    if (!noAssert) {\n      const limit = Math.pow(2, 8 * byteLength - 1);\n      Buffer._checkInt(this, value, offset, byteLength, limit - 1, -limit);\n    }\n\n    let i = 0;\n    let mul = 1;\n    let sub = 0;\n\n    this[offset] = value & 0xff;\n\n    while (++i < byteLength && (mul *= 0x100)) {\n      if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n        sub = 1;\n      }\n\n      this[offset + i] = (((value / mul) >> 0) - sub) & 0xff;\n    }\n\n    return offset + byteLength;\n  }\n\n  /**\n   * Writes `byteLength` bytes of `value` to `buf` at the specified `offset` as big-endian. Supports up to 48 bits\n   * of accuracy. Behavior is undefined when `value` is anything other than a signed integer.\n   *\n   * @param value Number to write.\n   * @param offset Number of bytes to skip before starting to write.\n   * @param byteLength Number of bytes to write, between 0 and 6.\n   * @param noAssert\n   * @returns `offset` plus the number of bytes written.\n   */\n  public writeIntBE(value: number, offset: number, byteLength: number, noAssert?: boolean): number {\n    value = +value;\n    offset = offset >>> 0;\n\n    if (!noAssert) {\n      const limit = Math.pow(2, 8 * byteLength - 1);\n      Buffer._checkInt(this, value, offset, byteLength, limit - 1, -limit);\n    }\n\n    let i = byteLength - 1;\n    let mul = 1;\n    let sub = 0;\n\n    this[offset + i] = value & 0xff;\n\n    while (--i >= 0 && (mul *= 0x100)) {\n      if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n        sub = 1;\n      }\n\n      this[offset + i] = (((value / mul) >> 0) - sub) & 0xff;\n    }\n\n    return offset + byteLength;\n  }\n\n  /**\n   * Reads `byteLength` number of bytes from `buf` at the specified `offset` and interprets the result as an\n   * unsigned, little-endian integer supporting up to 48 bits of accuracy.\n   *\n   * @param offset Number of bytes to skip before starting to read.\n   * @param byteLength Number of bytes to read, between 0 and 6.\n   * @param noAssert\n   */\n  public readUIntLE(offset: number, byteLength: number, noAssert?: boolean): number {\n    offset = offset >>> 0;\n    byteLength = byteLength >>> 0;\n\n    if (!noAssert) {\n      Buffer._checkOffset(offset, byteLength, this.length);\n    }\n\n    let val = this[offset];\n    let mul = 1;\n    let i = 0;\n\n    while (++i < byteLength && (mul *= 0x100)) {\n      val += this[offset + i] * mul;\n    }\n\n    return val;\n  }\n\n  /**\n   * Reads `byteLength` number of bytes from `buf` at the specified `offset` and interprets the result as an\n   * unsigned, big-endian integer supporting up to 48 bits of accuracy.\n   *\n   * @param offset Number of bytes to skip before starting to read.\n   * @param byteLength Number of bytes to read, between 0 and 6.\n   * @param noAssert\n   */\n  public readUIntBE(offset: number, byteLength: number, noAssert?: boolean): number {\n    offset = offset >>> 0;\n    byteLength = byteLength >>> 0;\n\n    if (!noAssert) {\n      Buffer._checkOffset(offset, byteLength, this.length);\n    }\n\n    let val = this[offset + --byteLength];\n    let mul = 1;\n\n    while (byteLength > 0 && (mul *= 0x100)) {\n      val += this[offset + --byteLength] * mul;\n    }\n\n    return val;\n  }\n\n  /**\n   * Reads `byteLength` number of bytes from `buf` at the specified `offset` and interprets the result as a\n   * little-endian, two's complement signed value supporting up to 48 bits of accuracy.\n   *\n   * @param offset Number of bytes to skip before starting to read.\n   * @param byteLength Number of bytes to read, between 0 and 6.\n   * @param noAssert\n   */\n  public readIntLE(offset: number, byteLength: number, noAssert?: boolean): number {\n    offset = offset >>> 0;\n    byteLength = byteLength >>> 0;\n\n    if (!noAssert) {\n      Buffer._checkOffset(offset, byteLength, this.length);\n    }\n\n    let val = this[offset];\n    let mul = 1;\n    let i = 0;\n\n    while (++i < byteLength && (mul *= 0x100)) {\n      val += this[offset + i] * mul;\n    }\n\n    mul *= 0x80;\n\n    if (val >= mul) {\n      val -= Math.pow(2, 8 * byteLength);\n    }\n\n    return val;\n  }\n\n  /**\n   * Reads `byteLength` number of bytes from `buf` at the specified `offset` and interprets the result as a\n   * big-endian, two's complement signed value supporting up to 48 bits of accuracy.\n   *\n   * @param offset Number of bytes to skip before starting to read.\n   * @param byteLength Number of bytes to read, between 0 and 6.\n   * @param noAssert\n   */\n  public readIntBE(offset: number, byteLength: number, noAssert?: boolean): number {\n    offset = offset >>> 0;\n    byteLength = byteLength >>> 0;\n\n    if (!noAssert) {\n      Buffer._checkOffset(offset, byteLength, this.length);\n    }\n\n    let i = byteLength;\n    let mul = 1;\n    let val = this[offset + --i];\n\n    while (i > 0 && (mul *= 0x100)) {\n      val += this[offset + --i] * mul;\n    }\n\n    mul *= 0x80;\n\n    if (val >= mul) {\n      val -= Math.pow(2, 8 * byteLength);\n    }\n\n    return val;\n  }\n\n  /**\n   * Reads an unsigned 8-bit integer from `buf` at the specified `offset`.\n   *\n   * @param offset Number of bytes to skip before starting to read.\n   * @param noAssert\n   */\n  public readUInt8(offset: number, noAssert?: boolean): number {\n    offset = offset >>> 0;\n\n    if (!noAssert) {\n      Buffer._checkOffset(offset, 1, this.length);\n    }\n\n    return this[offset];\n  }\n\n  /**\n   * Reads an unsigned, little-endian 16-bit integer from `buf` at the specified `offset`.\n   *\n   * @param offset Number of bytes to skip before starting to read.\n   * @param noAssert\n   */\n  public readUInt16LE(offset: number, noAssert?: boolean): number {\n    offset = offset >>> 0;\n\n    if (!noAssert) {\n      Buffer._checkOffset(offset, 2, this.length);\n    }\n\n    return this[offset] | (this[offset + 1] << 8);\n  }\n\n  /**\n   * Reads an unsigned, big-endian 16-bit integer from `buf` at the specified `offset`.\n   *\n   * @param offset Number of bytes to skip before starting to read.\n   * @param noAssert\n   */\n  public readUInt16BE(offset: number, noAssert?: boolean): number {\n    offset = offset >>> 0;\n\n    if (!noAssert) {\n      Buffer._checkOffset(offset, 2, this.length);\n    }\n\n    return (this[offset] << 8) | this[offset + 1];\n  }\n\n  /**\n   * Reads an unsigned, little-endian 32-bit integer from `buf` at the specified `offset`.\n   *\n   * @param offset Number of bytes to skip before starting to read.\n   * @param noAssert\n   */\n  public readUInt32LE(offset: number, noAssert?: boolean): number {\n    offset = offset >>> 0;\n\n    if (!noAssert) {\n      Buffer._checkOffset(offset, 4, this.length);\n    }\n\n    return (this[offset] | (this[offset + 1] << 8) | (this[offset + 2] << 16)) + this[offset + 3] * 0x1000000;\n  }\n\n  /**\n   * Reads an unsigned, big-endian 32-bit integer from `buf` at the specified `offset`.\n   *\n   * @param offset Number of bytes to skip before starting to read.\n   * @param noAssert\n   */\n  public readUInt32BE(offset: number, noAssert?: boolean): number {\n    offset = offset >>> 0;\n\n    if (!noAssert) {\n      Buffer._checkOffset(offset, 4, this.length);\n    }\n\n    return this[offset] * 0x1000000 + ((this[offset + 1] << 16) | (this[offset + 2] << 8) | this[offset + 3]);\n  }\n\n  /**\n   * Reads a signed 8-bit integer from `buf` at the specified `offset`. Integers read from a `Buffer` are interpreted\n   * as two's complement signed values.\n   *\n   * @param offset Number of bytes to skip before starting to read.\n   * @param noAssert\n   */\n  public readInt8(offset: number, noAssert?: boolean): number {\n    offset = offset >>> 0;\n\n    if (!noAssert) {\n      Buffer._checkOffset(offset, 1, this.length);\n    }\n\n    if (!(this[offset] & 0x80)) {\n      return this[offset];\n    }\n\n    return (0xff - this[offset] + 1) * -1;\n  }\n\n  /**\n   * Reads a signed, little-endian 16-bit integer from `buf` at the specified `offset`. Integers read from a `Buffer`\n   * are interpreted as two's complement signed values.\n   *\n   * @param offset Number of bytes to skip before starting to read.\n   * @param noAssert\n   */\n  public readInt16LE(offset: number, noAssert?: boolean): number {\n    offset = offset >>> 0;\n\n    if (!noAssert) {\n      Buffer._checkOffset(offset, 2, this.length);\n    }\n\n    const val = this[offset] | (this[offset + 1] << 8);\n    return val & 0x8000 ? val | 0xffff0000 : val;\n  }\n\n  /**\n   * Reads a signed, big-endian 16-bit integer from `buf` at the specified `offset`. Integers read from a `Buffer`\n   * are interpreted as two's complement signed values.\n   *\n   * @param offset Number of bytes to skip before starting to read.\n   * @param noAssert\n   */\n  public readInt16BE(offset: number, noAssert?: boolean): number {\n    offset = offset >>> 0;\n\n    if (!noAssert) {\n      Buffer._checkOffset(offset, 2, this.length);\n    }\n\n    const val = this[offset + 1] | (this[offset] << 8);\n    return val & 0x8000 ? val | 0xffff0000 : val;\n  }\n\n  /**\n   * Reads a signed, little-endian 32-bit integer from `buf` at the specified `offset`. Integers read from a `Buffer`\n   * are interpreted as two's complement signed values.\n   *\n   * @param offset Number of bytes to skip before starting to read.\n   * @param noAssert\n   */\n  public readInt32LE(offset: number, noAssert?: boolean): number {\n    offset = offset >>> 0;\n\n    if (!noAssert) {\n      Buffer._checkOffset(offset, 4, this.length);\n    }\n\n    return this[offset] | (this[offset + 1] << 8) | (this[offset + 2] << 16) | (this[offset + 3] << 24);\n  }\n\n  /**\n   * Reads a signed, big-endian 32-bit integer from `buf` at the specified `offset`. Integers read from a `Buffer`\n   * are interpreted as two's complement signed values.\n   *\n   * @param offset Number of bytes to skip before starting to read.\n   * @param noAssert\n   */\n  public readInt32BE(offset: number, noAssert?: boolean): number {\n    offset = offset >>> 0;\n\n    if (!noAssert) {\n      Buffer._checkOffset(offset, 4, this.length);\n    }\n\n    return (this[offset] << 24) | (this[offset + 1] << 16) | (this[offset + 2] << 8) | this[offset + 3];\n  }\n\n  /**\n   * Interprets `buf` as an array of unsigned 16-bit integers and swaps the byte order in-place.\n   * Throws a `RangeError` if `buf.length` is not a multiple of 2.\n   */\n  public swap16(): Buffer {\n    const len = this.length;\n\n    if (len % 2 !== 0) {\n      throw new RangeError('Buffer size must be a multiple of 16-bits');\n    }\n\n    for (let i = 0; i < len; i += 2) {\n      this._swap(this, i, i + 1);\n    }\n\n    return this;\n  }\n\n  /**\n   * Interprets `buf` as an array of unsigned 32-bit integers and swaps the byte order in-place.\n   * Throws a `RangeError` if `buf.length` is not a multiple of 4.\n   */\n  public swap32(): Buffer {\n    const len = this.length;\n\n    if (len % 4 !== 0) {\n      throw new RangeError('Buffer size must be a multiple of 32-bits');\n    }\n\n    for (let i = 0; i < len; i += 4) {\n      this._swap(this, i, i + 3);\n      this._swap(this, i + 1, i + 2);\n    }\n\n    return this;\n  }\n\n  /**\n   * Interprets `buf` as an array of unsigned 64-bit integers and swaps the byte order in-place.\n   * Throws a `RangeError` if `buf.length` is not a multiple of 8.\n   */\n  public swap64(): Buffer {\n    const len = this.length;\n\n    if (len % 8 !== 0) {\n      throw new RangeError('Buffer size must be a multiple of 64-bits');\n    }\n\n    for (let i = 0; i < len; i += 8) {\n      this._swap(this, i, i + 7);\n      this._swap(this, i + 1, i + 6);\n      this._swap(this, i + 2, i + 5);\n      this._swap(this, i + 3, i + 4);\n    }\n\n    return this;\n  }\n\n  /**\n   * Swaps two octets.\n   *\n   * @param b\n   * @param n\n   * @param m\n   */\n  private _swap(b: Buffer, n: number, m: number) {\n    const i = b[n];\n    b[n] = b[m];\n    b[m] = i;\n  }\n\n  /**\n   * Writes `value` to `buf` at the specified `offset`. The `value` must be a valid unsigned 8-bit integer.\n   * Behavior is undefined when `value` is anything other than an unsigned 8-bit integer.\n   *\n   * @param value Number to write.\n   * @param offset Number of bytes to skip before starting to write.\n   * @param noAssert\n   * @returns `offset` plus the number of bytes written.\n   */\n  public writeUInt8(value: number, offset: number, noAssert?: boolean): number {\n    value = +value;\n    offset = offset >>> 0;\n\n    if (!noAssert) {\n      Buffer._checkInt(this, value, offset, 1, 0xff, 0);\n    }\n\n    this[offset] = value & 0xff;\n    return offset + 1;\n  }\n\n  /**\n   * Writes `value` to `buf` at the specified `offset` as little-endian. The `value` must be a valid unsigned 16-bit\n   * integer. Behavior is undefined when `value` is anything other than an unsigned 16-bit integer.\n   *\n   * @param value Number to write.\n   * @param offset Number of bytes to skip before starting to write.\n   * @param noAssert\n   * @returns `offset` plus the number of bytes written.\n   */\n  public writeUInt16LE(value: number | string, offset: number, noAssert?: boolean): number {\n    value = +value;\n    offset = offset >>> 0;\n\n    if (!noAssert) {\n      Buffer._checkInt(this, value, offset, 2, 0xffff, 0);\n    }\n\n    this[offset] = value & 0xff;\n    this[offset + 1] = value >>> 8;\n    return offset + 2;\n  }\n\n  /**\n   * Writes `value` to `buf` at the specified `offset` as big-endian. The `value` must be a valid unsigned 16-bit\n   * integer. Behavior is undefined when `value` is anything other than an unsigned 16-bit integer.\n   *\n   * @param value Number to write.\n   * @param offset Number of bytes to skip before starting to write.\n   * @param noAssert\n   * @returns `offset` plus the number of bytes written.\n   */\n  public writeUInt16BE(value: number, offset: number, noAssert?: boolean): number {\n    value = +value;\n    offset = offset >>> 0;\n\n    if (!noAssert) {\n      Buffer._checkInt(this, value, offset, 2, 0xffff, 0);\n    }\n\n    this[offset] = value >>> 8;\n    this[offset + 1] = value & 0xff;\n\n    return offset + 2;\n  }\n\n  /**\n   * Writes `value` to `buf` at the specified `offset` as little-endian. The `value` must be a valid unsigned 32-bit\n   * integer. Behavior is undefined when `value` is anything other than an unsigned 32-bit integer.\n   *\n   * @param value Number to write.\n   * @param offset Number of bytes to skip before starting to write.\n   * @param noAssert\n   * @returns `offset` plus the number of bytes written.\n   */\n  public writeUInt32LE(value: number, offset: number, noAssert?: boolean): number {\n    value = +value;\n    offset = offset >>> 0;\n\n    if (!noAssert) {\n      Buffer._checkInt(this, value, offset, 4, 0xffffffff, 0);\n    }\n\n    this[offset + 3] = value >>> 24;\n    this[offset + 2] = value >>> 16;\n    this[offset + 1] = value >>> 8;\n    this[offset] = value & 0xff;\n    return offset + 4;\n  }\n\n  /**\n   * Writes `value` to `buf` at the specified `offset` as big-endian. The `value` must be a valid unsigned 32-bit\n   * integer. Behavior is undefined when `value` is anything other than an unsigned 32-bit integer.\n   *\n   * @param value Number to write.\n   * @param offset Number of bytes to skip before starting to write.\n   * @param noAssert\n   * @returns `offset` plus the number of bytes written.\n   */\n  public writeUInt32BE(value: number, offset: number, noAssert?: boolean): number {\n    value = +value;\n    offset = offset >>> 0;\n\n    if (!noAssert) {\n      Buffer._checkInt(this, value, offset, 4, 0xffffffff, 0);\n    }\n\n    this[offset] = value >>> 24;\n    this[offset + 1] = value >>> 16;\n    this[offset + 2] = value >>> 8;\n    this[offset + 3] = value & 0xff;\n\n    return offset + 4;\n  }\n\n  /**\n   * Writes `value` to `buf` at the specified `offset`. The `value` must be a valid signed 8-bit integer.\n   * Behavior is undefined when `value` is anything other than a signed 8-bit integer.\n   *\n   * @param value Number to write.\n   * @param offset Number of bytes to skip before starting to write.\n   * @param noAssert\n   * @returns `offset` plus the number of bytes written.\n   */\n  public writeInt8(value: number, offset: number, noAssert?: boolean): number {\n    value = +value;\n    offset = offset >>> 0;\n\n    if (!noAssert) {\n      Buffer._checkInt(this, value, offset, 1, 0x7f, -0x80);\n    }\n\n    if (value < 0) {\n      value = 0xff + value + 1;\n    }\n\n    this[offset] = value & 0xff;\n    return offset + 1;\n  }\n\n  /**\n   * Writes `value` to `buf` at the specified `offset` as little-endian. The `value` must be a valid signed 16-bit\n   * integer. Behavior is undefined when `value` is anything other than a signed 16-bit integer.\n   *\n   * @param value Number to write.\n   * @param offset Number of bytes to skip before starting to write.\n   * @param noAssert\n   * @returns `offset` plus the number of bytes written.\n   */\n  public writeInt16LE(value: number, offset: number, noAssert?: boolean): number {\n    value = +value;\n    offset = offset >>> 0;\n\n    if (!noAssert) {\n      Buffer._checkInt(this, value, offset, 2, 0x7fff, -0x8000);\n    }\n\n    this[offset] = value & 0xff;\n    this[offset + 1] = value >>> 8;\n\n    return offset + 2;\n  }\n\n  /**\n   * Writes `value` to `buf` at the specified `offset` as big-endian. The `value` must be a valid signed 16-bit\n   * integer. Behavior is undefined when `value` is anything other than a signed 16-bit integer.\n   *\n   * @param value Number to write.\n   * @param offset Number of bytes to skip before starting to write.\n   * @param noAssert\n   * @returns `offset` plus the number of bytes written.\n   */\n  public writeInt16BE(value: number, offset: number, noAssert?: boolean): number {\n    value = +value;\n    offset = offset >>> 0;\n\n    if (!noAssert) {\n      Buffer._checkInt(this, value, offset, 2, 0x7fff, -0x8000);\n    }\n\n    this[offset] = value >>> 8;\n    this[offset + 1] = value & 0xff;\n\n    return offset + 2;\n  }\n\n  /**\n   * Writes `value` to `buf` at the specified `offset` as little-endian. The `value` must be a valid signed 32-bit\n   * integer. Behavior is undefined when `value` is anything other than a signed 32-bit integer.\n   *\n   * @param value Number to write.\n   * @param offset Number of bytes to skip before starting to write.\n   * @param noAssert\n   * @returns `offset` plus the number of bytes written.\n   */\n  public writeInt32LE(value: number, offset: number, noAssert?: boolean): number {\n    value = +value;\n    offset = offset >>> 0;\n\n    if (!noAssert) {\n      Buffer._checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);\n    }\n\n    this[offset] = value & 0xff;\n    this[offset + 1] = value >>> 8;\n    this[offset + 2] = value >>> 16;\n    this[offset + 3] = value >>> 24;\n\n    return offset + 4;\n  }\n\n  /**\n   * Writes `value` to `buf` at the specified `offset` as big-endian. The `value` must be a valid signed 32-bit\n   * integer. Behavior is undefined when `value` is anything other than a signed 32-bit integer.\n   *\n   * @param value Number to write.\n   * @param offset Number of bytes to skip before starting to write.\n   * @param noAssert\n   * @returns `offset` plus the number of bytes written.\n   */\n  public writeInt32BE(value: number, offset: number, noAssert?: boolean): number {\n    value = +value;\n    offset = offset >>> 0;\n\n    if (!noAssert) {\n      Buffer._checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);\n    }\n\n    if (value < 0) {\n      value = 0xffffffff + value + 1;\n    }\n\n    this[offset] = value >>> 24;\n    this[offset + 1] = value >>> 16;\n    this[offset + 2] = value >>> 8;\n    this[offset + 3] = value & 0xff;\n\n    return offset + 4;\n  }\n\n  /**\n   * Fills `buf` with the specified `value`. If the `offset` and `end` are not given, the entire `buf` will be\n   * filled. The `value` is coerced to a `uint32` value if it is not a string, `Buffer`, or integer. If the resulting\n   * integer is greater than `255` (decimal), then `buf` will be filled with `value & 255`.\n   *\n   * If the final write of a `fill()` operation falls on a multi-byte character, then only the bytes of that\n   * character that fit into `buf` are written.\n   *\n   * If `value` contains invalid characters, it is truncated; if no valid fill data remains, an exception is thrown.\n   *\n   * @param value\n   * @param encoding\n   */\n  public fill(value: any, offset?: number, end?: number, encoding?: Encoding): this {\n    if (typeof value === 'string') {\n      if (typeof offset === 'string') {\n        encoding = offset;\n        offset = 0;\n        end = this.length;\n      } else if (typeof end === 'string') {\n        encoding = end;\n        end = this.length;\n      }\n\n      if (encoding !== undefined && typeof encoding !== 'string') {\n        throw new TypeError('encoding must be a string');\n      }\n\n      if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n        throw new TypeError('Unknown encoding: ' + encoding);\n      }\n\n      if (value.length === 1) {\n        const code = value.charCodeAt(0);\n\n        if (encoding === 'utf8' && code < 128) {\n          // Fast path: If `val` fits into a single byte, use that numeric value.\n          value = code;\n        }\n      }\n    } else if (typeof value === 'number') {\n      value = value & 255;\n    } else if (typeof value === 'boolean') {\n      value = Number(value);\n    }\n\n    // Apply defaults\n    offset ??= 0;\n    end ??= this.length;\n\n    // Invalid ranges are not set to a default, so can range check early.\n    if (offset < 0 || this.length < offset || this.length < end) {\n      throw new RangeError('Out of range index');\n    }\n\n    if (end <= offset) {\n      return this;\n    }\n\n    offset = offset >>> 0;\n    end = end === undefined ? this.length : end >>> 0;\n    value ||= 0;\n\n    let i: number;\n\n    if (typeof value === 'number') {\n      for (i = offset; i < end; ++i) {\n        this[i] = value;\n      }\n    } else {\n      const bytes = Buffer.isBuffer(value) ? value : Buffer.from(value, encoding);\n      const len = bytes.length;\n\n      if (len === 0) {\n        throw new TypeError('The value \"' + value + '\" is invalid for argument \"value\"');\n      }\n\n      for (i = 0; i < end - offset; ++i) {\n        this[i + offset] = bytes[i % len];\n      }\n    }\n\n    return this;\n  }\n\n  /**\n   * Returns the index of the specified value.\n   *\n   * If `value` is:\n   * - a string, `value` is interpreted according to the character encoding in `encoding`.\n   * - a `Buffer` or `Uint8Array`, `value` will be used in its entirety. To compare a partial Buffer, use `slice()`.\n   * - a number, `value` will be interpreted as an unsigned 8-bit integer value between `0` and `255`.\n   *\n   * Any other types will throw a `TypeError`.\n   *\n   * @param value What to search for.\n   * @param byteOffset Where to begin searching in `buf`. If negative, then calculated from the end.\n   * @param encoding If `value` is a string, this is the encoding used to search.\n   * @returns The index of the first occurrence of `value` in `buf`, or `-1` if not found.\n   */\n  public indexOf(value: string | number | Buffer, byteOffset?: number, encoding?: Encoding): number {\n    return this._bidirectionalIndexOf(this, value, byteOffset, encoding, true);\n  }\n\n  /**\n   * Gets the last index of the specified value.\n   *\n   * @see indexOf()\n   * @param value\n   * @param byteOffset\n   * @param encoding\n   */\n  public lastIndexOf(value: string | number | Buffer, byteOffset?: number, encoding?: Encoding): number {\n    return this._bidirectionalIndexOf(this, value, byteOffset, encoding, false);\n  }\n\n  private _bidirectionalIndexOf(\n    buffer: Buffer,\n    val: string | number | Buffer,\n    byteOffset?: number,\n    encoding?: Encoding,\n    dir?: boolean\n  ) {\n    // Empty buffer means no match\n    if (buffer.length === 0) {\n      return -1;\n    }\n\n    // Normalize byteOffset\n    if (typeof byteOffset === 'string') {\n      encoding = byteOffset;\n      byteOffset = 0;\n    } else if (typeof byteOffset === 'undefined') {\n      byteOffset = 0;\n    } else if (byteOffset > 0x7fffffff) {\n      byteOffset = 0x7fffffff;\n    } else if (byteOffset < -0x80000000) {\n      byteOffset = -0x80000000;\n    }\n\n    byteOffset = +byteOffset; // Coerce to Number.\n    if (byteOffset !== byteOffset) {\n      // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n      byteOffset = dir ? 0 : buffer.length - 1;\n    }\n\n    // Normalize byteOffset: negative offsets start from the end of the buffer\n    if (byteOffset < 0) {\n      byteOffset = buffer.length + byteOffset;\n    }\n    if (byteOffset >= buffer.length) {\n      if (dir) {\n        return -1;\n      } else {\n        byteOffset = buffer.length - 1;\n      }\n    } else if (byteOffset < 0) {\n      if (dir) {\n        byteOffset = 0;\n      } else {\n        return -1;\n      }\n    }\n\n    // Normalize val\n    if (typeof val === 'string') {\n      val = Buffer.from(val, encoding);\n    }\n\n    // Finally, search either indexOf (if dir is true) or lastIndexOf\n    if (Buffer.isBuffer(val)) {\n      // Special case: looking for empty string/buffer always fails\n      if (val.length === 0) {\n        return -1;\n      }\n\n      return Buffer._arrayIndexOf(buffer, val, byteOffset, encoding, dir);\n    } else if (typeof val === 'number') {\n      val = val & 0xff; // Search for a byte value [0-255]\n\n      if (typeof Uint8Array.prototype.indexOf === 'function') {\n        if (dir) {\n          return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);\n        } else {\n          return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);\n        }\n      }\n\n      return Buffer._arrayIndexOf(buffer, Buffer.from([val]), byteOffset, encoding, dir);\n    }\n\n    throw new TypeError('val must be string, number or Buffer');\n  }\n\n  /**\n   * Equivalent to `buf.indexOf() !== -1`.\n   *\n   * @param value\n   * @param byteOffset\n   * @param encoding\n   */\n  public includes(value: string | number | Buffer, byteOffset?: number, encoding?: Encoding): boolean {\n    return this.indexOf(value, byteOffset, encoding) !== -1;\n  }\n\n  /**\n   * Allocates a new Buffer using an `array` of octet values.\n   *\n   * @param array\n   */\n  public static from(array: number[]): Buffer;\n\n  /**\n   * When passed a reference to the .buffer property of a TypedArray instance, the newly created Buffer will share\n   * the same allocated memory as the TypedArray. The optional `byteOffset` and `length` arguments specify a memory\n   * range within the `arrayBuffer` that will be shared by the Buffer.\n   *\n   * @param buffer The .buffer property of a TypedArray or a new ArrayBuffer().\n   * @param byteOffset\n   * @param length\n   */\n  public static from(buffer: ArrayBuffer, byteOffset?: number, length?: number): Buffer;\n\n  /**\n   * Copies the passed `buffer` data onto a new Buffer instance.\n   *\n   * @param buffer\n   */\n  public static from(buffer: Buffer | Uint8Array): Buffer;\n\n  /**\n   * Creates a new Buffer containing the given string `str`. If provided, the `encoding` parameter identifies the\n   * character encoding.\n   *\n   * @param str String to store in buffer.\n   * @param encoding Encoding to use, optional. Default is `utf8`.\n   */\n  public static from(str: string, encoding?: Encoding): Buffer;\n\n  /**\n   * Creates a new buffer from the given parameters.\n   *\n   * @param data\n   * @param encoding\n   */\n  public static from(\n    a: string | number | Uint8Array | number[] | Buffer | ArrayBuffer,\n    b?: Encoding | number,\n    c?: number\n  ): Buffer {\n    return new Buffer(a as any, b as any, c);\n  }\n\n  /**\n   * Returns true if `obj` is a Buffer.\n   *\n   * @param obj\n   */\n  public static isBuffer(obj: any): obj is Buffer {\n    return obj != null && obj !== Buffer.prototype && Buffer._isInstance(obj, Buffer);\n  }\n\n  /**\n   * Returns true if `encoding` is a supported encoding.\n   *\n   * @param encoding\n   */\n  public static isEncoding(encoding: string): encoding is Encoding {\n    switch (encoding.toLowerCase()) {\n      case 'hex':\n      case 'utf8':\n      case 'ascii':\n      case 'binary':\n      case 'latin1':\n      case 'ucs2':\n      case 'utf16le':\n      case 'base64':\n        return true;\n      default:\n        return false;\n    }\n  }\n\n  /**\n   * Gives the actual byte length of a string for an encoding. This is not the same as `string.length` since that\n   * returns the number of characters in the string.\n   *\n   * @param string The string to test.\n   * @param encoding The encoding to use for calculation. Defaults is `utf8`.\n   */\n  public static byteLength(string: string | Buffer | ArrayBuffer, encoding?: Encoding): number {\n    if (Buffer.isBuffer(string)) {\n      return string.length;\n    }\n\n    if (typeof string !== 'string' && (ArrayBuffer.isView(string) || Buffer._isInstance(string, ArrayBuffer))) {\n      return string.byteLength;\n    }\n\n    if (typeof string !== 'string') {\n      throw new TypeError(\n        'The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. ' + 'Received type ' + typeof string\n      );\n    }\n\n    const len = string.length;\n    const mustMatch = arguments.length > 2 && arguments[2] === true;\n\n    if (!mustMatch && len === 0) {\n      return 0;\n    }\n\n    // Use a for loop to avoid recursion\n    switch (encoding?.toLowerCase()) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len;\n      case 'utf8':\n        return Buffer._utf8ToBytes(string).length;\n      case 'hex':\n        return len >>> 1;\n      case 'ucs2':\n      case 'utf16le':\n        return len * 2;\n      case 'base64':\n        return Buffer._base64ToBytes(string).length;\n      default:\n        return mustMatch ? -1 : Buffer._utf8ToBytes(string).length; // assume utf8\n    }\n  }\n\n  /**\n   * Returns a Buffer which is the result of concatenating all the buffers in the list together.\n   *\n   * - If the list has no items, or if the `totalLength` is 0, then it returns a zero-length buffer.\n   * - If the list has exactly one item, then the first item is returned.\n   * - If the list has more than one item, then a new buffer is created.\n   *\n   * It is faster to provide the `totalLength` if it is known. However, it will be calculated if not provided at\n   * a small computational expense.\n   *\n   * @param list An array of Buffer objects to concatenate.\n   * @param totalLength Total length of the buffers when concatenated.\n   */\n  public static concat(list: Uint8Array[], totalLength?: number): Buffer {\n    if (!Array.isArray(list)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers');\n    }\n\n    if (list.length === 0) {\n      return Buffer.alloc(0);\n    }\n\n    let i: number;\n    if (totalLength === undefined) {\n      totalLength = 0;\n\n      for (i = 0; i < list.length; ++i) {\n        totalLength += list[i].length;\n      }\n    }\n\n    const buffer = Buffer.allocUnsafe(totalLength);\n    let pos = 0;\n\n    for (i = 0; i < list.length; ++i) {\n      let buf = list[i];\n\n      if (Buffer._isInstance(buf, Uint8Array)) {\n        if (pos + buf.length > buffer.length) {\n          if (!Buffer.isBuffer(buf)) {\n            buf = Buffer.from(buf);\n          }\n\n          (buf as Buffer).copy(buffer, pos);\n        } else {\n          Uint8Array.prototype.set.call(buffer, buf, pos);\n        }\n      } else if (!Buffer.isBuffer(buf)) {\n        throw new TypeError('\"list\" argument must be an Array of Buffers');\n      } else {\n        (buf as Buffer).copy(buffer, pos);\n      }\n\n      pos += buf.length;\n    }\n\n    return buffer;\n  }\n\n  /**\n   * The same as `buf1.compare(buf2)`.\n   */\n  public static compare(buf1: Uint8Array, buf2: Uint8Array): number {\n    if (Buffer._isInstance(buf1, Uint8Array)) {\n      buf1 = Buffer.from(buf1, buf1.byteOffset, buf1.byteLength);\n    }\n\n    if (Buffer._isInstance(buf2, Uint8Array)) {\n      buf2 = Buffer.from(buf2, buf2.byteOffset, buf2.byteLength);\n    }\n\n    if (!Buffer.isBuffer(buf1) || !Buffer.isBuffer(buf2)) {\n      throw new TypeError('The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array');\n    }\n\n    if (buf1 === buf2) {\n      return 0;\n    }\n\n    let x = buf1.length;\n    let y = buf2.length;\n\n    for (let i = 0, len = Math.min(x, y); i < len; ++i) {\n      if (buf1[i] !== buf2[i]) {\n        x = buf1[i];\n        y = buf2[i];\n\n        break;\n      }\n    }\n\n    if (x < y) {\n      return -1;\n    }\n\n    if (y < x) {\n      return 1;\n    }\n\n    return 0;\n  }\n\n  /**\n   * Allocates a new buffer of `size` octets.\n   *\n   * @param size The number of octets to allocate.\n   * @param fill If specified, the buffer will be initialized by calling `buf.fill(fill)`, or with zeroes otherwise.\n   * @param encoding The encoding used for the call to `buf.fill()` while initializing.\n   */\n  public static alloc(size: number, fill?: string | Buffer | number, encoding?: Encoding): Buffer {\n    if (typeof size !== 'number') {\n      throw new TypeError('\"size\" argument must be of type number');\n    } else if (size < 0) {\n      throw new RangeError('The value \"' + size + '\" is invalid for option \"size\"');\n    }\n\n    if (size <= 0) {\n      return new Buffer(size);\n    }\n\n    if (fill !== undefined) {\n      // Only pay attention to encoding if it's a string. This\n      // prevents accidentally sending in a number that would\n      // be interpreted as a start offset.\n      return typeof encoding === 'string'\n        ? new Buffer(size).fill(fill, 0, size, encoding)\n        : new Buffer(size).fill(fill);\n    }\n\n    return new Buffer(size);\n  }\n\n  /**\n   * Allocates a new buffer of `size` octets without initializing memory. The contents of the buffer are unknown.\n   *\n   * @param size\n   */\n  public static allocUnsafe(size: number): Buffer {\n    if (typeof size !== 'number') {\n      throw new TypeError('\"size\" argument must be of type number');\n    } else if (size < 0) {\n      throw new RangeError('The value \"' + size + '\" is invalid for option \"size\"');\n    }\n\n    return new Buffer(size < 0 ? 0 : Buffer._checked(size) | 0);\n  }\n\n  /**\n   * Returns true if the given `obj` is an instance of `type`.\n   *\n   * @param obj\n   * @param type\n   */\n  private static _isInstance(obj: any, type: any): obj is typeof type {\n    return (\n      obj instanceof type ||\n      (obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name)\n    );\n  }\n\n  private static _checked(length: number) {\n    if (length >= K_MAX_LENGTH) {\n      throw new RangeError(\n        'Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes'\n      );\n    }\n\n    return length | 0;\n  }\n\n  private static _blitBuffer(src: number[] | Uint8Array, dst: Buffer, offset: number, length: number) {\n    let i: number;\n\n    for (i = 0; i < length; ++i) {\n      if (i + offset >= dst.length || i >= src.length) {\n        break;\n      }\n\n      dst[i + offset] = src[i];\n    }\n\n    return i;\n  }\n\n  private static _utf8Write(buf: Buffer, string: string, offset: number, length: number) {\n    return Buffer._blitBuffer(Buffer._utf8ToBytes(string, buf.length - offset), buf, offset, length);\n  }\n\n  private static _asciiWrite(buf: Buffer, string: string, offset: number, length: number) {\n    return Buffer._blitBuffer(Buffer._asciiToBytes(string), buf, offset, length);\n  }\n\n  private static _base64Write(buf: Buffer, string: string, offset: number, length: number) {\n    return Buffer._blitBuffer(Buffer._base64ToBytes(string), buf, offset, length);\n  }\n\n  private static _ucs2Write(buf: Buffer, string: string, offset: number, length: number) {\n    return Buffer._blitBuffer(Buffer._utf16leToBytes(string, buf.length - offset), buf, offset, length);\n  }\n\n  private static _hexWrite(buf: Buffer, string: string, offset: number, length: number) {\n    offset = Number(offset) || 0;\n\n    const remaining = buf.length - offset;\n\n    if (!length) {\n      length = remaining;\n    } else {\n      length = Number(length);\n\n      if (length > remaining) {\n        length = remaining;\n      }\n    }\n\n    const strLen = string.length;\n\n    if (length > strLen / 2) {\n      length = strLen / 2;\n    }\n\n    let i;\n\n    for (i = 0; i < length; ++i) {\n      const parsed = parseInt(string.substr(i * 2, 2), 16);\n\n      if (parsed !== parsed) {\n        return i;\n      }\n\n      buf[offset + i] = parsed;\n    }\n\n    return i;\n  }\n\n  private static _utf8ToBytes(string: string, units?: number) {\n    units = units || Infinity;\n\n    const length = string.length;\n    const bytes = [];\n\n    let codePoint;\n    let leadSurrogate = null;\n\n    for (let i = 0; i < length; ++i) {\n      codePoint = string.charCodeAt(i);\n\n      // is surrogate component\n      if (codePoint > 0xd7ff && codePoint < 0xe000) {\n        // last char was a lead\n        if (!leadSurrogate) {\n          // no lead yet\n          if (codePoint > 0xdbff) {\n            // unexpected trail\n            if ((units -= 3) > -1) {\n              bytes.push(0xef, 0xbf, 0xbd);\n            }\n\n            continue;\n          } else if (i + 1 === length) {\n            // unpaired lead\n            if ((units -= 3) > -1) {\n              bytes.push(0xef, 0xbf, 0xbd);\n            }\n\n            continue;\n          }\n\n          // valid lead\n          leadSurrogate = codePoint;\n\n          continue;\n        }\n\n        // 2 leads in a row\n        if (codePoint < 0xdc00) {\n          if ((units -= 3) > -1) {\n            bytes.push(0xef, 0xbf, 0xbd);\n          }\n\n          leadSurrogate = codePoint;\n          continue;\n        }\n\n        // valid surrogate pair\n        codePoint = (((leadSurrogate - 0xd800) << 10) | (codePoint - 0xdc00)) + 0x10000;\n      } else if (leadSurrogate) {\n        // valid bmp char, but last char was a lead\n        if ((units -= 3) > -1) {\n          bytes.push(0xef, 0xbf, 0xbd);\n        }\n      }\n\n      leadSurrogate = null;\n\n      // encode utf8\n      if (codePoint < 0x80) {\n        if ((units -= 1) < 0) {\n          break;\n        }\n\n        bytes.push(codePoint);\n      } else if (codePoint < 0x800) {\n        if ((units -= 2) < 0) {\n          break;\n        }\n\n        bytes.push((codePoint >> 0x6) | 0xc0, (codePoint & 0x3f) | 0x80);\n      } else if (codePoint < 0x10000) {\n        if ((units -= 3) < 0) {\n          break;\n        }\n\n        bytes.push((codePoint >> 0xc) | 0xe0, ((codePoint >> 0x6) & 0x3f) | 0x80, (codePoint & 0x3f) | 0x80);\n      } else if (codePoint < 0x110000) {\n        if ((units -= 4) < 0) {\n          break;\n        }\n\n        bytes.push(\n          (codePoint >> 0x12) | 0xf0,\n          ((codePoint >> 0xc) & 0x3f) | 0x80,\n          ((codePoint >> 0x6) & 0x3f) | 0x80,\n          (codePoint & 0x3f) | 0x80\n        );\n      } else {\n        throw new Error('Invalid code point');\n      }\n    }\n\n    return bytes;\n  }\n\n  private static _base64ToBytes(str: string) {\n    return base64.toByteArray(base64clean(str));\n  }\n\n  private static _asciiToBytes(str: string) {\n    const byteArray = [];\n\n    for (let i = 0; i < str.length; ++i) {\n      // Node's code seems to be doing this and not & 0x7F..\n      byteArray.push(str.charCodeAt(i) & 0xff);\n    }\n\n    return byteArray;\n  }\n\n  private static _utf16leToBytes(str: string, units: number) {\n    let c, hi, lo;\n    const byteArray = [];\n\n    for (let i = 0; i < str.length; ++i) {\n      if ((units -= 2) < 0) break;\n\n      c = str.charCodeAt(i);\n      hi = c >> 8;\n      lo = c % 256;\n\n      byteArray.push(lo);\n      byteArray.push(hi);\n    }\n\n    return byteArray;\n  }\n\n  private static _hexSlice(buf: Buffer, start: number, end: number) {\n    const len = buf.length;\n\n    if (!start || start < 0) {\n      start = 0;\n    }\n\n    if (!end || end < 0 || end > len) {\n      end = len;\n    }\n\n    let out = '';\n    for (let i = start; i < end; ++i) {\n      out += hexSliceLookupTable[buf[i]];\n    }\n\n    return out;\n  }\n\n  private static _base64Slice(buf: Buffer, start: number, end: number) {\n    if (start === 0 && end === buf.length) {\n      return base64.fromByteArray(buf);\n    } else {\n      return base64.fromByteArray(buf.slice(start, end));\n    }\n  }\n\n  private static _utf8Slice(buf: Buffer, start: number, end: number) {\n    end = Math.min(buf.length, end);\n    const res: number[] = [];\n\n    let i = start;\n    while (i < end) {\n      const firstByte = buf[i];\n      let codePoint = null;\n      let bytesPerSequence = firstByte > 0xef ? 4 : firstByte > 0xdf ? 3 : firstByte > 0xbf ? 2 : 1;\n\n      if (i + bytesPerSequence <= end) {\n        let secondByte, thirdByte, fourthByte, tempCodePoint;\n\n        switch (bytesPerSequence) {\n          case 1:\n            if (firstByte < 0x80) {\n              codePoint = firstByte;\n            }\n\n            break;\n          case 2:\n            secondByte = buf[i + 1];\n\n            if ((secondByte & 0xc0) === 0x80) {\n              tempCodePoint = ((firstByte & 0x1f) << 0x6) | (secondByte & 0x3f);\n\n              if (tempCodePoint > 0x7f) {\n                codePoint = tempCodePoint;\n              }\n            }\n\n            break;\n          case 3:\n            secondByte = buf[i + 1];\n            thirdByte = buf[i + 2];\n\n            if ((secondByte & 0xc0) === 0x80 && (thirdByte & 0xc0) === 0x80) {\n              tempCodePoint = ((firstByte & 0xf) << 0xc) | ((secondByte & 0x3f) << 0x6) | (thirdByte & 0x3f);\n\n              if (tempCodePoint > 0x7ff && (tempCodePoint < 0xd800 || tempCodePoint > 0xdfff)) {\n                codePoint = tempCodePoint;\n              }\n            }\n\n            break;\n          case 4:\n            secondByte = buf[i + 1];\n            thirdByte = buf[i + 2];\n            fourthByte = buf[i + 3];\n\n            if ((secondByte & 0xc0) === 0x80 && (thirdByte & 0xc0) === 0x80 && (fourthByte & 0xc0) === 0x80) {\n              tempCodePoint =\n                ((firstByte & 0xf) << 0x12) |\n                ((secondByte & 0x3f) << 0xc) |\n                ((thirdByte & 0x3f) << 0x6) |\n                (fourthByte & 0x3f);\n\n              if (tempCodePoint > 0xffff && tempCodePoint < 0x110000) {\n                codePoint = tempCodePoint;\n              }\n            }\n        }\n      }\n\n      if (codePoint === null) {\n        // we did not generate a valid codePoint so insert a\n        // replacement char (U+FFFD) and advance only 1 byte\n        codePoint = 0xfffd;\n        bytesPerSequence = 1;\n      } else if (codePoint > 0xffff) {\n        // encode to utf16 (surrogate pair dance)\n        codePoint -= 0x10000;\n        res.push(((codePoint >>> 10) & 0x3ff) | 0xd800);\n        codePoint = 0xdc00 | (codePoint & 0x3ff);\n      }\n\n      res.push(codePoint);\n      i += bytesPerSequence;\n    }\n\n    return Buffer._decodeCodePointsArray(res);\n  }\n\n  private static _decodeCodePointsArray(codePoints: number[]) {\n    const len = codePoints.length;\n\n    if (len <= MAX_ARGUMENTS_LENGTH) {\n      return String.fromCharCode.apply(String, codePoints); // avoid extra slice()\n    }\n\n    // Decode in chunks to avoid \"call stack size exceeded\".\n    let res = '';\n    let i = 0;\n\n    while (i < len) {\n      res += String.fromCharCode.apply(String, codePoints.slice(i, (i += MAX_ARGUMENTS_LENGTH)));\n    }\n\n    return res;\n  }\n\n  private static _asciiSlice(buf: Buffer, start: number, end: number) {\n    let ret = '';\n    end = Math.min(buf.length, end);\n\n    for (let i = start; i < end; ++i) {\n      ret += String.fromCharCode(buf[i] & 0x7f);\n    }\n\n    return ret;\n  }\n\n  private static _latin1Slice(buf: Buffer, start: number, end: number) {\n    let ret = '';\n    end = Math.min(buf.length, end);\n\n    for (let i = start; i < end; ++i) {\n      ret += String.fromCharCode(buf[i]);\n    }\n\n    return ret;\n  }\n\n  private static _utf16leSlice(buf: Buffer, start: number, end: number) {\n    const bytes = buf.slice(start, end);\n    let res = '';\n\n    // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)\n    for (let i = 0; i < bytes.length - 1; i += 2) {\n      res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);\n    }\n\n    return res;\n  }\n\n  private static _arrayIndexOf(arr: Buffer, val: Buffer, byteOffset: number, encoding?: string, dir?: boolean) {\n    let indexSize = 1;\n    let arrLength = arr.length;\n    let valLength = val.length;\n\n    if (encoding !== undefined) {\n      encoding = Buffer._getEncoding(encoding);\n\n      if (encoding === 'ucs2' || encoding === 'utf16le') {\n        if (arr.length < 2 || val.length < 2) {\n          return -1;\n        }\n\n        indexSize = 2;\n        arrLength /= 2;\n        valLength /= 2;\n        byteOffset /= 2;\n      }\n    }\n\n    function read(buf: Buffer, i: number) {\n      if (indexSize === 1) {\n        return buf[i];\n      } else {\n        return (buf as Buffer).readUInt16BE(i * indexSize);\n      }\n    }\n\n    let i: number;\n\n    if (dir) {\n      let foundIndex = -1;\n\n      for (i = byteOffset; i < arrLength; i++) {\n        if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n          if (foundIndex === -1) foundIndex = i;\n          if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;\n        } else {\n          if (foundIndex !== -1) i -= i - foundIndex;\n          foundIndex = -1;\n        }\n      }\n    } else {\n      if (byteOffset + valLength > arrLength) {\n        byteOffset = arrLength - valLength;\n      }\n\n      for (i = byteOffset; i >= 0; i--) {\n        let found = true;\n\n        for (let j = 0; j < valLength; j++) {\n          if (read(arr, i + j) !== read(val, j)) {\n            found = false;\n            break;\n          }\n        }\n\n        if (found) {\n          return i;\n        }\n      }\n    }\n\n    return -1;\n  }\n\n  private static _checkOffset(offset: number, ext: number, length: number) {\n    if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');\n    if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');\n  }\n\n  private static _checkInt(buf: Buffer, value: number, offset: number, ext: number, max: number, min: number) {\n    if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance');\n    if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds');\n    if (offset + ext > buf.length) throw new RangeError('Index out of range');\n  }\n\n  private static _getEncoding(encoding: string): Encoding {\n    let toLowerCase = false;\n    let originalEncoding = '';\n\n    for (;;) {\n      switch (encoding) {\n        case 'hex':\n          return 'hex';\n        case 'utf8':\n          return 'utf8';\n        case 'ascii':\n          return 'ascii';\n        case 'binary':\n          return 'binary';\n        case 'latin1':\n          return 'latin1';\n        case 'ucs2':\n          return 'ucs2';\n        case 'utf16le':\n          return 'utf16le';\n        case 'base64':\n          return 'base64';\n\n        default: {\n          if (toLowerCase) {\n            throw new TypeError('Unknown or unsupported encoding: ' + originalEncoding);\n          }\n\n          toLowerCase = true;\n          originalEncoding = encoding;\n          encoding = encoding.toLowerCase();\n        }\n      }\n    }\n  }\n}\n\n/**\n * Utility table for hex slicing.\n */\nconst hexSliceLookupTable = (function () {\n  const alphabet = '0123456789abcdef';\n  const table = new Array(256);\n\n  for (let i = 0; i < 16; ++i) {\n    const i16 = i * 16;\n\n    for (let j = 0; j < 16; ++j) {\n      table[i16 + j] = alphabet[i] + alphabet[j];\n    }\n  }\n\n  return table;\n})();\n\n/**\n * Regular expression for invalid Base64 characters.\n */\nconst INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;\n\nfunction base64clean(str: string) {\n  // Node takes equal signs as end of the Base64 encoding\n  str = str.split('=')[0];\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = str.trim().replace(INVALID_BASE64_RE, '');\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return '';\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '=';\n  }\n  return str;\n}\n\n/**\n * The encodings that are supported in both native and polyfilled `Buffer` instances.\n */\nexport type Encoding = 'ascii' | 'utf8' | 'utf16le' | 'ucs2' | 'binary' | 'hex' | 'latin1' | 'base64';\n\nexport { Buffer };\n","import { Buffer } from './buffer';\n\nfunction notEmpty<T>(value: T | null | undefined): value is T {\n  return value !== null && value !== undefined;\n}\n\nexport function compact<T>(arr: Array<T | null | undefined>): T[] {\n  return arr.filter(notEmpty);\n}\n\nexport function compactObject<T>(obj: Record<string, T | null | undefined>): Record<string, T> {\n  return Object.fromEntries(Object.entries(obj).filter(([, value]) => notEmpty(value))) as Record<string, T>;\n}\n\nexport type PartialBy<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;\n\nexport function isBlob(value: any): value is Blob {\n  try {\n    return value instanceof Blob;\n  } catch (error) {\n    // Node prior to v18.0.0 doesn't support instanceof Blob and throws a ReferenceError\n    return false;\n  }\n}\n\nexport function isObject(value: any): value is Record<string, unknown> {\n  return (\n    Boolean(value) && typeof value === 'object' && !Array.isArray(value) && !(value instanceof Date) && !isBlob(value)\n  );\n}\n\nexport function isDefined<T>(value: T | null | undefined): value is T {\n  return value !== null && value !== undefined;\n}\n\nexport function isString(value: any): value is string {\n  return isDefined(value) && typeof value === 'string';\n}\n\nexport function isStringArray(value: any): value is string[] {\n  return isDefined(value) && Array.isArray(value) && value.every(isString);\n}\n\nexport function isNumber(value: any): value is number {\n  return isDefined(value) && typeof value === 'number';\n}\n\nexport function parseNumber(value: any): number | undefined {\n  if (isNumber(value)) {\n    return value;\n  }\n\n  if (isString(value)) {\n    const parsed = Number(value);\n    if (!Number.isNaN(parsed)) {\n      return parsed;\n    }\n  }\n\n  return undefined;\n}\n\nexport function toBase64(value: string): string {\n  try {\n    return btoa(value);\n  } catch (err) {\n    const buf = Buffer; // Avoid \"A Node.js API is used which is not supported in the Edge Runtime\" in Vercel Edge middleware\n    return buf.from(value).toString('base64');\n  }\n}\n\nexport function deepMerge<A extends Record<string, any>, B extends Record<string, any>>(a: A, b: B) {\n  const result: Record<string, any> = { ...a };\n\n  for (const [key, value] of Object.entries(b)) {\n    if (isObject(value) && isObject(result[key])) {\n      result[key] = deepMerge(result[key], value);\n    } else {\n      result[key] = value;\n    }\n  }\n\n  return result as DeepMergeResult<A, B>;\n}\n\ntype DeepMergeResult<A extends Record<string, any>, B extends Record<string, any>> = {\n  [K in keyof A | keyof B]: K extends keyof A\n    ? K extends keyof B\n      ? A[K] extends Record<string, any>\n        ? B[K] extends Record<string, any>\n          ? DeepMergeResult<A[K], B[K]>\n          : B[K]\n        : B[K]\n      : A[K]\n    : K extends keyof B\n    ? B[K]\n    : never;\n};\n\nexport function chunk<T>(array: T[], chunkSize: number): T[][] {\n  const result = [];\n\n  for (let i = 0; i < array.length; i += chunkSize) {\n    result.push(array.slice(i, i + chunkSize));\n  }\n\n  return result;\n}\n\nexport async function timeout(ms: number) {\n  return new Promise((resolve) => setTimeout(resolve, ms));\n}\n\nexport function timeoutWithCancel(ms: number) {\n  let timeoutId: ReturnType<typeof setTimeout>;\n\n  const promise = new Promise<void>((resolve) => {\n    timeoutId = setTimeout(() => {\n      resolve();\n    }, ms);\n  });\n\n  return {\n    cancel: () => clearTimeout(timeoutId),\n    promise\n  };\n}\n\n/* Map sequentially over T[] with an asynchronous function and return array of mapped values */\nexport function promiseMap<T, S>(inputValues: T[], mapper: (value: T) => Promise<S>): Promise<S[]> {\n  const reducer = (acc$: Promise<S[]>, inputValue: T): Promise<S[]> =>\n    acc$.then((acc: S[]) =>\n      mapper(inputValue).then((result) => {\n        acc.push(result);\n        return acc;\n      })\n    );\n\n  return inputValues.reduce(reducer, Promise.resolve([]));\n}\n","import { parseNumber, timeout, timeoutWithCancel } from './lang';\n\nconst REQUEST_TIMEOUT = 5 * 60 * 1000; // 5 minutes\n\nexport type RequestInit = { body?: any; headers?: Record<string, string>; method?: string; signal?: any };\n\nexport type Response = {\n  ok: boolean;\n  status: number;\n  url: string;\n  json(): Promise<any>;\n  text(): Promise<string>;\n  blob(): Promise<Blob>;\n  headers?: {\n    get(name: string): string | null;\n  };\n};\n\n// Typed only the subset of the spec we actually use (to be able to build a simple mock)\nexport type FetchImpl = (url: string, init?: RequestInit) => Promise<Response>;\n\nexport function getFetchImplementation(userFetch?: FetchImpl) {\n  // @ts-ignore - fetch might not be a global\n  const globalFetch = typeof fetch !== 'undefined' ? fetch : undefined;\n  // @ts-ignore - globalThis might not be a global\n  const globalThisFetch = typeof globalThis !== 'undefined' ? globalThis.fetch : undefined;\n  const fetchImpl: FetchImpl | undefined = (userFetch as any) ?? (globalFetch as any) ?? (globalThisFetch as any);\n  if (!fetchImpl) {\n    /** @todo add a link after docs exist */\n    throw new Error(`Couldn't find a global \\`fetch\\`. Pass a fetch implementation explicitly.`);\n  }\n  return fetchImpl;\n}\n\nexport class ApiRequestPool {\n  #fetch?: FetchImpl;\n  #queue: Array<(...params: any[]) => any>;\n  #concurrency: number;\n\n  running: number;\n  started: number;\n\n  constructor(concurrency = 10) {\n    this.#queue = [];\n    this.#concurrency = concurrency;\n\n    this.running = 0;\n    this.started = 0;\n  }\n\n  setFetch(fetch: FetchImpl) {\n    this.#fetch = fetch;\n  }\n\n  getFetch(): FetchImpl {\n    if (!this.#fetch) {\n      throw new Error('Fetch not set');\n    }\n\n    return this.#fetch;\n  }\n\n  request(url: string, options?: RequestInit): Promise<Response> {\n    const start = new Date();\n    const fetchImpl = this.getFetch();\n\n    const runRequest = async (stalled = false): Promise<Response> => {\n      // Some fetch implementations don't timeout and network changes hang the connection\n      const { promise, cancel } = timeoutWithCancel(REQUEST_TIMEOUT);\n      const response = await Promise.race([fetchImpl(url, options), promise.then(() => null)]).finally(cancel);\n      if (!response) {\n        throw new Error('Request timed out');\n      }\n\n      if (response.status === 429) {\n        const rateLimitReset = parseNumber(response.headers?.get('x-ratelimit-reset')) ?? 1;\n\n        await timeout(rateLimitReset * 1000);\n        return await runRequest(true);\n      }\n\n      if (stalled) {\n        const stalledTime = new Date().getTime() - start.getTime();\n        console.warn(`A request to Xata hit branch rate limits, was retried and stalled for ${stalledTime}ms`);\n      }\n\n      return response;\n    };\n\n    return this.#enqueue(async () => {\n      return await runRequest();\n    });\n  }\n  #enqueue<Result>(task: () => Promise<Result>): Promise<Result> {\n    const promise = new Promise<Result>((resolve) => this.#queue.push(resolve))\n      .finally(() => {\n        this.started--;\n        this.running++;\n      })\n      .then(() => task())\n      .finally(() => {\n        this.running--;\n\n        const next = this.#queue.shift();\n        if (next !== undefined) {\n          this.started++;\n          next();\n        }\n      });\n\n    if (this.running + this.started < this.#concurrency) {\n      const next = this.#queue.shift();\n      if (next !== undefined) {\n        this.started++;\n        next();\n      }\n    }\n\n    return promise;\n  }\n}\n","export function generateUUID() {\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n    const r = (Math.random() * 16) | 0,\n      v = c == 'x' ? r : (r & 0x3) | 0x8;\n    return v.toString(16);\n  });\n}\n","/* eslint-disable */\n\n// Code extracted from @microsoft/fetch-event-source (MIT License)\n// Removed browser-specific parts to make it cross-platform\n\nimport { FetchImpl, RequestInit, Response } from './fetch';\n\n/**\n * Represents a message sent in an event stream\n * https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#Event_stream_format\n */\nexport interface EventSourceMessage {\n  /** The event ID to set the EventSource object's last event ID value. */\n  id: string;\n  /** A string identifying the type of event described. */\n  event: string;\n  /** The event data */\n  data: string;\n  /** The reconnection interval (in milliseconds) to wait before retrying the connection */\n  retry?: number;\n}\n\n/**\n * Converts a ReadableStream into a callback pattern.\n * @param stream The input ReadableStream.\n * @param onChunk A function that will be called on each new byte chunk in the stream.\n * @returns {Promise<void>} A promise that will be resolved when the stream closes.\n */\nasync function getBytes(stream: any, onChunk: (arr: Uint8Array) => void) {\n  const reader = stream.getReader();\n  let result;\n  while (!(result = await reader.read()).done) {\n    onChunk(result.value);\n  }\n}\n\nconst enum ControlChars {\n  NewLine = 10,\n  CarriageReturn = 13,\n  Space = 32,\n  Colon = 58\n}\n\n/**\n * Parses arbitary byte chunks into EventSource line buffers.\n * Each line should be of the format \"field: value\" and ends with \\r, \\n, or \\r\\n.\n * @param onLine A function that will be called on each new EventSource line.\n * @returns A function that should be called for each incoming byte chunk.\n */\nfunction getLines(onLine: (line: Uint8Array, fieldLength: number) => void) {\n  let buffer: Uint8Array | undefined;\n  let position: number; // current read position\n  let fieldLength: number; // length of the `field` portion of the line\n  let discardTrailingNewline = false;\n\n  // return a function that can process each incoming byte chunk:\n  return function onChunk(arr: Uint8Array) {\n    if (buffer === undefined) {\n      buffer = arr;\n      position = 0;\n      fieldLength = -1;\n    } else {\n      // we're still parsing the old line. Append the new bytes into buffer:\n      buffer = concat(buffer, arr);\n    }\n\n    const bufLength = buffer.length;\n    let lineStart = 0; // index where the current line starts\n    while (position < bufLength) {\n      if (discardTrailingNewline) {\n        if (buffer[position] === ControlChars.NewLine) {\n          lineStart = ++position; // skip to next char\n        }\n\n        discardTrailingNewline = false;\n      }\n\n      // start looking forward till the end of line:\n      let lineEnd = -1; // index of the \\r or \\n char\n      for (; position < bufLength && lineEnd === -1; ++position) {\n        switch (buffer[position]) {\n          case ControlChars.Colon:\n            if (fieldLength === -1) {\n              // first colon in line\n              fieldLength = position - lineStart;\n            }\n            break;\n          // @ts-ignore:7029 \\r case below should fallthrough to \\n:\n          case ControlChars.CarriageReturn:\n            discardTrailingNewline = true;\n          case ControlChars.NewLine:\n            lineEnd = position;\n            break;\n        }\n      }\n\n      if (lineEnd === -1) {\n        // We reached the end of the buffer but the line hasn't ended.\n        // Wait for the next arr and then continue parsing:\n        break;\n      }\n\n      // we've reached the line end, send it out:\n      onLine(buffer.subarray(lineStart, lineEnd), fieldLength);\n      lineStart = position; // we're now on the next line\n      fieldLength = -1;\n    }\n\n    if (lineStart === bufLength) {\n      buffer = undefined; // we've finished reading it\n    } else if (lineStart !== 0) {\n      // Create a new view into buffer beginning at lineStart so we don't\n      // need to copy over the previous lines when we get the new arr:\n      buffer = buffer.subarray(lineStart);\n      position -= lineStart;\n    }\n  };\n}\n\n/**\n * Parses line buffers into EventSourceMessages.\n * @param onId A function that will be called on each `id` field.\n * @param onRetry A function that will be called on each `retry` field.\n * @param onMessage A function that will be called on each message.\n * @returns A function that should be called for each incoming line buffer.\n */\nfunction getMessages(\n  onId: (id: string) => void,\n  onRetry: (retry: number) => void,\n  onMessage?: (msg: EventSourceMessage) => void\n) {\n  let message = newMessage();\n  const decoder = new TextDecoder();\n\n  // return a function that can process each incoming line buffer:\n  return function onLine(line: Uint8Array, fieldLength: number) {\n    if (line.length === 0) {\n      // empty line denotes end of message. Trigger the callback and start a new message:\n      onMessage?.(message);\n      message = newMessage();\n    } else if (fieldLength > 0) {\n      // exclude comments and lines with no values\n      // line is of format \"<field>:<value>\" or \"<field>: <value>\"\n      // https://html.spec.whatwg.org/multipage/server-sent-events.html#event-stream-interpretation\n      const field = decoder.decode(line.subarray(0, fieldLength));\n      const valueOffset = fieldLength + (line[fieldLength + 1] === ControlChars.Space ? 2 : 1);\n      const value = decoder.decode(line.subarray(valueOffset));\n\n      switch (field) {\n        case 'data':\n          // if this message already has data, append the new value to the old.\n          // otherwise, just set to the new value:\n          message.data = message.data ? message.data + '\\n' + value : value; // otherwise,\n          break;\n        case 'event':\n          message.event = value;\n          break;\n        case 'id':\n          onId((message.id = value));\n          break;\n        case 'retry':\n          const retry = parseInt(value, 10);\n          if (!isNaN(retry)) {\n            // per spec, ignore non-integers\n            onRetry((message.retry = retry));\n          }\n          break;\n      }\n    }\n  };\n}\n\nfunction concat(a: Uint8Array, b: Uint8Array) {\n  const res = new Uint8Array(a.length + b.length);\n  res.set(a);\n  res.set(b, a.length);\n  return res;\n}\n\nfunction newMessage(): EventSourceMessage {\n  // data, event, and id must be initialized to empty strings:\n  // https://html.spec.whatwg.org/multipage/server-sent-events.html#event-stream-interpretation\n  // retry should be initialized to undefined so we return a consistent shape\n  // to the js engine all the time: https://mathiasbynens.be/notes/shapes-ics#takeaways\n  return {\n    data: '',\n    event: '',\n    id: '',\n    retry: undefined\n  };\n}\n\nexport const EventStreamContentType = 'text/event-stream';\n\nconst LastEventId = 'last-event-id';\n\nexport interface FetchEventSourceInit extends RequestInit {\n  /**\n   * The request headers. FetchEventSource only supports the Record<string,string> format.\n   */\n  headers?: Record<string, string>;\n\n  /**\n   * Called when a response is received. Use this to validate that the response\n   * actually matches what you expect (and throw if it doesn't.) If not provided,\n   * will default to a basic validation to ensure the content-type is text/event-stream.\n   */\n  onopen?: (response: Response) => Promise<void>;\n\n  /**\n   * Called when a message is received. NOTE: Unlike the default browser\n   * EventSource.onmessage, this callback is called for _all_ events,\n   * even ones with a custom `event` field.\n   */\n  onmessage?: (ev: EventSourceMessage) => void;\n\n  /**\n   * Called when a response finishes. If you don't expect the server to kill\n   * the connection, you can throw an exception here and retry using onerror.\n   */\n  onclose?: () => void;\n\n  /**\n   * Called when there is any error making the request / processing messages /\n   * handling callbacks etc. Use this to control the retry strategy: if the\n   * error is fatal, rethrow the error inside the callback to stop the entire\n   * operation. Otherwise, you can return an interval (in milliseconds) after\n   * which the request will automatically retry (with the last-event-id).\n   * If this callback is not specified, or it returns undefined, fetchEventSource\n   * will treat every error as retriable and will try again after 1 second.\n   */\n  onerror?: (err: any) => number | null | undefined | void;\n\n  /** The Fetch function to use. */\n  fetch?: FetchImpl;\n}\n\nexport function fetchEventSource(\n  input: string,\n  {\n    signal: inputSignal,\n    headers: inputHeaders,\n    onopen: inputOnOpen,\n    onmessage,\n    onclose,\n    onerror,\n    fetch: inputFetch,\n    ...rest\n  }: FetchEventSourceInit\n) {\n  return new Promise<void>((resolve, reject) => {\n    // make a copy of the input headers since we may modify it below:\n    const headers = { ...inputHeaders };\n    if (!headers.accept) {\n      headers.accept = EventStreamContentType;\n    }\n\n    let curRequestController: AbortController;\n\n    function dispose() {\n      curRequestController.abort();\n    }\n\n    // if the incoming signal aborts, dispose resources and resolve:\n    inputSignal?.addEventListener('abort', () => {\n      dispose();\n      resolve(); // don't waste time constructing/logging errors\n    });\n\n    const fetchImpl = inputFetch ?? fetch;\n    const onopen = inputOnOpen ?? defaultOnOpen;\n    async function create() {\n      curRequestController = new AbortController();\n      try {\n        const response: any = await fetchImpl(input, {\n          ...rest,\n          headers,\n          signal: curRequestController.signal\n        });\n\n        await onopen(response);\n\n        await getBytes(\n          response.body!,\n          getLines(\n            getMessages(\n              (id) => {\n                if (id) {\n                  // store the id and send it back on the next retry:\n                  headers[LastEventId] = id;\n                } else {\n                  // don't send the last-event-id header anymore:\n                  delete headers[LastEventId];\n                }\n              },\n              (_retry) => {},\n              onmessage\n            )\n          )\n        );\n\n        onclose?.();\n        dispose();\n        resolve();\n      } catch (err) {}\n    }\n\n    create();\n  });\n}\n\nfunction defaultOnOpen(response: Response) {\n  const contentType = response.headers?.get('content-type');\n  if (!contentType?.startsWith(EventStreamContentType)) {\n    throw new Error(`Expected content-type to be ${EventStreamContentType}, Actual: ${contentType}`);\n  }\n}\n","export const VERSION = '0.30.0';","import { Responses } from '.';\nimport { isObject, isString } from '../util/lang';\n\n// Polyfill for TypeScript < 4.6\nclass ErrorWithCause extends Error {\n  cause?: Error;\n\n  constructor(message?: string, options?: { cause?: Error }) {\n    // @ts-ignore - Options didn't exist before 4.6\n    super(message, options);\n  }\n}\n\nexport class FetcherError extends ErrorWithCause {\n  public status: number | string;\n  public requestId: string | undefined;\n  public errors: Responses.BulkError['errors'] | undefined;\n\n  constructor(status: number, data?: unknown, requestId?: string) {\n    super(getMessage(data));\n\n    this.status = status;\n    this.errors = isBulkError(data) ? data.errors : [{ message: getMessage(data), status }];\n    this.requestId = requestId;\n\n    if (data instanceof Error) {\n      this.stack = data.stack;\n      this.cause = (data as ErrorWithCause).cause;\n    }\n  }\n\n  toString() {\n    const error = super.toString();\n\n    return `[${this.status}] (${this.requestId ?? 'Unknown'}): ${error}`;\n  }\n}\n\nexport type PossibleErrors =\n  | Responses.BadRequestError\n  | Responses.AuthError\n  | Responses.SimpleError\n  | Responses.BulkError;\n\nfunction isBulkError(error: any): error is Responses.BulkError {\n  return isObject(error) && Array.isArray(error.errors);\n}\n\nfunction isErrorWithMessage(\n  error: any\n): error is Responses.BadRequestError | Responses.SimpleError | Responses.AuthError {\n  return isObject(error) && isString(error.message);\n}\n\nfunction getMessage(data?: unknown): string {\n  if (data instanceof Error) {\n    return data.message;\n  } else if (isString(data)) {\n    return data;\n  } else if (isErrorWithMessage(data)) {\n    return data.message;\n  } else if (isBulkError(data)) {\n    return 'Bulk operation failed';\n  } else {\n    return 'Unexpected error';\n  }\n}\n","import { isObject, isString } from '../util/lang';\n\ntype HostAliases = 'production' | 'staging' | 'dev' | 'local';\ntype ProviderBuilder = { main: string; workspaces: string };\nexport type HostProvider = HostAliases | ProviderBuilder;\n\nexport function getHostUrl(provider: HostProvider, type: keyof ProviderBuilder): string {\n  if (isHostProviderAlias(provider)) {\n    return providers[provider][type];\n  } else if (isHostProviderBuilder(provider)) {\n    return provider[type];\n  }\n\n  throw new Error('Invalid API provider');\n}\n\nconst providers: Record<HostAliases, ProviderBuilder> = {\n  production: {\n    main: 'https://api.xata.io',\n    workspaces: 'https://{workspaceId}.{region}.xata.sh'\n  },\n  staging: {\n    main: 'https://api.staging-xata.dev',\n    workspaces: 'https://{workspaceId}.{region}.staging-xata.dev'\n  },\n  dev: {\n    main: 'https://api.dev-xata.dev',\n    workspaces: 'https://{workspaceId}.{region}.dev-xata.dev'\n  },\n  local: {\n    main: 'http://localhost:6001',\n    workspaces: 'http://{workspaceId}.{region}.localhost:6001'\n  }\n};\n\nexport function isHostProviderAlias(alias?: HostProvider | string): alias is HostAliases {\n  return isString(alias) && Object.keys(providers).includes(alias);\n}\n\nexport function isHostProviderBuilder(builder: HostProvider): builder is ProviderBuilder {\n  return isObject(builder) && isString(builder.main) && isString(builder.workspaces);\n}\n\nexport function parseProviderString(provider = 'production'): HostProvider | null {\n  if (isHostProviderAlias(provider)) {\n    return provider;\n  }\n\n  const [main, workspaces] = provider.split(',');\n  if (!main || !workspaces) return null;\n  return { main, workspaces };\n}\n\nexport function buildProviderString(provider: HostProvider): string {\n  if (isHostProviderAlias(provider)) return provider;\n  return `${provider.main},${provider.workspaces}`;\n}\n\nexport function parseWorkspacesUrlParts(\n  url: string\n): { workspace: string; region: string; database: string; branch?: string; host: HostAliases } | null {\n  if (!isString(url)) return null;\n\n  const matches = {\n    production: url.match(/(?:https:\\/\\/)?([^.]+)(?:\\.([^.]+))\\.xata\\.sh\\/db\\/([^:]+):?(.*)?/),\n    staging: url.match(/(?:https:\\/\\/)?([^.]+)(?:\\.([^.]+))\\.staging-xata\\.dev\\/db\\/([^:]+):?(.*)?/),\n    dev: url.match(/(?:https:\\/\\/)?([^.]+)(?:\\.([^.]+))\\.dev-xata\\.dev\\/db\\/([^:]+):?(.*)?/),\n    local: url.match(/(?:https?:\\/\\/)?([^.]+)(?:\\.([^.]+))\\.localhost:(?:\\d+)\\/db\\/([^:]+):?(.*)?/)\n  };\n\n  const [host, match] = Object.entries(matches).find(([, match]) => match !== null) ?? [];\n  if (!isHostProviderAlias(host) || !match) return null;\n\n  return { workspace: match[1], region: match[2], database: match[3], branch: match[4], host };\n}\n","import { TraceAttributes, TraceFunction } from '../schema/tracing';\nimport { ApiRequestPool, FetchImpl } from '../util/fetch';\nimport { compact, compactObject, isBlob, isDefined, isObject, isString } from '../util/lang';\nimport { fetchEventSource } from '../util/sse';\nimport { generateUUID } from '../util/uuid';\nimport { VERSION } from '../version';\nimport { FetcherError, PossibleErrors } from './errors';\nimport { parseWorkspacesUrlParts } from './providers';\n\nconst pool = new ApiRequestPool();\n\nconst resolveUrl = (\n  url: string,\n  queryParams: Record<string, any> = {},\n  pathParams: Partial<Record<string, string | number>> = {}\n) => {\n  // Remove nulls and undefineds from query params\n  const cleanQueryParams = Object.entries(queryParams).reduce((acc, [key, value]) => {\n    if (value === undefined || value === null) return acc;\n    return { ...acc, [key]: value };\n  }, {} as Record<string, any>);\n\n  const query = new URLSearchParams(cleanQueryParams).toString();\n  const queryString = query.length > 0 ? `?${query}` : '';\n\n  // We need to encode the path params because they can contain special characters\n  // Special case, `:` does not need to be encoded as we use it as a separator\n  const cleanPathParams = Object.entries(pathParams).reduce((acc, [key, value]) => {\n    return { ...acc, [key]: encodeURIComponent(String(value ?? '')).replace('%3A', ':') };\n  }, {} as Record<string, string>);\n\n  return url.replace(/\\{\\w*\\}/g, (key) => cleanPathParams[key.slice(1, -1)]) + queryString;\n};\n\nexport type WorkspaceApiUrlBuilder = (path: string, pathParams: Partial<Record<string, string | number>>) => string;\n\nexport type FetcherExtraProps = {\n  endpoint: 'controlPlane' | 'dataPlane';\n  apiUrl: string;\n  workspacesApiUrl: string | WorkspaceApiUrlBuilder;\n  fetch: FetchImpl;\n  apiKey: string;\n  trace: TraceFunction;\n  signal?: AbortSignal;\n  clientID?: string;\n  sessionID?: string;\n  clientName?: string;\n  xataAgentExtra?: Record<string, string>;\n  fetchOptions?: Record<string, unknown>;\n  rawResponse?: boolean;\n  headers?: Record<string, unknown>;\n};\n\nexport type ErrorWrapper<TError> = TError | { status: 'unknown'; payload: string };\n\nexport type FetcherOptions<TBody, THeaders, TQueryParams, TPathParams> = {\n  url: string;\n  method: string;\n  body?: TBody;\n  headers?: THeaders;\n  queryParams?: TQueryParams;\n  pathParams?: TPathParams;\n} & FetcherExtraProps;\n\nfunction buildBaseUrl({\n  method,\n  endpoint,\n  path,\n  workspacesApiUrl,\n  apiUrl,\n  pathParams = {}\n}: {\n  method: string;\n  endpoint: 'controlPlane' | 'dataPlane';\n  path: string;\n  workspacesApiUrl: string | WorkspaceApiUrlBuilder;\n  apiUrl: string;\n  pathParams?: Partial<Record<string, string | number>>;\n}): string {\n  if (endpoint === 'dataPlane') {\n    let url = isString(workspacesApiUrl) ? `${workspacesApiUrl}${path}` : workspacesApiUrl(path, pathParams);\n\n    // Special case, for file uploads, we have a different subdomain\n    // TODO: We should re-use OpenAPI spec to determine this via servers variables\n    if (\n      method.toUpperCase() === 'PUT' &&\n      [\n        '/db/{dbBranchName}/tables/{tableName}/data/{recordId}/column/{columnName}/file',\n        '/db/{dbBranchName}/tables/{tableName}/data/{recordId}/column/{columnName}/file/{fileId}'\n      ].includes(path)\n    ) {\n      const { host } = parseWorkspacesUrlParts(url) ?? {};\n      switch (host) {\n        case 'production':\n          url = url.replace('xata.sh', 'upload.xata.sh');\n          break;\n        case 'staging':\n          url = url.replace('staging-xata.dev', 'upload.staging-xata.dev');\n          break;\n        case 'dev':\n          url = url.replace('dev-xata.dev', 'upload.dev-xata.dev');\n          break;\n      }\n    }\n\n    const urlWithWorkspace = isString(pathParams.workspace)\n      ? url.replace('{workspaceId}', String(pathParams.workspace))\n      : url;\n\n    return isString(pathParams.region)\n      ? urlWithWorkspace.replace('{region}', String(pathParams.region))\n      : urlWithWorkspace;\n  }\n\n  return `${apiUrl}${path}`;\n}\n\n// The host header is needed by Node.js on localhost.\n// It is ignored by fetch() in the frontend\nfunction hostHeader(url: string): { Host?: string } {\n  const pattern = /.*:\\/\\/(?<host>[^/]+).*/;\n  const { groups } = pattern.exec(url) ?? {};\n\n  return groups?.host ? { Host: groups.host } : {};\n}\n\nasync function parseBody<T>(body?: T, headers?: Record<string, unknown>): Promise<any> {\n  if (!isDefined(body)) return undefined;\n\n  // If body is a blob or has a text() method, we don't need to do anything\n  if (isBlob(body) || typeof (body as any).text === 'function') {\n    return body;\n  }\n\n  const { 'Content-Type': contentType } = headers ?? {};\n  if (String(contentType).toLowerCase() === 'application/json' && isObject(body)) {\n    return JSON.stringify(body);\n  }\n\n  return body;\n}\n\nconst defaultClientID = generateUUID();\n\nexport async function fetch<\n  TData,\n  TError extends ErrorWrapper<{ status: unknown; payload: PossibleErrors }>,\n  TBody extends Record<string, unknown> | Record<string, unknown>[] | Blob | undefined | null,\n  THeaders extends Record<string, unknown>,\n  TQueryParams extends Record<string, unknown>,\n  TPathParams extends Partial<Record<string, string | number>>\n>({\n  url: path,\n  method,\n  body,\n  headers: customHeaders,\n  pathParams,\n  queryParams,\n  fetch,\n  apiKey,\n  endpoint,\n  apiUrl,\n  workspacesApiUrl,\n  trace,\n  signal,\n  clientID,\n  sessionID,\n  clientName,\n  xataAgentExtra,\n  fetchOptions = {},\n  rawResponse = false\n}: FetcherOptions<TBody, THeaders, TQueryParams, TPathParams> & FetcherExtraProps): Promise<TData> {\n  pool.setFetch(fetch);\n\n  return await trace(\n    `${method.toUpperCase()} ${path}`,\n    async ({ setAttributes }) => {\n      const baseUrl = buildBaseUrl({ method, endpoint, path, workspacesApiUrl, pathParams, apiUrl });\n      const fullUrl = resolveUrl(baseUrl, queryParams, pathParams);\n\n      // Node.js on localhost won't resolve localhost subdomains unless mapped in /etc/hosts\n      // So, instead, we use localhost without subdomains, but will add a Host header\n      // We remove two subdomains because we need be able to resolve localhost URLs like\n      // http://ws-id.dev.localhost\n      const url = fullUrl.includes('localhost') ? fullUrl.replace(/^[^.]+\\.[^.]+\\./, 'http://') : fullUrl;\n      setAttributes({\n        [TraceAttributes.HTTP_URL]: url,\n        [TraceAttributes.HTTP_TARGET]: resolveUrl(path, queryParams, pathParams)\n      });\n\n      const xataAgent = compact([\n        ['client', 'TS_SDK'],\n        ['version', VERSION],\n        isDefined(clientName) ? ['service', clientName] : undefined,\n        ...Object.entries(xataAgentExtra ?? {})\n      ])\n        .map(([key, value]) => `${key}=${value}`)\n        .join('; ');\n\n      const headers = compactObject({\n        'Accept-Encoding': 'identity',\n        'Content-Type': 'application/json',\n        'X-Xata-Client-ID': clientID ?? defaultClientID,\n        'X-Xata-Session-ID': sessionID ?? generateUUID(),\n        'X-Xata-Agent': xataAgent,\n        // Force field rename to xata_ internal properties\n        'X-Features': compact(['feat-internal-field-rename-api=1', customHeaders?.['X-Features']]).join(' '),\n        ...customHeaders,\n        ...hostHeader(fullUrl),\n        Authorization: `Bearer ${apiKey}`\n      });\n\n      const response = await pool.request(url, {\n        ...fetchOptions,\n        method: method.toUpperCase(),\n        body: await parseBody(body, headers),\n        headers,\n        signal\n      });\n\n      const { host, protocol } = parseUrl(response.url);\n      const requestId = response.headers?.get('x-request-id') ?? undefined;\n      setAttributes({\n        [TraceAttributes.KIND]: 'http',\n        [TraceAttributes.HTTP_REQUEST_ID]: requestId,\n        [TraceAttributes.HTTP_STATUS_CODE]: response.status,\n        [TraceAttributes.HTTP_HOST]: host,\n        [TraceAttributes.HTTP_SCHEME]: protocol?.replace(':', ''),\n        [TraceAttributes.CLOUDFLARE_RAY_ID]: response.headers?.get('cf-ray') ?? undefined\n      });\n\n      const message = response.headers?.get('x-xata-message');\n      if (message) console.warn(message);\n\n      // No content\n      if (response.status === 204) {\n        return {} as unknown as TData;\n      }\n\n      // Rate limit exceeded\n      if (response.status === 429) {\n        throw new FetcherError(response.status, 'Rate limit exceeded', requestId);\n      }\n\n      try {\n        const jsonResponse = rawResponse ? await response.blob() : await response.json();\n\n        if (response.ok) {\n          return jsonResponse;\n        }\n\n        throw new FetcherError(response.status, jsonResponse as TError['payload'], requestId);\n      } catch (error) {\n        throw new FetcherError(response.status, error, requestId);\n      }\n    },\n    { [TraceAttributes.HTTP_METHOD]: method.toUpperCase(), [TraceAttributes.HTTP_ROUTE]: path }\n  );\n}\n\nexport function fetchSSERequest<\n  TData,\n  TError extends ErrorWrapper<{ status: unknown; payload: PossibleErrors }>,\n  TBody extends Record<string, unknown> | undefined | null,\n  THeaders extends Record<string, unknown>,\n  TQueryParams extends Record<string, unknown>,\n  TPathParams extends Partial<Record<string, string | number>>\n>({\n  url: path,\n  method,\n  body,\n  headers: customHeaders,\n  pathParams,\n  queryParams,\n  fetch,\n  apiKey,\n  endpoint,\n  apiUrl,\n  workspacesApiUrl,\n  onMessage,\n  onError,\n  onClose,\n  signal,\n  clientID,\n  sessionID,\n  clientName,\n  xataAgentExtra\n}: FetcherOptions<TBody, THeaders, TQueryParams, TPathParams> &\n  FetcherExtraProps & {\n    onMessage?: (message: TData) => void;\n    onError?: (error: TError) => void;\n    onClose?: () => void;\n  }): void {\n  const baseUrl = buildBaseUrl({ method, endpoint, path, workspacesApiUrl, pathParams, apiUrl });\n  const fullUrl = resolveUrl(baseUrl, queryParams, pathParams);\n\n  // Node.js on localhost won't resolve localhost subdomains unless mapped in /etc/hosts\n  // So, instead, we use localhost without subdomains, but will add a Host header\n  const url = fullUrl.includes('localhost') ? fullUrl.replace(/^[^.]+\\./, 'http://') : fullUrl;\n\n  void fetchEventSource(url, {\n    method,\n    body: JSON.stringify(body),\n    fetch,\n    signal,\n    headers: {\n      'X-Xata-Client-ID': clientID ?? defaultClientID,\n      'X-Xata-Session-ID': sessionID ?? generateUUID(),\n      'X-Xata-Agent': compact([\n        ['client', 'TS_SDK'],\n        ['version', VERSION],\n        isDefined(clientName) ? ['service', clientName] : undefined,\n        ...Object.entries(xataAgentExtra ?? {})\n      ])\n        .map(([key, value]) => `${key}=${value}`)\n        .join('; '),\n      ...customHeaders,\n      Authorization: `Bearer ${apiKey}`,\n      'Content-Type': 'application/json'\n    },\n    onmessage(ev) {\n      onMessage?.(JSON.parse(ev.data));\n    },\n    onerror(ev) {\n      onError?.(JSON.parse(ev.data));\n    },\n    onclose() {\n      onClose?.();\n    }\n  });\n}\n\nfunction parseUrl(url: string): { host?: string; protocol?: string } {\n  try {\n    const { host, protocol } = new URL(url);\n\n    return { host, protocol };\n  } catch (error) {\n    return {};\n  }\n}\n","import { TraceFunction } from '../schema/tracing';\nimport { FetchImpl } from '../util/fetch';\nimport { PossibleErrors } from './errors';\nimport { fetch, WorkspaceApiUrlBuilder } from './fetcher';\n\nexport type DataPlaneFetcherExtraProps = {\n  apiUrl: string;\n  workspacesApiUrl: string | WorkspaceApiUrlBuilder;\n  fetch: FetchImpl;\n  apiKey: string;\n  trace: TraceFunction;\n  signal?: AbortSignal;\n  clientID?: string;\n  sessionID?: string;\n  clientName?: string;\n  xataAgentExtra?: Record<string, string>;\n  rawResponse?: boolean;\n  headers?: Record<string, unknown>;\n};\n\nexport type ErrorWrapper<TError> = TError | { status: 'unknown'; payload: string };\n\nexport type DataPlaneFetcherOptions<TBody, THeaders, TQueryParams, TPathParams> = {\n  url: string;\n  method: string;\n  body?: TBody;\n  headers?: THeaders;\n  queryParams?: TQueryParams;\n  pathParams?: TPathParams;\n  signal?: AbortSignal;\n} & DataPlaneFetcherExtraProps;\n\nexport const dataPlaneFetch = async <\n  TData,\n  TError extends ErrorWrapper<{ status: unknown; payload: PossibleErrors }>,\n  TBody extends Record<string, unknown> | Record<string, unknown>[] | Blob | undefined | null,\n  THeaders extends Record<string, unknown>,\n  TQueryParams extends Record<string, unknown>,\n  TPathParams extends Partial<Record<string, string | number>>\n>(\n  options: DataPlaneFetcherOptions<TBody, THeaders, TQueryParams, TPathParams>\n): Promise<TData> =>\n  fetch<TData, TError, TBody, THeaders, TQueryParams, TPathParams>({ ...options, endpoint: 'dataPlane' });\n","/**\n * Generated by @openapi-codegen\n *\n * @version 1.0\n */\nimport type * as Fetcher from './dataPlaneFetcher';\nimport { dataPlaneFetch, DataPlaneFetcherExtraProps } from './dataPlaneFetcher';\nimport type * as Schemas from './dataPlaneSchemas';\nimport type * as Responses from './dataPlaneResponses';\n\nexport type GetTasksPathParams = {\n  workspace: string;\n  region: string;\n};\n\nexport type GetTasksError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type GetTasksResponse = Schemas.TaskStatusResponse[];\n\nexport type GetTasksVariables = {\n  pathParams: GetTasksPathParams;\n} & DataPlaneFetcherExtraProps;\n\nexport const getTasks = (variables: GetTasksVariables, signal?: AbortSignal) =>\n  dataPlaneFetch<GetTasksResponse, GetTasksError, undefined, {}, {}, GetTasksPathParams>({\n    url: '/tasks',\n    method: 'get',\n    ...variables,\n    signal\n  });\n\nexport type GetTaskStatusPathParams = {\n  /**\n   * The id of the branch creation task\n   */\n  taskId: Schemas.TaskID;\n  workspace: string;\n  region: string;\n};\n\nexport type GetTaskStatusError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type GetTaskStatusVariables = {\n  pathParams: GetTaskStatusPathParams;\n} & DataPlaneFetcherExtraProps;\n\nexport const getTaskStatus = (variables: GetTaskStatusVariables, signal?: AbortSignal) =>\n  dataPlaneFetch<Schemas.TaskStatusResponse, GetTaskStatusError, undefined, {}, {}, GetTaskStatusPathParams>({\n    url: '/tasks/{taskId}',\n    method: 'get',\n    ...variables,\n    signal\n  });\n\nexport type ListClusterBranchesPathParams = {\n  /**\n   * Cluster ID\n   */\n  clusterId: Schemas.ClusterID;\n  workspace: string;\n  region: string;\n};\n\nexport type ListClusterBranchesQueryParams = {\n  /**\n   * Page size\n   */\n  page?: Schemas.PageSize;\n  /**\n   * Page token\n   */\n  token?: Schemas.PageToken;\n};\n\nexport type ListClusterBranchesError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n>;\n\nexport type ListClusterBranchesVariables = {\n  pathParams: ListClusterBranchesPathParams;\n  queryParams?: ListClusterBranchesQueryParams;\n} & DataPlaneFetcherExtraProps;\n\n/**\n * Retrieve branches for given cluster ID\n */\nexport const listClusterBranches = (variables: ListClusterBranchesVariables, signal?: AbortSignal) =>\n  dataPlaneFetch<\n    Schemas.ListClusterBranchesResponse,\n    ListClusterBranchesError,\n    undefined,\n    {},\n    ListClusterBranchesQueryParams,\n    ListClusterBranchesPathParams\n  >({\n    url: '/cluster/{clusterId}/branches',\n    method: 'get',\n    ...variables,\n    signal\n  });\n\nexport type ListClusterExtensionsPathParams = {\n  /**\n   * Cluster ID\n   */\n  clusterId: Schemas.ClusterID;\n  workspace: string;\n  region: string;\n};\n\nexport type ListClusterExtensionsQueryParams = {\n  extensionType: 'available' | 'installed';\n};\n\nexport type ListClusterExtensionsError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n>;\n\nexport type ListClusterExtensionsVariables = {\n  pathParams: ListClusterExtensionsPathParams;\n  queryParams: ListClusterExtensionsQueryParams;\n} & DataPlaneFetcherExtraProps;\n\n/**\n * Retrieve extensions for given cluster ID\n */\nexport const listClusterExtensions = (variables: ListClusterExtensionsVariables, signal?: AbortSignal) =>\n  dataPlaneFetch<\n    Schemas.ListClusterExtensionsResponse,\n    ListClusterExtensionsError,\n    undefined,\n    {},\n    ListClusterExtensionsQueryParams,\n    ListClusterExtensionsPathParams\n  >({\n    url: '/cluster/{clusterId}/extensions',\n    method: 'get',\n    ...variables,\n    signal\n  });\n\nexport type InstallClusterExtensionPathParams = {\n  /**\n   * Cluster ID\n   */\n  clusterId: Schemas.ClusterID;\n  workspace: string;\n  region: string;\n};\n\nexport type InstallClusterExtensionError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n>;\n\nexport type InstallClusterExtensionRequestBody = {\n  /**\n   * Extension name\n   */\n  extension: string;\n  /**\n   * Schema name\n   */\n  schema?: string;\n  /**\n   * install with cascade option\n   */\n  cascade?: boolean;\n};\n\nexport type InstallClusterExtensionVariables = {\n  body: InstallClusterExtensionRequestBody;\n  pathParams: InstallClusterExtensionPathParams;\n} & DataPlaneFetcherExtraProps;\n\n/**\n * Install an extension for given cluster ID\n */\nexport const installClusterExtension = (variables: InstallClusterExtensionVariables, signal?: AbortSignal) =>\n  dataPlaneFetch<\n    Schemas.ClusterExtensionInstallationResponse,\n    InstallClusterExtensionError,\n    InstallClusterExtensionRequestBody,\n    {},\n    {},\n    InstallClusterExtensionPathParams\n  >({\n    url: '/cluster/{clusterId}/extensions',\n    method: 'post',\n    ...variables,\n    signal\n  });\n\nexport type DropClusterExtensionPathParams = {\n  /**\n   * Cluster ID\n   */\n  clusterId: Schemas.ClusterID;\n  workspace: string;\n  region: string;\n};\n\nexport type DropClusterExtensionError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n>;\n\nexport type DropClusterExtensionRequestBody = {\n  /**\n   * Extension name\n   */\n  extension: string;\n  /**\n   * drop with cascade option, true by default\n   */\n  cascade?: boolean;\n};\n\nexport type DropClusterExtensionVariables = {\n  body: DropClusterExtensionRequestBody;\n  pathParams: DropClusterExtensionPathParams;\n} & DataPlaneFetcherExtraProps;\n\n/**\n * Drop an extension for given cluster ID\n */\nexport const dropClusterExtension = (variables: DropClusterExtensionVariables, signal?: AbortSignal) =>\n  dataPlaneFetch<\n    undefined,\n    DropClusterExtensionError,\n    DropClusterExtensionRequestBody,\n    {},\n    {},\n    DropClusterExtensionPathParams\n  >({\n    url: '/cluster/{clusterId}/extensions',\n    method: 'delete',\n    ...variables,\n    signal\n  });\n\nexport type GetClusterMetricsPathParams = {\n  /**\n   * Cluster ID\n   */\n  clusterId: Schemas.ClusterID;\n  workspace: string;\n  region: string;\n};\n\nexport type GetClusterMetricsQueryParams = {\n  startTime: string;\n  endTime: string;\n  period: '5min' | '15min' | '1hour';\n  /**\n   * Page size\n   */\n  page?: Schemas.PageSize;\n  /**\n   * Page token\n   */\n  token?: Schemas.PageToken;\n};\n\nexport type GetClusterMetricsError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type GetClusterMetricsVariables = {\n  pathParams: GetClusterMetricsPathParams;\n  queryParams: GetClusterMetricsQueryParams;\n} & DataPlaneFetcherExtraProps;\n\n/**\n * retrieve a standard set of RDS cluster metrics\n */\nexport const getClusterMetrics = (variables: GetClusterMetricsVariables, signal?: AbortSignal) =>\n  dataPlaneFetch<\n    Schemas.MetricsResponse,\n    GetClusterMetricsError,\n    undefined,\n    {},\n    GetClusterMetricsQueryParams,\n    GetClusterMetricsPathParams\n  >({\n    url: '/cluster/{clusterId}/metrics',\n    method: 'get',\n    ...variables,\n    signal\n  });\n\nexport type ApplyMigrationPathParams = {\n  /**\n   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.\n   */\n  dbBranchName: Schemas.DBBranchName;\n  workspace: string;\n  region: string;\n};\n\nexport type ApplyMigrationError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type ApplyMigrationRequestBody = {\n  /**\n   * Migration name\n   */\n  name?: string;\n  operations: {\n    [key: string]: any;\n  }[];\n  /**\n   * The schema in which the migration should be applied\n   *\n   * @default public\n   */\n  schema?: string;\n  adaptTables?: boolean;\n};\n\nexport type ApplyMigrationVariables = {\n  body: ApplyMigrationRequestBody;\n  pathParams: ApplyMigrationPathParams;\n} & DataPlaneFetcherExtraProps;\n\n/**\n * Applies a pgroll migration to the specified database.\n */\nexport const applyMigration = (variables: ApplyMigrationVariables, signal?: AbortSignal) =>\n  dataPlaneFetch<\n    Schemas.ApplyMigrationResponse,\n    ApplyMigrationError,\n    ApplyMigrationRequestBody,\n    {},\n    {},\n    ApplyMigrationPathParams\n  >({\n    url: '/db/{dbBranchName}/migrations/apply',\n    method: 'post',\n    ...variables,\n    signal\n  });\n\nexport type StartMigrationPathParams = {\n  /**\n   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.\n   */\n  dbBranchName: Schemas.DBBranchName;\n  workspace: string;\n  region: string;\n};\n\nexport type StartMigrationError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type StartMigrationRequestBody = {\n  /**\n   * Migration name\n   */\n  name?: string;\n  operations: {\n    [key: string]: any;\n  }[];\n  /**\n   * The schema in which the migration should be started\n   *\n   * @default public\n   */\n  schema?: string;\n};\n\nexport type StartMigrationVariables = {\n  body: StartMigrationRequestBody;\n  pathParams: StartMigrationPathParams;\n} & DataPlaneFetcherExtraProps;\n\n/**\n * Starts a pgroll migration on the specified database.\n */\nexport const startMigration = (variables: StartMigrationVariables, signal?: AbortSignal) =>\n  dataPlaneFetch<\n    Schemas.StartMigrationResponse,\n    StartMigrationError,\n    StartMigrationRequestBody,\n    {},\n    {},\n    StartMigrationPathParams\n  >({\n    url: '/db/{dbBranchName}/migrations/start',\n    method: 'post',\n    ...variables,\n    signal\n  });\n\nexport type CompleteMigrationPathParams = {\n  /**\n   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.\n   */\n  dbBranchName: Schemas.DBBranchName;\n  workspace: string;\n  region: string;\n};\n\nexport type CompleteMigrationError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type CompleteMigrationRequestBody = {\n  /**\n   * The schema in which the migration should be completed\n   *\n   * @default public\n   */\n  schema?: string;\n};\n\nexport type CompleteMigrationVariables = {\n  body?: CompleteMigrationRequestBody;\n  pathParams: CompleteMigrationPathParams;\n} & DataPlaneFetcherExtraProps;\n\n/**\n * Complete an active migration on the specified database\n */\nexport const completeMigration = (variables: CompleteMigrationVariables, signal?: AbortSignal) =>\n  dataPlaneFetch<\n    Schemas.CompleteMigrationResponse,\n    CompleteMigrationError,\n    CompleteMigrationRequestBody,\n    {},\n    {},\n    CompleteMigrationPathParams\n  >({\n    url: '/db/{dbBranchName}/migrations/complete',\n    method: 'post',\n    ...variables,\n    signal\n  });\n\nexport type RollbackMigrationPathParams = {\n  /**\n   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.\n   */\n  dbBranchName: Schemas.DBBranchName;\n  workspace: string;\n  region: string;\n};\n\nexport type RollbackMigrationError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type RollbackMigrationRequestBody = {\n  /**\n   * The schema in which the migration should be rolled back\n   *\n   * @default public\n   */\n  schema?: string;\n};\n\nexport type RollbackMigrationVariables = {\n  body?: RollbackMigrationRequestBody;\n  pathParams: RollbackMigrationPathParams;\n} & DataPlaneFetcherExtraProps;\n\n/**\n * Roll back an active migration on the specified database\n */\nexport const rollbackMigration = (variables: RollbackMigrationVariables, signal?: AbortSignal) =>\n  dataPlaneFetch<\n    Schemas.RollbackMigrationResponse,\n    RollbackMigrationError,\n    RollbackMigrationRequestBody,\n    {},\n    {},\n    RollbackMigrationPathParams\n  >({\n    url: '/db/{dbBranchName}/migrations/rollback',\n    method: 'post',\n    ...variables,\n    signal\n  });\n\nexport type AdaptTablePathParams = {\n  /**\n   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.\n   */\n  dbBranchName: Schemas.DBBranchName;\n  /**\n   * The Table name\n   */\n  tableName: Schemas.TableName;\n  workspace: string;\n  region: string;\n};\n\nexport type AdaptTableError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type AdaptTableVariables = {\n  pathParams: AdaptTablePathParams;\n} & DataPlaneFetcherExtraProps;\n\n/**\n * Adapt a table to be used from Xata, this will add the Xata metadata fields to the table, making it accessible through the data API.\n */\nexport const adaptTable = (variables: AdaptTableVariables, signal?: AbortSignal) =>\n  dataPlaneFetch<Schemas.ApplyMigrationResponse, AdaptTableError, undefined, {}, {}, AdaptTablePathParams>({\n    url: '/db/{dbBranchName}/migrations/adapt/{tableName}',\n    method: 'post',\n    ...variables,\n    signal\n  });\n\nexport type AdaptAllTablesPathParams = {\n  /**\n   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.\n   */\n  dbBranchName: Schemas.DBBranchName;\n  workspace: string;\n  region: string;\n};\n\nexport type AdaptAllTablesError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type AdaptAllTablesVariables = {\n  pathParams: AdaptAllTablesPathParams;\n} & DataPlaneFetcherExtraProps;\n\n/**\n * Adapt all xata incompatible tables present in the branch, this will add the Xata metadata fields to the table, making them accessible through the data API.\n */\nexport const adaptAllTables = (variables: AdaptAllTablesVariables, signal?: AbortSignal) =>\n  dataPlaneFetch<Schemas.ApplyMigrationResponse, AdaptAllTablesError, undefined, {}, {}, AdaptAllTablesPathParams>({\n    url: '/db/{dbBranchName}/migrations/adapt',\n    method: 'post',\n    ...variables,\n    signal\n  });\n\nexport type GetBranchMigrationJobStatusPathParams = {\n  /**\n   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.\n   */\n  dbBranchName: Schemas.DBBranchName;\n  workspace: string;\n  region: string;\n};\n\nexport type GetBranchMigrationJobStatusError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type GetBranchMigrationJobStatusVariables = {\n  pathParams: GetBranchMigrationJobStatusPathParams;\n} & DataPlaneFetcherExtraProps;\n\nexport const getBranchMigrationJobStatus = (variables: GetBranchMigrationJobStatusVariables, signal?: AbortSignal) =>\n  dataPlaneFetch<\n    Schemas.MigrationJobStatusResponse,\n    GetBranchMigrationJobStatusError,\n    undefined,\n    {},\n    {},\n    GetBranchMigrationJobStatusPathParams\n  >({\n    url: '/db/{dbBranchName}/migrations/status',\n    method: 'get',\n    ...variables,\n    signal\n  });\n\nexport type GetMigrationJobsPathParams = {\n  /**\n   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.\n   */\n  dbBranchName: Schemas.DBBranchName;\n  workspace: string;\n  region: string;\n};\n\nexport type GetMigrationJobsQueryParams = {\n  /**\n   * @format date-time\n   */\n  cursor?: string;\n  /**\n   * Page size\n   */\n  limit?: Schemas.PageSize;\n};\n\nexport type GetMigrationJobsError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type GetMigrationJobsVariables = {\n  pathParams: GetMigrationJobsPathParams;\n  queryParams?: GetMigrationJobsQueryParams;\n} & DataPlaneFetcherExtraProps;\n\nexport const getMigrationJobs = (variables: GetMigrationJobsVariables, signal?: AbortSignal) =>\n  dataPlaneFetch<\n    Schemas.GetMigrationJobsResponse,\n    GetMigrationJobsError,\n    undefined,\n    {},\n    GetMigrationJobsQueryParams,\n    GetMigrationJobsPathParams\n  >({\n    url: '/db/{dbBranchName}/migrations/jobs',\n    method: 'get',\n    ...variables,\n    signal\n  });\n\nexport type GetMigrationJobStatusPathParams = {\n  /**\n   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.\n   */\n  dbBranchName: Schemas.DBBranchName;\n  /**\n   * The id of the migration job\n   */\n  jobId: Schemas.MigrationJobID;\n  workspace: string;\n  region: string;\n};\n\nexport type GetMigrationJobStatusError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type GetMigrationJobStatusVariables = {\n  pathParams: GetMigrationJobStatusPathParams;\n} & DataPlaneFetcherExtraProps;\n\nexport const getMigrationJobStatus = (variables: GetMigrationJobStatusVariables, signal?: AbortSignal) =>\n  dataPlaneFetch<\n    Schemas.MigrationJobStatusResponse,\n    GetMigrationJobStatusError,\n    undefined,\n    {},\n    {},\n    GetMigrationJobStatusPathParams\n  >({\n    url: '/db/{dbBranchName}/migrations/jobs/{jobId}',\n    method: 'get',\n    ...variables,\n    signal\n  });\n\nexport type GetMigrationHistoryPathParams = {\n  /**\n   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.\n   */\n  dbBranchName: Schemas.DBBranchName;\n  workspace: string;\n  region: string;\n};\n\nexport type GetMigrationHistoryQueryParams = {\n  /**\n   * @format date-time\n   */\n  cursor?: string;\n  /**\n   * Page size\n   */\n  limit?: Schemas.PageSize;\n};\n\nexport type GetMigrationHistoryError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type GetMigrationHistoryVariables = {\n  pathParams: GetMigrationHistoryPathParams;\n  queryParams?: GetMigrationHistoryQueryParams;\n} & DataPlaneFetcherExtraProps;\n\nexport const getMigrationHistory = (variables: GetMigrationHistoryVariables, signal?: AbortSignal) =>\n  dataPlaneFetch<\n    Schemas.MigrationHistoryResponse,\n    GetMigrationHistoryError,\n    undefined,\n    {},\n    GetMigrationHistoryQueryParams,\n    GetMigrationHistoryPathParams\n  >({\n    url: '/db/{dbBranchName}/migrations/history',\n    method: 'get',\n    ...variables,\n    signal\n  });\n\nexport type GetBranchListPathParams = {\n  /**\n   * The Database Name\n   */\n  dbName: Schemas.DBName;\n  workspace: string;\n  region: string;\n};\n\nexport type GetBranchListError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type GetBranchListVariables = {\n  pathParams: GetBranchListPathParams;\n} & DataPlaneFetcherExtraProps;\n\n/**\n * List all available Branches\n */\nexport const getBranchList = (variables: GetBranchListVariables, signal?: AbortSignal) =>\n  dataPlaneFetch<Schemas.ListBranchesResponse, GetBranchListError, undefined, {}, {}, GetBranchListPathParams>({\n    url: '/dbs/{dbName}',\n    method: 'get',\n    ...variables,\n    signal\n  });\n\nexport type GetDatabaseSettingsPathParams = {\n  /**\n   * The Database Name\n   */\n  dbName: Schemas.DBName;\n  workspace: string;\n  region: string;\n};\n\nexport type GetDatabaseSettingsError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.SimpleError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type GetDatabaseSettingsVariables = {\n  pathParams: GetDatabaseSettingsPathParams;\n} & DataPlaneFetcherExtraProps;\n\n/**\n * Get database settings\n */\nexport const getDatabaseSettings = (variables: GetDatabaseSettingsVariables, signal?: AbortSignal) =>\n  dataPlaneFetch<Schemas.DatabaseSettings, GetDatabaseSettingsError, undefined, {}, {}, GetDatabaseSettingsPathParams>({\n    url: '/dbs/{dbName}/settings',\n    method: 'get',\n    ...variables,\n    signal\n  });\n\nexport type UpdateDatabaseSettingsPathParams = {\n  /**\n   * The Database Name\n   */\n  dbName: Schemas.DBName;\n  workspace: string;\n  region: string;\n};\n\nexport type UpdateDatabaseSettingsError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.SimpleError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type UpdateDatabaseSettingsRequestBody = {\n  searchEnabled?: boolean;\n};\n\nexport type UpdateDatabaseSettingsVariables = {\n  body?: UpdateDatabaseSettingsRequestBody;\n  pathParams: UpdateDatabaseSettingsPathParams;\n} & DataPlaneFetcherExtraProps;\n\n/**\n * Update database settings, this endpoint can be used to disable search\n */\nexport const updateDatabaseSettings = (variables: UpdateDatabaseSettingsVariables, signal?: AbortSignal) =>\n  dataPlaneFetch<\n    Schemas.DatabaseSettings,\n    UpdateDatabaseSettingsError,\n    UpdateDatabaseSettingsRequestBody,\n    {},\n    {},\n    UpdateDatabaseSettingsPathParams\n  >({ url: '/dbs/{dbName}/settings', method: 'patch', ...variables, signal });\n\nexport type CreateBranchAsyncPathParams = {\n  /**\n   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.\n   */\n  dbBranchName: Schemas.DBBranchName;\n  workspace: string;\n  region: string;\n};\n\nexport type CreateBranchAsyncQueryParams = {\n  /**\n   * Name of source branch to branch the new schema from\n   */\n  from?: string;\n};\n\nexport type CreateBranchAsyncError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n  | {\n      status: 423;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type CreateBranchAsyncRequestBody = {\n  /**\n   * Select the branch to fork from. Defaults to 'main'\n   */\n  from?: string;\n  /**\n   * Select the dedicated cluster to create on. Defaults to 'xata-cloud'\n   *\n   * @minLength 1\n   * @x-internal true\n   */\n  clusterID?: string;\n  metadata?: Schemas.BranchMetadata;\n};\n\nexport type CreateBranchAsyncVariables = {\n  body?: CreateBranchAsyncRequestBody;\n  pathParams: CreateBranchAsyncPathParams;\n  queryParams?: CreateBranchAsyncQueryParams;\n} & DataPlaneFetcherExtraProps;\n\nexport const createBranchAsync = (variables: CreateBranchAsyncVariables, signal?: AbortSignal) =>\n  dataPlaneFetch<\n    Schemas.CreateBranchResponse,\n    CreateBranchAsyncError,\n    CreateBranchAsyncRequestBody,\n    {},\n    CreateBranchAsyncQueryParams,\n    CreateBranchAsyncPathParams\n  >({ url: '/db/{dbBranchName}/async', method: 'put', ...variables, signal });\n\nexport type GetBranchDetailsPathParams = {\n  /**\n   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.\n   */\n  dbBranchName: Schemas.DBBranchName;\n  workspace: string;\n  region: string;\n};\n\nexport type GetBranchDetailsError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type GetBranchDetailsVariables = {\n  pathParams: GetBranchDetailsPathParams;\n} & DataPlaneFetcherExtraProps;\n\nexport const getBranchDetails = (variables: GetBranchDetailsVariables, signal?: AbortSignal) =>\n  dataPlaneFetch<Schemas.DBBranch, GetBranchDetailsError, undefined, {}, {}, GetBranchDetailsPathParams>({\n    url: '/db/{dbBranchName}',\n    method: 'get',\n    ...variables,\n    signal\n  });\n\nexport type CreateBranchPathParams = {\n  /**\n   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.\n   */\n  dbBranchName: Schemas.DBBranchName;\n  workspace: string;\n  region: string;\n};\n\nexport type CreateBranchQueryParams = {\n  /**\n   * Name of source branch to branch the new schema from\n   */\n  from?: string;\n};\n\nexport type CreateBranchError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n  | {\n      status: 423;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type CreateBranchResponse = {\n  /**\n   * @minLength 1\n   */\n  databaseName: string;\n  branchName: string;\n  status: Schemas.MigrationStatus;\n};\n\nexport type CreateBranchRequestBody = {\n  /**\n   * Select the branch to fork from. Defaults to 'main'\n   */\n  from?: string;\n  /**\n   * Select the dedicated cluster to create on. Defaults to 'xata-cloud'\n   *\n   * @minLength 1\n   * @x-internal true\n   */\n  clusterID?: string;\n  metadata?: Schemas.BranchMetadata;\n};\n\nexport type CreateBranchVariables = {\n  body?: CreateBranchRequestBody;\n  pathParams: CreateBranchPathParams;\n  queryParams?: CreateBranchQueryParams;\n} & DataPlaneFetcherExtraProps;\n\nexport const createBranch = (variables: CreateBranchVariables, signal?: AbortSignal) =>\n  dataPlaneFetch<\n    CreateBranchResponse,\n    CreateBranchError,\n    CreateBranchRequestBody,\n    {},\n    CreateBranchQueryParams,\n    CreateBranchPathParams\n  >({ url: '/db/{dbBranchName}', method: 'put', ...variables, signal });\n\nexport type DeleteBranchPathParams = {\n  /**\n   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.\n   */\n  dbBranchName: Schemas.DBBranchName;\n  workspace: string;\n  region: string;\n};\n\nexport type DeleteBranchError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n  | {\n      status: 409;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type DeleteBranchResponse = {\n  status: Schemas.MigrationStatus;\n};\n\nexport type DeleteBranchVariables = {\n  pathParams: DeleteBranchPathParams;\n} & DataPlaneFetcherExtraProps;\n\n/**\n * Delete the branch in the database and all its resources\n */\nexport const deleteBranch = (variables: DeleteBranchVariables, signal?: AbortSignal) =>\n  dataPlaneFetch<DeleteBranchResponse, DeleteBranchError, undefined, {}, {}, DeleteBranchPathParams>({\n    url: '/db/{dbBranchName}',\n    method: 'delete',\n    ...variables,\n    signal\n  });\n\nexport type GetSchemaPathParams = {\n  /**\n   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.\n   */\n  dbBranchName: Schemas.DBBranchName;\n  workspace: string;\n  region: string;\n};\n\nexport type GetSchemaError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type GetSchemaResponse = {\n  schema: Schemas.BranchSchema;\n};\n\nexport type GetSchemaVariables = {\n  pathParams: GetSchemaPathParams;\n} & DataPlaneFetcherExtraProps;\n\nexport const getSchema = (variables: GetSchemaVariables, signal?: AbortSignal) =>\n  dataPlaneFetch<GetSchemaResponse, GetSchemaError, undefined, {}, {}, GetSchemaPathParams>({\n    url: '/db/{dbBranchName}/schema',\n    method: 'get',\n    ...variables,\n    signal\n  });\n\nexport type GetSchemasPathParams = {\n  /**\n   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.\n   */\n  dbBranchName: Schemas.DBBranchName;\n  workspace: string;\n  region: string;\n};\n\nexport type GetSchemasError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type GetSchemasResponse = {\n  schemas: Schemas.BranchSchema[];\n};\n\nexport type GetSchemasVariables = {\n  pathParams: GetSchemasPathParams;\n} & DataPlaneFetcherExtraProps;\n\nexport const getSchemas = (variables: GetSchemasVariables, signal?: AbortSignal) =>\n  dataPlaneFetch<GetSchemasResponse, GetSchemasError, undefined, {}, {}, GetSchemasPathParams>({\n    url: '/db/{dbBranchName}/schemas',\n    method: 'get',\n    ...variables,\n    signal\n  });\n\nexport type CopyBranchPathParams = {\n  /**\n   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.\n   */\n  dbBranchName: Schemas.DBBranchName;\n  workspace: string;\n  region: string;\n};\n\nexport type CopyBranchError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type CopyBranchRequestBody = {\n  destinationBranch: string;\n  limit?: number;\n};\n\nexport type CopyBranchVariables = {\n  body: CopyBranchRequestBody;\n  pathParams: CopyBranchPathParams;\n} & DataPlaneFetcherExtraProps;\n\n/**\n * Create a copy of the branch\n */\nexport const copyBranch = (variables: CopyBranchVariables, signal?: AbortSignal) =>\n  dataPlaneFetch<Schemas.BranchWithCopyID, CopyBranchError, CopyBranchRequestBody, {}, {}, CopyBranchPathParams>({\n    url: '/db/{dbBranchName}/copy',\n    method: 'post',\n    ...variables,\n    signal\n  });\n\nexport type GetBranchMoveStatusPathParams = {\n  /**\n   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.\n   */\n  dbBranchName: Schemas.DBBranchName;\n  workspace: string;\n  region: string;\n};\n\nexport type GetBranchMoveStatusError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type GetBranchMoveStatusResponse = {\n  state: string;\n  pendingBytes: number;\n};\n\nexport type GetBranchMoveStatusVariables = {\n  pathParams: GetBranchMoveStatusPathParams;\n} & DataPlaneFetcherExtraProps;\n\n/**\n * Get the branch move status (if a move is happening)\n */\nexport const getBranchMoveStatus = (variables: GetBranchMoveStatusVariables, signal?: AbortSignal) =>\n  dataPlaneFetch<\n    GetBranchMoveStatusResponse,\n    GetBranchMoveStatusError,\n    undefined,\n    {},\n    {},\n    GetBranchMoveStatusPathParams\n  >({ url: '/db/{dbBranchName}/move', method: 'get', ...variables, signal });\n\nexport type MoveBranchPathParams = {\n  /**\n   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.\n   */\n  dbBranchName: Schemas.DBBranchName;\n  workspace: string;\n  region: string;\n};\n\nexport type MoveBranchError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n  | {\n      status: 423;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type MoveBranchResponse = {\n  state: string;\n};\n\nexport type MoveBranchRequestBody = {\n  /**\n   * Select the cluster to move the branch to. Must be different from the current cluster.\n   *\n   * @minLength 1\n   * @x-internal true\n   */\n  to: string;\n};\n\nexport type MoveBranchVariables = {\n  body: MoveBranchRequestBody;\n  pathParams: MoveBranchPathParams;\n} & DataPlaneFetcherExtraProps;\n\nexport const moveBranch = (variables: MoveBranchVariables, signal?: AbortSignal) =>\n  dataPlaneFetch<MoveBranchResponse, MoveBranchError, MoveBranchRequestBody, {}, {}, MoveBranchPathParams>({\n    url: '/db/{dbBranchName}/move',\n    method: 'put',\n    ...variables,\n    signal\n  });\n\nexport type UpdateBranchMetadataPathParams = {\n  /**\n   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.\n   */\n  dbBranchName: Schemas.DBBranchName;\n  workspace: string;\n  region: string;\n};\n\nexport type UpdateBranchMetadataError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type UpdateBranchMetadataVariables = {\n  body?: Schemas.BranchMetadata;\n  pathParams: UpdateBranchMetadataPathParams;\n} & DataPlaneFetcherExtraProps;\n\n/**\n * Update the branch metadata\n */\nexport const updateBranchMetadata = (variables: UpdateBranchMetadataVariables, signal?: AbortSignal) =>\n  dataPlaneFetch<undefined, UpdateBranchMetadataError, Schemas.BranchMetadata, {}, {}, UpdateBranchMetadataPathParams>({\n    url: '/db/{dbBranchName}/metadata',\n    method: 'put',\n    ...variables,\n    signal\n  });\n\nexport type GetBranchMetadataPathParams = {\n  /**\n   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.\n   */\n  dbBranchName: Schemas.DBBranchName;\n  workspace: string;\n  region: string;\n};\n\nexport type GetBranchMetadataError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type GetBranchMetadataVariables = {\n  pathParams: GetBranchMetadataPathParams;\n} & DataPlaneFetcherExtraProps;\n\nexport const getBranchMetadata = (variables: GetBranchMetadataVariables, signal?: AbortSignal) =>\n  dataPlaneFetch<Schemas.BranchMetadata, GetBranchMetadataError, undefined, {}, {}, GetBranchMetadataPathParams>({\n    url: '/db/{dbBranchName}/metadata',\n    method: 'get',\n    ...variables,\n    signal\n  });\n\nexport type GetBranchStatsPathParams = {\n  /**\n   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.\n   */\n  dbBranchName: Schemas.DBBranchName;\n  workspace: string;\n  region: string;\n};\n\nexport type GetBranchStatsError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.SimpleError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type GetBranchStatsResponse = {\n  timestamp: string;\n  interval: string;\n  resolution: string;\n  numberOfRecords?: Schemas.MetricsDatapoint[];\n  writesOverTime?: Schemas.MetricsDatapoint[];\n  readsOverTime?: Schemas.MetricsDatapoint[];\n  readLatency?: Schemas.MetricsLatency;\n  writeLatency?: Schemas.MetricsLatency;\n  warning?: string;\n};\n\nexport type GetBranchStatsVariables = {\n  pathParams: GetBranchStatsPathParams;\n} & DataPlaneFetcherExtraProps;\n\n/**\n * Get branch usage metrics.\n */\nexport const getBranchStats = (variables: GetBranchStatsVariables, signal?: AbortSignal) =>\n  dataPlaneFetch<GetBranchStatsResponse, GetBranchStatsError, undefined, {}, {}, GetBranchStatsPathParams>({\n    url: '/db/{dbBranchName}/stats',\n    method: 'get',\n    ...variables,\n    signal\n  });\n\nexport type GetGitBranchesMappingPathParams = {\n  /**\n   * The Database Name\n   */\n  dbName: Schemas.DBName;\n  workspace: string;\n  region: string;\n};\n\nexport type GetGitBranchesMappingError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n>;\n\nexport type GetGitBranchesMappingVariables = {\n  pathParams: GetGitBranchesMappingPathParams;\n} & DataPlaneFetcherExtraProps;\n\n/**\n * Lists all the git branches in the mapping, and their associated Xata branches.\n *\n * Example response:\n *\n * ```json\n * {\n *   \"mappings\": [\n *       {\n *         \"gitBranch\": \"main\",\n *         \"xataBranch\": \"main\"\n *       },\n *       {\n *         \"gitBranch\": \"gitBranch1\",\n *         \"xataBranch\": \"xataBranch1\"\n *       }\n *       {\n *         \"gitBranch\": \"xataBranch2\",\n *         \"xataBranch\": \"xataBranch2\"\n *       }\n *   ]\n * }\n * ```\n */\nexport const getGitBranchesMapping = (variables: GetGitBranchesMappingVariables, signal?: AbortSignal) =>\n  dataPlaneFetch<\n    Schemas.ListGitBranchesResponse,\n    GetGitBranchesMappingError,\n    undefined,\n    {},\n    {},\n    GetGitBranchesMappingPathParams\n  >({ url: '/dbs/{dbName}/gitBranches', method: 'get', ...variables, signal });\n\nexport type AddGitBranchesEntryPathParams = {\n  /**\n   * The Database Name\n   */\n  dbName: Schemas.DBName;\n  workspace: string;\n  region: string;\n};\n\nexport type AddGitBranchesEntryError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n>;\n\nexport type AddGitBranchesEntryResponse = {\n  /**\n   * Warning message\n   */\n  warning?: string;\n};\n\nexport type AddGitBranchesEntryRequestBody = {\n  /**\n   * The name of the Git branch.\n   */\n  gitBranch: string;\n  /**\n   * The name of the Xata branch.\n   */\n  xataBranch: Schemas.BranchName;\n};\n\nexport type AddGitBranchesEntryVariables = {\n  body: AddGitBranchesEntryRequestBody;\n  pathParams: AddGitBranchesEntryPathParams;\n} & DataPlaneFetcherExtraProps;\n\n/**\n * Adds an entry to the mapping of git branches to Xata branches. The git branch and the Xata branch must be present in the body of the request. If the Xata branch doesn't exist, a 400 error is returned.\n *\n * If the git branch is already present in the mapping, the old entry is overwritten, and a warning message is included in the response. If the git branch is added and didn't exist before, the response code is 204. If the git branch existed and it was overwritten, the response code is 201.\n *\n * Example request:\n *\n * ```json\n * // POST https://tutorial-ng7s8c.xata.sh/dbs/demo/gitBranches\n * {\n *   \"gitBranch\": \"fix/bug123\",\n *   \"xataBranch\": \"fix_bug\"\n * }\n * ```\n */\nexport const addGitBranchesEntry = (variables: AddGitBranchesEntryVariables, signal?: AbortSignal) =>\n  dataPlaneFetch<\n    AddGitBranchesEntryResponse,\n    AddGitBranchesEntryError,\n    AddGitBranchesEntryRequestBody,\n    {},\n    {},\n    AddGitBranchesEntryPathParams\n  >({ url: '/dbs/{dbName}/gitBranches', method: 'post', ...variables, signal });\n\nexport type RemoveGitBranchesEntryPathParams = {\n  /**\n   * The Database Name\n   */\n  dbName: Schemas.DBName;\n  workspace: string;\n  region: string;\n};\n\nexport type RemoveGitBranchesEntryQueryParams = {\n  /**\n   * The git branch to remove from the mapping\n   */\n  gitBranch: string;\n};\n\nexport type RemoveGitBranchesEntryError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n>;\n\nexport type RemoveGitBranchesEntryVariables = {\n  pathParams: RemoveGitBranchesEntryPathParams;\n  queryParams: RemoveGitBranchesEntryQueryParams;\n} & DataPlaneFetcherExtraProps;\n\n/**\n * Removes an entry from the mapping of git branches to Xata branches. The name of the git branch must be passed as a query parameter. If the git branch is not found, the endpoint returns a 404 status code.\n *\n * Example request:\n *\n * ```json\n * // DELETE https://tutorial-ng7s8c.xata.sh/dbs/demo/gitBranches?gitBranch=fix%2Fbug123\n * ```\n */\nexport const removeGitBranchesEntry = (variables: RemoveGitBranchesEntryVariables, signal?: AbortSignal) =>\n  dataPlaneFetch<\n    undefined,\n    RemoveGitBranchesEntryError,\n    undefined,\n    {},\n    RemoveGitBranchesEntryQueryParams,\n    RemoveGitBranchesEntryPathParams\n  >({\n    url: '/dbs/{dbName}/gitBranches',\n    method: 'delete',\n    ...variables,\n    signal\n  });\n\nexport type ResolveBranchPathParams = {\n  /**\n   * The Database Name\n   */\n  dbName: Schemas.DBName;\n  workspace: string;\n  region: string;\n};\n\nexport type ResolveBranchQueryParams = {\n  /**\n   * The Git Branch\n   */\n  gitBranch?: string;\n  /**\n   * Default branch to fallback to\n   */\n  fallbackBranch?: string;\n};\n\nexport type ResolveBranchError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n>;\n\nexport type ResolveBranchResponse = {\n  branch: string;\n  reason: {\n    code: 'FOUND_IN_MAPPING' | 'BRANCH_EXISTS' | 'FALLBACK_BRANCH' | 'DEFAULT_BRANCH';\n    message: string;\n  };\n};\n\nexport type ResolveBranchVariables = {\n  pathParams: ResolveBranchPathParams;\n  queryParams?: ResolveBranchQueryParams;\n} & DataPlaneFetcherExtraProps;\n\n/**\n * In order to resolve the database branch, the following algorithm is used:\n * * if the `gitBranch` was provided and is found in the [git branches mapping](/docs/api-reference/dbs/db_name/gitBranches), the associated Xata branch is returned\n * * else, if a Xata branch with the exact same name as `gitBranch` exists, return it\n * * else, if `fallbackBranch` is provided and a branch with that name exists, return it\n * * else, return the default branch of the DB (`main` or the first branch)\n *\n * Example call:\n *\n * ```json\n * // GET https://tutorial-ng7s8c.xata.sh/dbs/demo/dbs/demo/resolveBranch?gitBranch=test&fallbackBranch=tsg\n * ```\n *\n * Example response:\n *\n * ```json\n * {\n *   \"branch\": \"main\",\n *   \"reason\": {\n *     \"code\": \"DEFAULT_BRANCH\",\n *     \"message\": \"Default branch for this database (main)\"\n *   }\n * }\n * ```\n */\nexport const resolveBranch = (variables: ResolveBranchVariables, signal?: AbortSignal) =>\n  dataPlaneFetch<\n    ResolveBranchResponse,\n    ResolveBranchError,\n    undefined,\n    {},\n    ResolveBranchQueryParams,\n    ResolveBranchPathParams\n  >({\n    url: '/dbs/{dbName}/resolveBranch',\n    method: 'get',\n    ...variables,\n    signal\n  });\n\nexport type GetBranchMigrationHistoryPathParams = {\n  /**\n   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.\n   */\n  dbBranchName: Schemas.DBBranchName;\n  workspace: string;\n  region: string;\n};\n\nexport type GetBranchMigrationHistoryError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type GetBranchMigrationHistoryResponse = {\n  startedFrom?: Schemas.StartedFromMetadata;\n  migrations?: Schemas.BranchMigration[];\n};\n\nexport type GetBranchMigrationHistoryRequestBody = {\n  limit?: number;\n  startFrom?: string;\n};\n\nexport type GetBranchMigrationHistoryVariables = {\n  body?: GetBranchMigrationHistoryRequestBody;\n  pathParams: GetBranchMigrationHistoryPathParams;\n} & DataPlaneFetcherExtraProps;\n\nexport const getBranchMigrationHistory = (variables: GetBranchMigrationHistoryVariables, signal?: AbortSignal) =>\n  dataPlaneFetch<\n    GetBranchMigrationHistoryResponse,\n    GetBranchMigrationHistoryError,\n    GetBranchMigrationHistoryRequestBody,\n    {},\n    {},\n    GetBranchMigrationHistoryPathParams\n  >({\n    url: '/db/{dbBranchName}/migrations',\n    method: 'get',\n    ...variables,\n    signal\n  });\n\nexport type GetBranchMigrationPlanPathParams = {\n  /**\n   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.\n   */\n  dbBranchName: Schemas.DBBranchName;\n  workspace: string;\n  region: string;\n};\n\nexport type GetBranchMigrationPlanError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type GetBranchMigrationPlanVariables = {\n  body: Schemas.Schema;\n  pathParams: GetBranchMigrationPlanPathParams;\n} & DataPlaneFetcherExtraProps;\n\n/**\n * Compute a migration plan from a target schema the branch should be migrated too.\n */\nexport const getBranchMigrationPlan = (variables: GetBranchMigrationPlanVariables, signal?: AbortSignal) =>\n  dataPlaneFetch<\n    Responses.BranchMigrationPlan,\n    GetBranchMigrationPlanError,\n    Schemas.Schema,\n    {},\n    {},\n    GetBranchMigrationPlanPathParams\n  >({\n    url: '/db/{dbBranchName}/migrations/plan',\n    method: 'post',\n    ...variables,\n    signal\n  });\n\nexport type ExecuteBranchMigrationPlanPathParams = {\n  /**\n   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.\n   */\n  dbBranchName: Schemas.DBBranchName;\n  workspace: string;\n  region: string;\n};\n\nexport type ExecuteBranchMigrationPlanError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type ExecuteBranchMigrationPlanRequestBody = {\n  version: number;\n  migration: Schemas.BranchMigration;\n};\n\nexport type ExecuteBranchMigrationPlanVariables = {\n  body: ExecuteBranchMigrationPlanRequestBody;\n  pathParams: ExecuteBranchMigrationPlanPathParams;\n} & DataPlaneFetcherExtraProps;\n\n/**\n * Apply a migration plan to the branch\n */\nexport const executeBranchMigrationPlan = (variables: ExecuteBranchMigrationPlanVariables, signal?: AbortSignal) =>\n  dataPlaneFetch<\n    Responses.SchemaUpdateResponse,\n    ExecuteBranchMigrationPlanError,\n    ExecuteBranchMigrationPlanRequestBody,\n    {},\n    {},\n    ExecuteBranchMigrationPlanPathParams\n  >({\n    url: '/db/{dbBranchName}/migrations/execute',\n    method: 'post',\n    ...variables,\n    signal\n  });\n\nexport type QueryMigrationRequestsPathParams = {\n  /**\n   * The Database Name\n   */\n  dbName: Schemas.DBName;\n  workspace: string;\n  region: string;\n};\n\nexport type QueryMigrationRequestsError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type QueryMigrationRequestsResponse = {\n  migrationRequests: Schemas.MigrationRequest[];\n  meta: Schemas.RecordsMetadata;\n};\n\nexport type QueryMigrationRequestsRequestBody = {\n  filter?: Schemas.FilterExpression;\n  sort?: Schemas.SortExpression;\n  page?: Schemas.PageConfig;\n  columns?: Schemas.ColumnsProjection;\n};\n\nexport type QueryMigrationRequestsVariables = {\n  body?: QueryMigrationRequestsRequestBody;\n  pathParams: QueryMigrationRequestsPathParams;\n} & DataPlaneFetcherExtraProps;\n\nexport const queryMigrationRequests = (variables: QueryMigrationRequestsVariables, signal?: AbortSignal) =>\n  dataPlaneFetch<\n    QueryMigrationRequestsResponse,\n    QueryMigrationRequestsError,\n    QueryMigrationRequestsRequestBody,\n    {},\n    {},\n    QueryMigrationRequestsPathParams\n  >({\n    url: '/dbs/{dbName}/migrations/query',\n    method: 'post',\n    ...variables,\n    signal\n  });\n\nexport type CreateMigrationRequestPathParams = {\n  /**\n   * The Database Name\n   */\n  dbName: Schemas.DBName;\n  workspace: string;\n  region: string;\n};\n\nexport type CreateMigrationRequestError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type CreateMigrationRequestResponse = {\n  number: number;\n};\n\nexport type CreateMigrationRequestRequestBody = {\n  /**\n   * The source branch.\n   */\n  source: string;\n  /**\n   * The target branch.\n   */\n  target: string;\n  /**\n   * The title.\n   */\n  title: string;\n  /**\n   * Optional migration request description.\n   */\n  body?: string;\n};\n\nexport type CreateMigrationRequestVariables = {\n  body: CreateMigrationRequestRequestBody;\n  pathParams: CreateMigrationRequestPathParams;\n} & DataPlaneFetcherExtraProps;\n\nexport const createMigrationRequest = (variables: CreateMigrationRequestVariables, signal?: AbortSignal) =>\n  dataPlaneFetch<\n    CreateMigrationRequestResponse,\n    CreateMigrationRequestError,\n    CreateMigrationRequestRequestBody,\n    {},\n    {},\n    CreateMigrationRequestPathParams\n  >({ url: '/dbs/{dbName}/migrations', method: 'post', ...variables, signal });\n\nexport type GetMigrationRequestPathParams = {\n  /**\n   * The Database Name\n   */\n  dbName: Schemas.DBName;\n  /**\n   * The migration request number.\n   */\n  mrNumber: Schemas.MigrationRequestNumber;\n  workspace: string;\n  region: string;\n};\n\nexport type GetMigrationRequestError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type GetMigrationRequestVariables = {\n  pathParams: GetMigrationRequestPathParams;\n} & DataPlaneFetcherExtraProps;\n\nexport const getMigrationRequest = (variables: GetMigrationRequestVariables, signal?: AbortSignal) =>\n  dataPlaneFetch<Schemas.MigrationRequest, GetMigrationRequestError, undefined, {}, {}, GetMigrationRequestPathParams>({\n    url: '/dbs/{dbName}/migrations/{mrNumber}',\n    method: 'get',\n    ...variables,\n    signal\n  });\n\nexport type UpdateMigrationRequestPathParams = {\n  /**\n   * The Database Name\n   */\n  dbName: Schemas.DBName;\n  /**\n   * The migration request number.\n   */\n  mrNumber: Schemas.MigrationRequestNumber;\n  workspace: string;\n  region: string;\n};\n\nexport type UpdateMigrationRequestError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type UpdateMigrationRequestRequestBody = {\n  /**\n   * New migration request title.\n   */\n  title?: string;\n  /**\n   * New migration request description.\n   */\n  body?: string;\n  /**\n   * Change the migration request status.\n   */\n  status?: 'open' | 'closed';\n};\n\nexport type UpdateMigrationRequestVariables = {\n  body?: UpdateMigrationRequestRequestBody;\n  pathParams: UpdateMigrationRequestPathParams;\n} & DataPlaneFetcherExtraProps;\n\nexport const updateMigrationRequest = (variables: UpdateMigrationRequestVariables, signal?: AbortSignal) =>\n  dataPlaneFetch<\n    undefined,\n    UpdateMigrationRequestError,\n    UpdateMigrationRequestRequestBody,\n    {},\n    {},\n    UpdateMigrationRequestPathParams\n  >({\n    url: '/dbs/{dbName}/migrations/{mrNumber}',\n    method: 'patch',\n    ...variables,\n    signal\n  });\n\nexport type ListMigrationRequestsCommitsPathParams = {\n  /**\n   * The Database Name\n   */\n  dbName: Schemas.DBName;\n  /**\n   * The migration request number.\n   */\n  mrNumber: Schemas.MigrationRequestNumber;\n  workspace: string;\n  region: string;\n};\n\nexport type ListMigrationRequestsCommitsError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type ListMigrationRequestsCommitsResponse = {\n  meta: {\n    /**\n     * last record id\n     */\n    cursor: string;\n    /**\n     * true if more records can be fetch\n     */\n    more: boolean;\n  };\n  logs: Schemas.Commit[];\n};\n\nexport type ListMigrationRequestsCommitsRequestBody = {\n  page?: {\n    /**\n     * Query the next page that follow the cursor.\n     */\n    after?: string;\n    /**\n     * Query the previous page before the cursor.\n     */\n    before?: string;\n    /**\n     * Set page size. If the size is missing it is read from the cursor. If no cursor is given xata will choose the default page size.\n     *\n     * @default 20\n     */\n    size?: number;\n  };\n};\n\nexport type ListMigrationRequestsCommitsVariables = {\n  body?: ListMigrationRequestsCommitsRequestBody;\n  pathParams: ListMigrationRequestsCommitsPathParams;\n} & DataPlaneFetcherExtraProps;\n\nexport const listMigrationRequestsCommits = (variables: ListMigrationRequestsCommitsVariables, signal?: AbortSignal) =>\n  dataPlaneFetch<\n    ListMigrationRequestsCommitsResponse,\n    ListMigrationRequestsCommitsError,\n    ListMigrationRequestsCommitsRequestBody,\n    {},\n    {},\n    ListMigrationRequestsCommitsPathParams\n  >({\n    url: '/dbs/{dbName}/migrations/{mrNumber}/commits',\n    method: 'post',\n    ...variables,\n    signal\n  });\n\nexport type CompareMigrationRequestPathParams = {\n  /**\n   * The Database Name\n   */\n  dbName: Schemas.DBName;\n  /**\n   * The migration request number.\n   */\n  mrNumber: Schemas.MigrationRequestNumber;\n  workspace: string;\n  region: string;\n};\n\nexport type CompareMigrationRequestError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type CompareMigrationRequestVariables = {\n  pathParams: CompareMigrationRequestPathParams;\n} & DataPlaneFetcherExtraProps;\n\nexport const compareMigrationRequest = (variables: CompareMigrationRequestVariables, signal?: AbortSignal) =>\n  dataPlaneFetch<\n    Responses.SchemaCompareResponse,\n    CompareMigrationRequestError,\n    undefined,\n    {},\n    {},\n    CompareMigrationRequestPathParams\n  >({\n    url: '/dbs/{dbName}/migrations/{mrNumber}/compare',\n    method: 'post',\n    ...variables,\n    signal\n  });\n\nexport type GetMigrationRequestIsMergedPathParams = {\n  /**\n   * The Database Name\n   */\n  dbName: Schemas.DBName;\n  /**\n   * The migration request number.\n   */\n  mrNumber: Schemas.MigrationRequestNumber;\n  workspace: string;\n  region: string;\n};\n\nexport type GetMigrationRequestIsMergedError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type GetMigrationRequestIsMergedResponse = {\n  merged?: boolean;\n};\n\nexport type GetMigrationRequestIsMergedVariables = {\n  pathParams: GetMigrationRequestIsMergedPathParams;\n} & DataPlaneFetcherExtraProps;\n\nexport const getMigrationRequestIsMerged = (variables: GetMigrationRequestIsMergedVariables, signal?: AbortSignal) =>\n  dataPlaneFetch<\n    GetMigrationRequestIsMergedResponse,\n    GetMigrationRequestIsMergedError,\n    undefined,\n    {},\n    {},\n    GetMigrationRequestIsMergedPathParams\n  >({\n    url: '/dbs/{dbName}/migrations/{mrNumber}/merge',\n    method: 'get',\n    ...variables,\n    signal\n  });\n\nexport type MergeMigrationRequestPathParams = {\n  /**\n   * The Database Name\n   */\n  dbName: Schemas.DBName;\n  /**\n   * The migration request number.\n   */\n  mrNumber: Schemas.MigrationRequestNumber;\n  workspace: string;\n  region: string;\n};\n\nexport type MergeMigrationRequestError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type MergeMigrationRequestVariables = {\n  pathParams: MergeMigrationRequestPathParams;\n} & DataPlaneFetcherExtraProps;\n\nexport const mergeMigrationRequest = (variables: MergeMigrationRequestVariables, signal?: AbortSignal) =>\n  dataPlaneFetch<Schemas.BranchOp, MergeMigrationRequestError, undefined, {}, {}, MergeMigrationRequestPathParams>({\n    url: '/dbs/{dbName}/migrations/{mrNumber}/merge',\n    method: 'post',\n    ...variables,\n    signal\n  });\n\nexport type GetBranchSchemaHistoryPathParams = {\n  /**\n   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.\n   */\n  dbBranchName: Schemas.DBBranchName;\n  workspace: string;\n  region: string;\n};\n\nexport type GetBranchSchemaHistoryError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type GetBranchSchemaHistoryResponse = {\n  meta: {\n    /**\n     * last record id\n     */\n    cursor: string;\n    /**\n     * true if more records can be fetch\n     */\n    more: boolean;\n  };\n  logs: Schemas.Commit[];\n};\n\nexport type GetBranchSchemaHistoryRequestBody = {\n  page?: {\n    /**\n     * Query the next page that follow the cursor.\n     */\n    after?: string;\n    /**\n     * Query the previous page before the cursor.\n     */\n    before?: string;\n    /**\n     * Set page size. If the size is missing it is read from the cursor. If no cursor is given xata will choose the default page size.\n     *\n     * @default 20\n     */\n    size?: number;\n  };\n  /**\n   * Report only migrations that have been added since the given Migration ID.\n   */\n  since?: string;\n};\n\nexport type GetBranchSchemaHistoryVariables = {\n  body?: GetBranchSchemaHistoryRequestBody;\n  pathParams: GetBranchSchemaHistoryPathParams;\n} & DataPlaneFetcherExtraProps;\n\nexport const getBranchSchemaHistory = (variables: GetBranchSchemaHistoryVariables, signal?: AbortSignal) =>\n  dataPlaneFetch<\n    GetBranchSchemaHistoryResponse,\n    GetBranchSchemaHistoryError,\n    GetBranchSchemaHistoryRequestBody,\n    {},\n    {},\n    GetBranchSchemaHistoryPathParams\n  >({\n    url: '/db/{dbBranchName}/schema/history',\n    method: 'post',\n    ...variables,\n    signal\n  });\n\nexport type CompareBranchWithUserSchemaPathParams = {\n  /**\n   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.\n   */\n  dbBranchName: Schemas.DBBranchName;\n  workspace: string;\n  region: string;\n};\n\nexport type CompareBranchWithUserSchemaError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type CompareBranchWithUserSchemaRequestBody = {\n  schema: Schemas.Schema;\n  schemaOperations?: Schemas.MigrationOp[];\n  branchOperations?: Schemas.MigrationOp[];\n};\n\nexport type CompareBranchWithUserSchemaVariables = {\n  body: CompareBranchWithUserSchemaRequestBody;\n  pathParams: CompareBranchWithUserSchemaPathParams;\n} & DataPlaneFetcherExtraProps;\n\nexport const compareBranchWithUserSchema = (variables: CompareBranchWithUserSchemaVariables, signal?: AbortSignal) =>\n  dataPlaneFetch<\n    Responses.SchemaCompareResponse,\n    CompareBranchWithUserSchemaError,\n    CompareBranchWithUserSchemaRequestBody,\n    {},\n    {},\n    CompareBranchWithUserSchemaPathParams\n  >({\n    url: '/db/{dbBranchName}/schema/compare',\n    method: 'post',\n    ...variables,\n    signal\n  });\n\nexport type CompareBranchSchemasPathParams = {\n  /**\n   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.\n   */\n  dbBranchName: Schemas.DBBranchName;\n  /**\n   * The Database Name\n   */\n  branchName: Schemas.BranchName;\n  workspace: string;\n  region: string;\n};\n\nexport type CompareBranchSchemasError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type CompareBranchSchemasRequestBody = {\n  sourceBranchOperations?: Schemas.MigrationOp[];\n  targetBranchOperations?: Schemas.MigrationOp[];\n};\n\nexport type CompareBranchSchemasVariables = {\n  body: CompareBranchSchemasRequestBody;\n  pathParams: CompareBranchSchemasPathParams;\n} & DataPlaneFetcherExtraProps;\n\nexport const compareBranchSchemas = (variables: CompareBranchSchemasVariables, signal?: AbortSignal) =>\n  dataPlaneFetch<\n    Responses.SchemaCompareResponse,\n    CompareBranchSchemasError,\n    CompareBranchSchemasRequestBody,\n    {},\n    {},\n    CompareBranchSchemasPathParams\n  >({\n    url: '/db/{dbBranchName}/schema/compare/{branchName}',\n    method: 'post',\n    ...variables,\n    signal\n  });\n\nexport type UpdateBranchSchemaPathParams = {\n  /**\n   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.\n   */\n  dbBranchName: Schemas.DBBranchName;\n  workspace: string;\n  region: string;\n};\n\nexport type UpdateBranchSchemaError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type UpdateBranchSchemaVariables = {\n  body: Schemas.Migration;\n  pathParams: UpdateBranchSchemaPathParams;\n} & DataPlaneFetcherExtraProps;\n\nexport const updateBranchSchema = (variables: UpdateBranchSchemaVariables, signal?: AbortSignal) =>\n  dataPlaneFetch<\n    Responses.SchemaUpdateResponse,\n    UpdateBranchSchemaError,\n    Schemas.Migration,\n    {},\n    {},\n    UpdateBranchSchemaPathParams\n  >({\n    url: '/db/{dbBranchName}/schema/update',\n    method: 'post',\n    ...variables,\n    signal\n  });\n\nexport type PreviewBranchSchemaEditPathParams = {\n  /**\n   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.\n   */\n  dbBranchName: Schemas.DBBranchName;\n  workspace: string;\n  region: string;\n};\n\nexport type PreviewBranchSchemaEditError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type PreviewBranchSchemaEditResponse = {\n  original: Schemas.Schema;\n  updated: Schemas.Schema;\n};\n\nexport type PreviewBranchSchemaEditRequestBody = {\n  edits?: Schemas.SchemaEditScript;\n};\n\nexport type PreviewBranchSchemaEditVariables = {\n  body?: PreviewBranchSchemaEditRequestBody;\n  pathParams: PreviewBranchSchemaEditPathParams;\n} & DataPlaneFetcherExtraProps;\n\nexport const previewBranchSchemaEdit = (variables: PreviewBranchSchemaEditVariables, signal?: AbortSignal) =>\n  dataPlaneFetch<\n    PreviewBranchSchemaEditResponse,\n    PreviewBranchSchemaEditError,\n    PreviewBranchSchemaEditRequestBody,\n    {},\n    {},\n    PreviewBranchSchemaEditPathParams\n  >({\n    url: '/db/{dbBranchName}/schema/preview',\n    method: 'post',\n    ...variables,\n    signal\n  });\n\nexport type ApplyBranchSchemaEditPathParams = {\n  /**\n   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.\n   */\n  dbBranchName: Schemas.DBBranchName;\n  workspace: string;\n  region: string;\n};\n\nexport type ApplyBranchSchemaEditError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type ApplyBranchSchemaEditRequestBody = {\n  edits: Schemas.SchemaEditScript;\n};\n\nexport type ApplyBranchSchemaEditVariables = {\n  body: ApplyBranchSchemaEditRequestBody;\n  pathParams: ApplyBranchSchemaEditPathParams;\n} & DataPlaneFetcherExtraProps;\n\nexport const applyBranchSchemaEdit = (variables: ApplyBranchSchemaEditVariables, signal?: AbortSignal) =>\n  dataPlaneFetch<\n    Responses.SchemaUpdateResponse,\n    ApplyBranchSchemaEditError,\n    ApplyBranchSchemaEditRequestBody,\n    {},\n    {},\n    ApplyBranchSchemaEditPathParams\n  >({\n    url: '/db/{dbBranchName}/schema/apply',\n    method: 'post',\n    ...variables,\n    signal\n  });\n\nexport type PushBranchMigrationsPathParams = {\n  /**\n   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.\n   */\n  dbBranchName: Schemas.DBBranchName;\n  workspace: string;\n  region: string;\n};\n\nexport type PushBranchMigrationsError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type PushBranchMigrationsRequestBody = {\n  migrations: Schemas.MigrationObject[];\n};\n\nexport type PushBranchMigrationsVariables = {\n  body: PushBranchMigrationsRequestBody;\n  pathParams: PushBranchMigrationsPathParams;\n} & DataPlaneFetcherExtraProps;\n\n/**\n * The `schema/push` API accepts a list of migrations to be applied to the\n * current branch. A list of applicable migrations can be fetched using\n * the `schema/history` API from another branch or database.\n *\n * The most recent migration must be part of the list or referenced (via\n * `parentID`) by the first migration in the list of migrations to be pushed.\n *\n * Each migration in the list has an `id`, `parentID`, and `checksum`. The\n * checksum for migrations are generated and verified by xata. The\n * operation fails if any migration in the list has an invalid checksum.\n */\nexport const pushBranchMigrations = (variables: PushBranchMigrationsVariables, signal?: AbortSignal) =>\n  dataPlaneFetch<\n    Responses.SchemaUpdateResponse,\n    PushBranchMigrationsError,\n    PushBranchMigrationsRequestBody,\n    {},\n    {},\n    PushBranchMigrationsPathParams\n  >({\n    url: '/db/{dbBranchName}/schema/push',\n    method: 'post',\n    ...variables,\n    signal\n  });\n\nexport type CreateTablePathParams = {\n  /**\n   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.\n   */\n  dbBranchName: Schemas.DBBranchName;\n  /**\n   * The Table name\n   */\n  tableName: Schemas.TableName;\n  workspace: string;\n  region: string;\n};\n\nexport type CreateTableError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n  | {\n      status: 422;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type CreateTableResponse = {\n  branchName: string;\n  /**\n   * @minLength 1\n   */\n  tableName: string;\n  status: Schemas.MigrationStatus;\n};\n\nexport type CreateTableVariables = {\n  pathParams: CreateTablePathParams;\n} & DataPlaneFetcherExtraProps;\n\n/**\n * Creates a new table with the given name. Returns 422 if a table with the same name already exists.\n */\nexport const createTable = (variables: CreateTableVariables, signal?: AbortSignal) =>\n  dataPlaneFetch<CreateTableResponse, CreateTableError, undefined, {}, {}, CreateTablePathParams>({\n    url: '/db/{dbBranchName}/tables/{tableName}',\n    method: 'put',\n    ...variables,\n    signal\n  });\n\nexport type DeleteTablePathParams = {\n  /**\n   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.\n   */\n  dbBranchName: Schemas.DBBranchName;\n  /**\n   * The Table name\n   */\n  tableName: Schemas.TableName;\n  workspace: string;\n  region: string;\n};\n\nexport type DeleteTableError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n>;\n\nexport type DeleteTableResponse = {\n  status: Schemas.MigrationStatus;\n};\n\nexport type DeleteTableVariables = {\n  pathParams: DeleteTablePathParams;\n} & DataPlaneFetcherExtraProps;\n\n/**\n * Deletes the table with the given name.\n */\nexport const deleteTable = (variables: DeleteTableVariables, signal?: AbortSignal) =>\n  dataPlaneFetch<DeleteTableResponse, DeleteTableError, undefined, {}, {}, DeleteTablePathParams>({\n    url: '/db/{dbBranchName}/tables/{tableName}',\n    method: 'delete',\n    ...variables,\n    signal\n  });\n\nexport type UpdateTablePathParams = {\n  /**\n   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.\n   */\n  dbBranchName: Schemas.DBBranchName;\n  /**\n   * The Table name\n   */\n  tableName: Schemas.TableName;\n  workspace: string;\n  region: string;\n};\n\nexport type UpdateTableError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n  | {\n      status: 422;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type UpdateTableRequestBody = {\n  /**\n   * @minLength 1\n   */\n  name: string;\n};\n\nexport type UpdateTableVariables = {\n  body: UpdateTableRequestBody;\n  pathParams: UpdateTablePathParams;\n} & DataPlaneFetcherExtraProps;\n\n/**\n * Update table. Currently there is only one update operation supported: renaming the table by providing a new name.\n *\n * In the example below, we rename a table from users to people:\n *\n * ```json\n * // PATCH /db/test:main/tables/users\n *\n * {\n *   \"name\": \"people\"\n * }\n * ```\n */\nexport const updateTable = (variables: UpdateTableVariables, signal?: AbortSignal) =>\n  dataPlaneFetch<\n    Responses.SchemaUpdateResponse,\n    UpdateTableError,\n    UpdateTableRequestBody,\n    {},\n    {},\n    UpdateTablePathParams\n  >({\n    url: '/db/{dbBranchName}/tables/{tableName}',\n    method: 'patch',\n    ...variables,\n    signal\n  });\n\nexport type GetTableSchemaPathParams = {\n  /**\n   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.\n   */\n  dbBranchName: Schemas.DBBranchName;\n  /**\n   * The Table name\n   */\n  tableName: Schemas.TableName;\n  workspace: string;\n  region: string;\n};\n\nexport type GetTableSchemaError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type GetTableSchemaResponse = {\n  columns: Schemas.Column[];\n};\n\nexport type GetTableSchemaVariables = {\n  pathParams: GetTableSchemaPathParams;\n} & DataPlaneFetcherExtraProps;\n\nexport const getTableSchema = (variables: GetTableSchemaVariables, signal?: AbortSignal) =>\n  dataPlaneFetch<GetTableSchemaResponse, GetTableSchemaError, undefined, {}, {}, GetTableSchemaPathParams>({\n    url: '/db/{dbBranchName}/tables/{tableName}/schema',\n    method: 'get',\n    ...variables,\n    signal\n  });\n\nexport type SetTableSchemaPathParams = {\n  /**\n   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.\n   */\n  dbBranchName: Schemas.DBBranchName;\n  /**\n   * The Table name\n   */\n  tableName: Schemas.TableName;\n  workspace: string;\n  region: string;\n};\n\nexport type SetTableSchemaError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n  | {\n      status: 409;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type SetTableSchemaRequestBody = {\n  columns: Schemas.Column[];\n};\n\nexport type SetTableSchemaVariables = {\n  body: SetTableSchemaRequestBody;\n  pathParams: SetTableSchemaPathParams;\n} & DataPlaneFetcherExtraProps;\n\nexport const setTableSchema = (variables: SetTableSchemaVariables, signal?: AbortSignal) =>\n  dataPlaneFetch<\n    Responses.SchemaUpdateResponse,\n    SetTableSchemaError,\n    SetTableSchemaRequestBody,\n    {},\n    {},\n    SetTableSchemaPathParams\n  >({\n    url: '/db/{dbBranchName}/tables/{tableName}/schema',\n    method: 'put',\n    ...variables,\n    signal\n  });\n\nexport type GetTableColumnsPathParams = {\n  /**\n   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.\n   */\n  dbBranchName: Schemas.DBBranchName;\n  /**\n   * The Table name\n   */\n  tableName: Schemas.TableName;\n  workspace: string;\n  region: string;\n};\n\nexport type GetTableColumnsError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type GetTableColumnsResponse = {\n  columns: Schemas.Column[];\n};\n\nexport type GetTableColumnsVariables = {\n  pathParams: GetTableColumnsPathParams;\n} & DataPlaneFetcherExtraProps;\n\n/**\n * Retrieves the list of table columns and their definition. This endpoint returns the column list with object columns being reported with their\n * full dot-separated path (flattened).\n */\nexport const getTableColumns = (variables: GetTableColumnsVariables, signal?: AbortSignal) =>\n  dataPlaneFetch<GetTableColumnsResponse, GetTableColumnsError, undefined, {}, {}, GetTableColumnsPathParams>({\n    url: '/db/{dbBranchName}/tables/{tableName}/columns',\n    method: 'get',\n    ...variables,\n    signal\n  });\n\nexport type AddTableColumnPathParams = {\n  /**\n   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.\n   */\n  dbBranchName: Schemas.DBBranchName;\n  /**\n   * The Table name\n   */\n  tableName: Schemas.TableName;\n  workspace: string;\n  region: string;\n};\n\nexport type AddTableColumnError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type AddTableColumnVariables = {\n  body: Schemas.Column;\n  pathParams: AddTableColumnPathParams;\n} & DataPlaneFetcherExtraProps;\n\n/**\n * Adds a new column to the table. The body of the request should contain the column definition.\n */\nexport const addTableColumn = (variables: AddTableColumnVariables, signal?: AbortSignal) =>\n  dataPlaneFetch<Responses.SchemaUpdateResponse, AddTableColumnError, Schemas.Column, {}, {}, AddTableColumnPathParams>(\n    {\n      url: '/db/{dbBranchName}/tables/{tableName}/columns',\n      method: 'post',\n      ...variables,\n      signal\n    }\n  );\n\nexport type GetColumnPathParams = {\n  /**\n   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.\n   */\n  dbBranchName: Schemas.DBBranchName;\n  /**\n   * The Table name\n   */\n  tableName: Schemas.TableName;\n  /**\n   * The Column name\n   */\n  columnName: Schemas.ColumnName;\n  workspace: string;\n  region: string;\n};\n\nexport type GetColumnError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type GetColumnVariables = {\n  pathParams: GetColumnPathParams;\n} & DataPlaneFetcherExtraProps;\n\n/**\n * Get the definition of a single column.\n */\nexport const getColumn = (variables: GetColumnVariables, signal?: AbortSignal) =>\n  dataPlaneFetch<Schemas.Column, GetColumnError, undefined, {}, {}, GetColumnPathParams>({\n    url: '/db/{dbBranchName}/tables/{tableName}/columns/{columnName}',\n    method: 'get',\n    ...variables,\n    signal\n  });\n\nexport type UpdateColumnPathParams = {\n  /**\n   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.\n   */\n  dbBranchName: Schemas.DBBranchName;\n  /**\n   * The Table name\n   */\n  tableName: Schemas.TableName;\n  /**\n   * The Column name\n   */\n  columnName: Schemas.ColumnName;\n  workspace: string;\n  region: string;\n};\n\nexport type UpdateColumnError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type UpdateColumnRequestBody = {\n  /**\n   * @minLength 1\n   */\n  name: string;\n};\n\nexport type UpdateColumnVariables = {\n  body: UpdateColumnRequestBody;\n  pathParams: UpdateColumnPathParams;\n} & DataPlaneFetcherExtraProps;\n\n/**\n * Update column with partial data. Can be used for renaming the column by providing a new \"name\" field.\n */\nexport const updateColumn = (variables: UpdateColumnVariables, signal?: AbortSignal) =>\n  dataPlaneFetch<\n    Responses.SchemaUpdateResponse,\n    UpdateColumnError,\n    UpdateColumnRequestBody,\n    {},\n    {},\n    UpdateColumnPathParams\n  >({\n    url: '/db/{dbBranchName}/tables/{tableName}/columns/{columnName}',\n    method: 'patch',\n    ...variables,\n    signal\n  });\n\nexport type DeleteColumnPathParams = {\n  /**\n   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.\n   */\n  dbBranchName: Schemas.DBBranchName;\n  /**\n   * The Table name\n   */\n  tableName: Schemas.TableName;\n  /**\n   * The Column name\n   */\n  columnName: Schemas.ColumnName;\n  workspace: string;\n  region: string;\n};\n\nexport type DeleteColumnError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type DeleteColumnVariables = {\n  pathParams: DeleteColumnPathParams;\n} & DataPlaneFetcherExtraProps;\n\n/**\n * Deletes the specified column.\n */\nexport const deleteColumn = (variables: DeleteColumnVariables, signal?: AbortSignal) =>\n  dataPlaneFetch<Responses.SchemaUpdateResponse, DeleteColumnError, undefined, {}, {}, DeleteColumnPathParams>({\n    url: '/db/{dbBranchName}/tables/{tableName}/columns/{columnName}',\n    method: 'delete',\n    ...variables,\n    signal\n  });\n\nexport type BranchTransactionPathParams = {\n  /**\n   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.\n   */\n  dbBranchName: Schemas.DBBranchName;\n  workspace: string;\n  region: string;\n};\n\nexport type BranchTransactionError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Schemas.TransactionFailure;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n  | {\n      status: 429;\n      payload: Responses.RateLimitError;\n    }\n>;\n\nexport type BranchTransactionRequestBody = {\n  operations: Schemas.TransactionOperation[];\n};\n\nexport type BranchTransactionVariables = {\n  body: BranchTransactionRequestBody;\n  pathParams: BranchTransactionPathParams;\n} & DataPlaneFetcherExtraProps;\n\nexport const branchTransaction = (variables: BranchTransactionVariables, signal?: AbortSignal) =>\n  dataPlaneFetch<\n    Schemas.TransactionSuccess,\n    BranchTransactionError,\n    BranchTransactionRequestBody,\n    {},\n    {},\n    BranchTransactionPathParams\n  >({\n    url: '/db/{dbBranchName}/transaction',\n    method: 'post',\n    ...variables,\n    signal\n  });\n\nexport type InsertRecordPathParams = {\n  /**\n   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.\n   */\n  dbBranchName: Schemas.DBBranchName;\n  /**\n   * The Table name\n   */\n  tableName: Schemas.TableName;\n  workspace: string;\n  region: string;\n};\n\nexport type InsertRecordQueryParams = {\n  /**\n   * Column filters\n   */\n  columns?: Schemas.ColumnsProjection;\n};\n\nexport type InsertRecordError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type InsertRecordVariables = {\n  body?: Schemas.DataInputRecord;\n  pathParams: InsertRecordPathParams;\n  queryParams?: InsertRecordQueryParams;\n} & DataPlaneFetcherExtraProps;\n\n/**\n * Insert a new Record into the Table\n */\nexport const insertRecord = (variables: InsertRecordVariables, signal?: AbortSignal) =>\n  dataPlaneFetch<\n    Responses.RecordUpdateResponse,\n    InsertRecordError,\n    Schemas.DataInputRecord,\n    {},\n    InsertRecordQueryParams,\n    InsertRecordPathParams\n  >({\n    url: '/db/{dbBranchName}/tables/{tableName}/data',\n    method: 'post',\n    ...variables,\n    signal\n  });\n\nexport type GetFileItemPathParams = {\n  /**\n   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.\n   */\n  dbBranchName: Schemas.DBBranchName;\n  /**\n   * The Table name\n   */\n  tableName: Schemas.TableName;\n  /**\n   * The Record name\n   */\n  recordId: Schemas.RecordID;\n  /**\n   * The Column name\n   */\n  columnName: Schemas.ColumnName;\n  /**\n   * The File Identifier\n   */\n  fileId: Schemas.FileItemID;\n  workspace: string;\n  region: string;\n};\n\nexport type GetFileItemError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type GetFileItemVariables = {\n  pathParams: GetFileItemPathParams;\n} & DataPlaneFetcherExtraProps;\n\n/**\n * Retrieves file content from an array by file ID\n */\nexport const getFileItem = (variables: GetFileItemVariables, signal?: AbortSignal) =>\n  dataPlaneFetch<Blob, GetFileItemError, undefined, {}, {}, GetFileItemPathParams>({\n    url: '/db/{dbBranchName}/tables/{tableName}/data/{recordId}/column/{columnName}/file/{fileId}',\n    method: 'get',\n    ...variables,\n    signal\n  });\n\nexport type PutFileItemPathParams = {\n  /**\n   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.\n   */\n  dbBranchName: Schemas.DBBranchName;\n  /**\n   * The Table name\n   */\n  tableName: Schemas.TableName;\n  /**\n   * The Record name\n   */\n  recordId: Schemas.RecordID;\n  /**\n   * The Column name\n   */\n  columnName: Schemas.ColumnName;\n  /**\n   * The File Identifier\n   */\n  fileId: Schemas.FileItemID;\n  workspace: string;\n  region: string;\n};\n\nexport type PutFileItemError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n  | {\n      status: 422;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type PutFileItemVariables = {\n  body?: Blob;\n  pathParams: PutFileItemPathParams;\n} & DataPlaneFetcherExtraProps;\n\n/**\n * Uploads the file content to an array given the file ID\n */\nexport const putFileItem = (variables: PutFileItemVariables, signal?: AbortSignal) =>\n  dataPlaneFetch<Responses.PutFileResponse, PutFileItemError, Blob, {}, {}, PutFileItemPathParams>({\n    url: '/db/{dbBranchName}/tables/{tableName}/data/{recordId}/column/{columnName}/file/{fileId}',\n    method: 'put',\n    ...variables,\n    signal\n  });\n\nexport type DeleteFileItemPathParams = {\n  /**\n   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.\n   */\n  dbBranchName: Schemas.DBBranchName;\n  /**\n   * The Table name\n   */\n  tableName: Schemas.TableName;\n  /**\n   * The Record name\n   */\n  recordId: Schemas.RecordID;\n  /**\n   * The Column name\n   */\n  columnName: Schemas.ColumnName;\n  /**\n   * The File Identifier\n   */\n  fileId: Schemas.FileItemID;\n  workspace: string;\n  region: string;\n};\n\nexport type DeleteFileItemError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type DeleteFileItemVariables = {\n  pathParams: DeleteFileItemPathParams;\n} & DataPlaneFetcherExtraProps;\n\n/**\n * Deletes an item from an file array column given the file ID\n */\nexport const deleteFileItem = (variables: DeleteFileItemVariables, signal?: AbortSignal) =>\n  dataPlaneFetch<Responses.PutFileResponse, DeleteFileItemError, undefined, {}, {}, DeleteFileItemPathParams>({\n    url: '/db/{dbBranchName}/tables/{tableName}/data/{recordId}/column/{columnName}/file/{fileId}',\n    method: 'delete',\n    ...variables,\n    signal\n  });\n\nexport type GetFilePathParams = {\n  /**\n   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.\n   */\n  dbBranchName: Schemas.DBBranchName;\n  /**\n   * The Table name\n   */\n  tableName: Schemas.TableName;\n  /**\n   * The Record name\n   */\n  recordId: Schemas.RecordID;\n  /**\n   * The Column name\n   */\n  columnName: Schemas.ColumnName;\n  workspace: string;\n  region: string;\n};\n\nexport type GetFileError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type GetFileVariables = {\n  pathParams: GetFilePathParams;\n} & DataPlaneFetcherExtraProps;\n\n/**\n * Retrieves the file content from a file column\n */\nexport const getFile = (variables: GetFileVariables, signal?: AbortSignal) =>\n  dataPlaneFetch<Blob, GetFileError, undefined, {}, {}, GetFilePathParams>({\n    url: '/db/{dbBranchName}/tables/{tableName}/data/{recordId}/column/{columnName}/file',\n    method: 'get',\n    ...variables,\n    signal\n  });\n\nexport type PutFilePathParams = {\n  /**\n   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.\n   */\n  dbBranchName: Schemas.DBBranchName;\n  /**\n   * The Table name\n   */\n  tableName: Schemas.TableName;\n  /**\n   * The Record name\n   */\n  recordId: Schemas.RecordID;\n  /**\n   * The Column name\n   */\n  columnName: Schemas.ColumnName;\n  workspace: string;\n  region: string;\n};\n\nexport type PutFileError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n  | {\n      status: 422;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type PutFileVariables = {\n  body?: Blob;\n  pathParams: PutFilePathParams;\n} & DataPlaneFetcherExtraProps;\n\n/**\n * Uploads the file content to the given file column\n */\nexport const putFile = (variables: PutFileVariables, signal?: AbortSignal) =>\n  dataPlaneFetch<Responses.PutFileResponse, PutFileError, Blob, {}, {}, PutFilePathParams>({\n    url: '/db/{dbBranchName}/tables/{tableName}/data/{recordId}/column/{columnName}/file',\n    method: 'put',\n    ...variables,\n    signal\n  });\n\nexport type DeleteFilePathParams = {\n  /**\n   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.\n   */\n  dbBranchName: Schemas.DBBranchName;\n  /**\n   * The Table name\n   */\n  tableName: Schemas.TableName;\n  /**\n   * The Record name\n   */\n  recordId: Schemas.RecordID;\n  /**\n   * The Column name\n   */\n  columnName: Schemas.ColumnName;\n  workspace: string;\n  region: string;\n};\n\nexport type DeleteFileError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type DeleteFileVariables = {\n  pathParams: DeleteFilePathParams;\n} & DataPlaneFetcherExtraProps;\n\n/**\n * Deletes a file referred in a file column\n */\nexport const deleteFile = (variables: DeleteFileVariables, signal?: AbortSignal) =>\n  dataPlaneFetch<Responses.PutFileResponse, DeleteFileError, undefined, {}, {}, DeleteFilePathParams>({\n    url: '/db/{dbBranchName}/tables/{tableName}/data/{recordId}/column/{columnName}/file',\n    method: 'delete',\n    ...variables,\n    signal\n  });\n\nexport type GetRecordPathParams = {\n  /**\n   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.\n   */\n  dbBranchName: Schemas.DBBranchName;\n  /**\n   * The Table name\n   */\n  tableName: Schemas.TableName;\n  /**\n   * The Record name\n   */\n  recordId: Schemas.RecordID;\n  workspace: string;\n  region: string;\n};\n\nexport type GetRecordQueryParams = {\n  /**\n   * Column filters\n   */\n  columns?: Schemas.ColumnsProjection;\n};\n\nexport type GetRecordError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type GetRecordVariables = {\n  pathParams: GetRecordPathParams;\n  queryParams?: GetRecordQueryParams;\n} & DataPlaneFetcherExtraProps;\n\n/**\n * Retrieve record by ID\n */\nexport const getRecord = (variables: GetRecordVariables, signal?: AbortSignal) =>\n  dataPlaneFetch<Responses.RecordResponse, GetRecordError, undefined, {}, GetRecordQueryParams, GetRecordPathParams>({\n    url: '/db/{dbBranchName}/tables/{tableName}/data/{recordId}',\n    method: 'get',\n    ...variables,\n    signal\n  });\n\nexport type InsertRecordWithIDPathParams = {\n  /**\n   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.\n   */\n  dbBranchName: Schemas.DBBranchName;\n  /**\n   * The Table name\n   */\n  tableName: Schemas.TableName;\n  /**\n   * The Record name\n   */\n  recordId: Schemas.RecordID;\n  workspace: string;\n  region: string;\n};\n\nexport type InsertRecordWithIDQueryParams = {\n  /**\n   * Column filters\n   */\n  columns?: Schemas.ColumnsProjection;\n  createOnly?: boolean;\n  ifVersion?: number;\n};\n\nexport type InsertRecordWithIDError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n  | {\n      status: 422;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type InsertRecordWithIDVariables = {\n  body?: Schemas.DataInputRecord;\n  pathParams: InsertRecordWithIDPathParams;\n  queryParams?: InsertRecordWithIDQueryParams;\n} & DataPlaneFetcherExtraProps;\n\n/**\n * By default, IDs are auto-generated when data is inserted into Xata. Sending a request to this endpoint allows us to insert a record with a pre-existing ID, bypassing the default automatic ID generation.\n */\nexport const insertRecordWithID = (variables: InsertRecordWithIDVariables, signal?: AbortSignal) =>\n  dataPlaneFetch<\n    Responses.RecordUpdateResponse,\n    InsertRecordWithIDError,\n    Schemas.DataInputRecord,\n    {},\n    InsertRecordWithIDQueryParams,\n    InsertRecordWithIDPathParams\n  >({\n    url: '/db/{dbBranchName}/tables/{tableName}/data/{recordId}',\n    method: 'put',\n    ...variables,\n    signal\n  });\n\nexport type UpdateRecordWithIDPathParams = {\n  /**\n   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.\n   */\n  dbBranchName: Schemas.DBBranchName;\n  /**\n   * The Table name\n   */\n  tableName: Schemas.TableName;\n  /**\n   * The Record name\n   */\n  recordId: Schemas.RecordID;\n  workspace: string;\n  region: string;\n};\n\nexport type UpdateRecordWithIDQueryParams = {\n  /**\n   * Column filters\n   */\n  columns?: Schemas.ColumnsProjection;\n  ifVersion?: number;\n};\n\nexport type UpdateRecordWithIDError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n  | {\n      status: 422;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type UpdateRecordWithIDVariables = {\n  body?: Schemas.DataInputRecord;\n  pathParams: UpdateRecordWithIDPathParams;\n  queryParams?: UpdateRecordWithIDQueryParams;\n} & DataPlaneFetcherExtraProps;\n\nexport const updateRecordWithID = (variables: UpdateRecordWithIDVariables, signal?: AbortSignal) =>\n  dataPlaneFetch<\n    Responses.RecordUpdateResponse,\n    UpdateRecordWithIDError,\n    Schemas.DataInputRecord,\n    {},\n    UpdateRecordWithIDQueryParams,\n    UpdateRecordWithIDPathParams\n  >({\n    url: '/db/{dbBranchName}/tables/{tableName}/data/{recordId}',\n    method: 'patch',\n    ...variables,\n    signal\n  });\n\nexport type UpsertRecordWithIDPathParams = {\n  /**\n   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.\n   */\n  dbBranchName: Schemas.DBBranchName;\n  /**\n   * The Table name\n   */\n  tableName: Schemas.TableName;\n  /**\n   * The Record name\n   */\n  recordId: Schemas.RecordID;\n  workspace: string;\n  region: string;\n};\n\nexport type UpsertRecordWithIDQueryParams = {\n  /**\n   * Column filters\n   */\n  columns?: Schemas.ColumnsProjection;\n  ifVersion?: number;\n};\n\nexport type UpsertRecordWithIDError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n  | {\n      status: 422;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type UpsertRecordWithIDVariables = {\n  body?: Schemas.DataInputRecord;\n  pathParams: UpsertRecordWithIDPathParams;\n  queryParams?: UpsertRecordWithIDQueryParams;\n} & DataPlaneFetcherExtraProps;\n\nexport const upsertRecordWithID = (variables: UpsertRecordWithIDVariables, signal?: AbortSignal) =>\n  dataPlaneFetch<\n    Responses.RecordUpdateResponse,\n    UpsertRecordWithIDError,\n    Schemas.DataInputRecord,\n    {},\n    UpsertRecordWithIDQueryParams,\n    UpsertRecordWithIDPathParams\n  >({\n    url: '/db/{dbBranchName}/tables/{tableName}/data/{recordId}',\n    method: 'post',\n    ...variables,\n    signal\n  });\n\nexport type DeleteRecordPathParams = {\n  /**\n   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.\n   */\n  dbBranchName: Schemas.DBBranchName;\n  /**\n   * The Table name\n   */\n  tableName: Schemas.TableName;\n  /**\n   * The Record name\n   */\n  recordId: Schemas.RecordID;\n  workspace: string;\n  region: string;\n};\n\nexport type DeleteRecordQueryParams = {\n  /**\n   * Column filters\n   */\n  columns?: Schemas.ColumnsProjection;\n};\n\nexport type DeleteRecordError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type DeleteRecordVariables = {\n  pathParams: DeleteRecordPathParams;\n  queryParams?: DeleteRecordQueryParams;\n} & DataPlaneFetcherExtraProps;\n\nexport const deleteRecord = (variables: DeleteRecordVariables, signal?: AbortSignal) =>\n  dataPlaneFetch<\n    Responses.RecordResponse,\n    DeleteRecordError,\n    undefined,\n    {},\n    DeleteRecordQueryParams,\n    DeleteRecordPathParams\n  >({\n    url: '/db/{dbBranchName}/tables/{tableName}/data/{recordId}',\n    method: 'delete',\n    ...variables,\n    signal\n  });\n\nexport type BulkInsertTableRecordsPathParams = {\n  /**\n   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.\n   */\n  dbBranchName: Schemas.DBBranchName;\n  /**\n   * The Table name\n   */\n  tableName: Schemas.TableName;\n  workspace: string;\n  region: string;\n};\n\nexport type BulkInsertTableRecordsQueryParams = {\n  /**\n   * Column filters\n   */\n  columns?: Schemas.ColumnsProjection;\n};\n\nexport type BulkInsertTableRecordsError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BulkError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n  | {\n      status: 422;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type BulkInsertTableRecordsRequestBody = {\n  records: Schemas.DataInputRecord[];\n};\n\nexport type BulkInsertTableRecordsVariables = {\n  body: BulkInsertTableRecordsRequestBody;\n  pathParams: BulkInsertTableRecordsPathParams;\n  queryParams?: BulkInsertTableRecordsQueryParams;\n} & DataPlaneFetcherExtraProps;\n\n/**\n * Bulk insert records\n */\nexport const bulkInsertTableRecords = (variables: BulkInsertTableRecordsVariables, signal?: AbortSignal) =>\n  dataPlaneFetch<\n    Responses.BulkInsertResponse,\n    BulkInsertTableRecordsError,\n    BulkInsertTableRecordsRequestBody,\n    {},\n    BulkInsertTableRecordsQueryParams,\n    BulkInsertTableRecordsPathParams\n  >({\n    url: '/db/{dbBranchName}/tables/{tableName}/bulk',\n    method: 'post',\n    ...variables,\n    signal\n  });\n\nexport type QueryTablePathParams = {\n  /**\n   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.\n   */\n  dbBranchName: Schemas.DBBranchName;\n  /**\n   * The Table name\n   */\n  tableName: Schemas.TableName;\n  workspace: string;\n  region: string;\n};\n\nexport type QueryTableError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n  | {\n      status: 503;\n      payload: Responses.ServiceUnavailableError;\n    }\n>;\n\nexport type QueryTableRequestBody = {\n  filter?: Schemas.FilterExpression;\n  sort?: Schemas.SortExpression;\n  page?: Schemas.PageConfig;\n  columns?: Schemas.QueryColumnsProjection;\n  /**\n   * The consistency level for this request.\n   *\n   * @default strong\n   */\n  consistency?: 'strong' | 'eventual';\n};\n\nexport type QueryTableVariables = {\n  body?: QueryTableRequestBody;\n  pathParams: QueryTablePathParams;\n} & DataPlaneFetcherExtraProps;\n\n/**\n * The Query Table API can be used to retrieve all records in a table.\n * The API support filtering, sorting, selecting a subset of columns, and pagination.\n *\n * The overall structure of the request looks like this:\n *\n * ```json\n * // POST /db/<dbname>:<branch>/tables/<table>/query\n * {\n *   \"columns\": [...],\n *   \"filter\": {\n *     \"$all\": [...],\n *     \"$any\": [...]\n *     ...\n *   },\n *   \"sort\": {\n *     \"multiple\": [...]\n *     ...\n *   },\n *   \"page\": {\n *     ...\n *   }\n * }\n * ```\n *\n * For usage, see also the [Xata SDK documentation](https://xata.io/docs/sdk/get).\n *\n * ### Column selection\n *\n * If the `columns` array is not specified, all columns are included. For link\n * fields, only the ID column of the linked records is included in the response.\n *\n * If the `columns` array is specified, only the selected and internal\n * columns `id` and `xata` are included. The `*` wildcard can be used to\n * select all columns.\n *\n * For objects and link fields, if the column name of the object is specified, we\n * include all of its sub-keys. If only some sub-keys are specified (via dotted\n * notation, e.g. `\"settings.plan\"` ), then only those sub-keys from the object\n * are included.\n *\n * By the way of example, assuming two tables like this:\n *\n * ```json {\"truncate\": true}\n * {\n *   \"tables\": [\n *     {\n *       \"name\": \"teams\",\n *       \"columns\": [\n *         {\n *           \"name\": \"name\",\n *           \"type\": \"string\"\n *         },\n *         {\n *           \"name\": \"owner\",\n *           \"type\": \"link\",\n *           \"link\": {\n *             \"table\": \"users\"\n *           }\n *         },\n *         {\n *           \"name\": \"foundedDate\",\n *           \"type\": \"datetime\"\n *         },\n *       ]\n *     },\n *     {\n *       \"name\": \"users\",\n *       \"columns\": [\n *         {\n *           \"name\": \"email\",\n *           \"type\": \"email\"\n *         },\n *         {\n *           \"name\": \"full_name\",\n *           \"type\": \"string\"\n *         },\n *         {\n *           \"name\": \"address\",\n *           \"type\": \"object\",\n *           \"columns\": [\n *             {\n *               \"name\": \"street\",\n *               \"type\": \"string\"\n *             },\n *             {\n *               \"name\": \"number\",\n *               \"type\": \"int\"\n *             },\n *             {\n *               \"name\": \"zipcode\",\n *               \"type\": \"int\"\n *             }\n *           ]\n *         },\n *         {\n *           \"name\": \"team\",\n *           \"type\": \"link\",\n *           \"link\": {\n *             \"table\": \"teams\"\n *           }\n *         }\n *       ]\n *     }\n *   ]\n * }\n * ```\n *\n * A query like this:\n *\n * ```json\n * POST /db/<dbname>:<branch>/tables/<table>/query\n * {\n *   \"columns\": [\n *     \"name\",\n *     \"address.*\"\n *   ]\n * }\n * ```\n *\n * returns objects like:\n *\n * ```json\n * {\n *   \"name\": \"Kilian\",\n *   \"address\": {\n *     \"street\": \"New street\",\n *     \"number\": 41,\n *     \"zipcode\": 10407\n *   }\n * }\n * ```\n *\n * while a query like this:\n *\n * ```json\n * POST /db/<dbname>:<branch>/tables/<table>/query\n * {\n *   \"columns\": [\n *     \"name\",\n *     \"address.street\"\n *   ]\n * }\n * ```\n *\n * returns objects like:\n *\n * ```json\n * {\n *   \"id\": \"id1\"\n *   \"xata\": {\n *     \"version\": 0\n *   }\n *   \"name\": \"Kilian\",\n *   \"address\": {\n *     \"street\": \"New street\"\n *   }\n * }\n * ```\n *\n * If you want to return all columns from the main table and selected columns from the linked table, you can do it like this:\n *\n * ```json\n * {\n *   \"columns\": [\"*\", \"team.name\"]\n * }\n * ```\n *\n * The `\"*\"` in the above means all columns, including columns of objects. This returns data like:\n *\n * ```json\n * {\n *   \"id\": \"id1\"\n *   \"xata\": {\n *     \"version\": 0\n *   }\n *   \"name\": \"Kilian\",\n *   \"email\": \"kilian@gmail.com\",\n *   \"address\": {\n *     \"street\": \"New street\",\n *     \"number\": 41,\n *     \"zipcode\": 10407\n *   },\n *   \"team\": {\n *     \"id\": \"XX\",\n *     \"xata\": {\n *       \"version\": 0\n *     },\n *     \"name\": \"first team\"\n *   }\n * }\n * ```\n *\n * If you want all columns of the linked table, you can do:\n *\n * ```json\n * {\n *   \"columns\": [\"*\", \"team.*\"]\n * }\n * ```\n *\n * This returns, for example:\n *\n * ```json\n * {\n *   \"id\": \"id1\"\n *   \"xata\": {\n *     \"version\": 0\n *   }\n *   \"name\": \"Kilian\",\n *   \"email\": \"kilian@gmail.com\",\n *   \"address\": {\n *     \"street\": \"New street\",\n *     \"number\": 41,\n *     \"zipcode\": 10407\n *   },\n *   \"team\": {\n *     \"id\": \"XX\",\n *     \"xata\": {\n *       \"version\": 0\n *     },\n *     \"name\": \"first team\",\n *     \"code\": \"A1\",\n *     \"foundedDate\": \"2020-03-04T10:43:54.32Z\"\n *   }\n * }\n * ```\n *\n * ### Filtering\n *\n * There are two types of operators:\n *\n * - Operators that work on a single column: `$is`, `$contains`, `$pattern`,\n *   `$includes`, `$gt`, etc.\n * - Control operators that combine multiple conditions: `$any`, `$all`, `$not` ,\n *   `$none`, etc.\n *\n * All operators start with an `$` to differentiate them from column names\n * (which are not allowed to start with a dollar sign).\n *\n * #### Exact matching and control operators\n *\n * Filter by one column:\n *\n * ```json\n * {\n *   \"filter\": {\n *     \"<column_name>\": \"value\"\n *   }\n * }\n * ```\n *\n * This is equivalent to using the `$is` operator:\n *\n * ```json\n * {\n *   \"filter\": {\n *     \"<column_name>\": {\n *       \"$is\": \"value\"\n *     }\n *   }\n * }\n * ```\n *\n * For example:\n *\n * ```json\n * {\n *   \"filter\": {\n *     \"name\": \"r2\"\n *   }\n * }\n * ```\n *\n * Or:\n *\n * ```json\n * {\n *   \"filter\": {\n *     \"name\": {\n *       \"$is\": \"r2\"\n *     }\n *   }\n * }\n * ```\n *\n * For objects, both dots and nested versions work:\n *\n * ```json\n * {\n *   \"filter\": {\n *     \"settings.plan\": \"free\"\n *   }\n * }\n * ```\n *\n * ```json\n * {\n *   \"filter\": {\n *     \"settings\": {\n *       \"plan\": \"free\"\n *     }\n *   }\n * }\n * ```\n *\n * If you want to OR together multiple values, you can use the `$any` operator with an array of values:\n *\n * ```json\n * {\n *   \"filter\": {\n *     \"settings.plan\": { \"$any\": [\"free\", \"paid\"] }\n *   }\n * }\n * ```\n *\n * If you specify multiple columns in the same filter, they are logically AND'ed together:\n *\n * ```json\n * {\n *   \"filter\": {\n *     \"settings.dark\": true,\n *     \"settings.plan\": \"free\"\n *   }\n * }\n * ```\n *\n * The above matches if both conditions are met.\n *\n * To be more explicit about it, you can use `$all` or `$any`:\n *\n * ```json\n * {\n *   \"filter\": {\n *     \"$any\": {\n *       \"settings.dark\": true,\n *       \"settings.plan\": \"free\"\n *     }\n *   }\n * }\n * ```\n *\n * The `$all` and `$any` operators can also receive an array of objects, which allows for repeating column names:\n *\n * ```json\n * {\n *   \"filter\": {\n *     \"$any\": [\n *       {\n *         \"name\": \"r1\"\n *       },\n *       {\n *         \"name\": \"r2\"\n *       }\n *     ]\n *   }\n * }\n * ```\n *\n * You can check for a value being not-null with `$exists`:\n *\n * ```json\n * {\n *   \"filter\": {\n *     \"$exists\": \"settings\"\n *   }\n * }\n * ```\n *\n * This can be combined with `$all` or `$any` :\n *\n * ```json\n * {\n *   \"filter\": {\n *     \"$all\": [\n *       {\n *         \"$exists\": \"settings\"\n *       },\n *       {\n *         \"$exists\": \"name\"\n *       }\n *     ]\n *   }\n * }\n * ```\n *\n * Or you can use the inverse operator `$notExists`:\n *\n * ```json\n * {\n *   \"filter\": {\n *     \"$notExists\": \"settings\"\n *   }\n * }\n * ```\n *\n * #### Partial match\n *\n * `$contains` is the simplest operator for partial matching. Note that `$contains` operator can\n * cause performance issues at scale, because indices cannot be used.\n *\n * ```json\n * {\n *   \"filter\": {\n *     \"<column_name>\": {\n *       \"$contains\": \"value\"\n *     }\n *   }\n * }\n * ```\n *\n * Wildcards are supported via the `$pattern` operator:\n *\n * ```json\n * {\n *   \"filter\": {\n *     \"<column_name>\": {\n *       \"$pattern\": \"v*alu?\"\n *     }\n *   }\n * }\n * ```\n *\n * The `$pattern` operator accepts two wildcard characters:\n * * `*` matches zero or more characters\n * * `?` matches exactly one character\n *\n * If you want to match a string that contains a wildcard character, you can escape them using a backslash (`\\`). You can escape a backslash by usign another backslash.\n *\n * You can also use the `$endsWith` and `$startsWith` operators:\n *\n * ```json\n * {\n *   \"filter\": {\n *     \"<column_name>\": {\n *       \"$endsWith\": \".gz\"\n *     },\n *     \"<column_name>\": {\n *       \"$startsWith\": \"tmp-\"\n *     }\n *   }\n * }\n * ```\n *\n * #### Numeric or datetime ranges\n *\n * ```json\n * {\n *   \"filter\": {\n *     \"<column_name>\": {\n *       \"$ge\": 0,\n *       \"$lt\": 100\n *     }\n *   }\n * }\n * ```\n * Date ranges support the same operators, with the date using the format defined in\n * [RFC 3339](https://www.rfc-editor.org/rfc/rfc3339):\n * ```json\n * {\n *   \"filter\": {\n *     \"<column_name>\": {\n *       \"$gt\": \"2019-10-12T07:20:50.52Z\",\n *       \"$lt\": \"2021-10-12T07:20:50.52Z\"\n *     }\n *   }\n * }\n * ```\n * The supported operators are `$gt`, `$lt`, `$ge`, `$le`.\n *\n * #### Negations\n *\n * A general `$not` operator can inverse any operation.\n *\n * ```json\n * {\n *   \"filter\": {\n *     \"$not\": {\n *       \"<column_name1>\": \"value1\",\n *       \"<column_name2>\": \"value1\"\n *     }\n *   }\n * }\n * ```\n *\n * Note: in the above the two condition are AND together, so this does (NOT ( ...\n * AND ...))\n *\n * Or more complex:\n *\n * ```json\n * {\n *   \"filter\": {\n *     \"$not\": {\n *       \"$any\": [\n *         {\n *           \"<column_name1>\": \"value1\"\n *         },\n *         {\n *           \"$all\": [\n *             {\n *               \"<column_name2>\": \"value2\"\n *             },\n *             {\n *               \"<column_name3>\": \"value3\"\n *             }\n *           ]\n *         }\n *       ]\n *     }\n *   }\n * }\n * ```\n *\n * The `$not: { $any: {}}` can be shorted using the `$none` operator:\n *\n * ```json\n * {\n *   \"filter\": {\n *     \"$none\": {\n *       \"<column_name1>\": \"value1\",\n *       \"<column_name2>\": \"value1\"\n *     }\n *   }\n * }\n * ```\n *\n * In addition, you can use operators like `$isNot` or `$notExists` to simplify expressions:\n *\n * ```json\n * {\n *   \"filter\": {\n *     \"<column_name>\": {\n *       \"$isNot\": \"2019-10-12T07:20:50.52Z\"\n *     }\n *   }\n * }\n * ```\n *\n * #### Working with arrays\n *\n * To test that an array contains a value, use `$includesAny`.\n *\n * ```json\n * {\n *   \"filter\": {\n *     \"<array_name>\": {\n *       \"$includesAny\": \"value\"\n *     }\n *   }\n * }\n * ```\n *\n * ##### `includesAny`\n *\n * The `$includesAny` operator accepts a custom predicate that will check if\n * any value in the array column matches the predicate. The `$includes` operator is a\n * synonym for the `$includesAny` operator.\n *\n * For example a complex predicate can include\n * the `$all` , `$contains` and `$endsWith` operators:\n *\n * ```json\n * {\n *   \"filter\": {\n *     \"<array name>\": {\n *       \"$includes\": {\n *         \"$all\": [\n *           { \"$contains\": \"label\" },\n *           { \"$not\": { \"$endsWith\": \"-debug\" } }\n *         ]\n *       }\n *     }\n *   }\n * }\n * ```\n *\n * ##### `includesNone`\n *\n * The `$includesNone` operator succeeds if no array item matches the\n * predicate.\n *\n * ```json\n * {\n *   \"filter\": {\n *     \"settings.labels\": {\n *       \"$includesNone\": [{ \"$contains\": \"label\" }]\n *     }\n *   }\n * }\n * ```\n * The above matches if none of the array values contain the string \"label\".\n *\n * ##### `includesAll`\n *\n * The `$includesAll` operator succeeds if all array items match the\n * predicate.\n *\n * Here is an example of using the `$includesAll` operator:\n *\n * ```json\n * {\n *   \"filter\": {\n *     \"settings.labels\": {\n *       \"$includesAll\": [{ \"$contains\": \"label\" }]\n *     }\n *   }\n * }\n * ```\n *\n * The above matches if all array values contain the string \"label\".\n *\n * ### Sorting\n *\n * Sorting by one element:\n *\n * ```json\n * POST /db/demo:main/tables/table/query\n * {\n *   \"sort\": {\n *     \"index\": \"asc\"\n *   }\n * }\n * ```\n *\n * or descendently:\n *\n * ```json\n * POST /db/demo:main/tables/table/query\n * {\n *   \"sort\": {\n *     \"index\": \"desc\"\n *   }\n * }\n * ```\n *\n * Sorting by multiple fields:\n *\n * ```json\n * POST /db/demo:main/tables/table/query\n * {\n *   \"sort\": [\n *     {\n *       \"index\": \"desc\"\n *     },\n *     {\n *       \"createdAt\": \"desc\"\n *     }\n *   ]\n * }\n * ```\n *\n * It is also possible to sort results randomly:\n *\n * ```json\n * POST /db/demo:main/tables/table/query\n * {\n *   \"sort\": {\n *     \"*\": \"random\"\n *   }\n * }\n * ```\n *\n * Note that a random sort does not apply to a specific column, hence the special column name `\"*\"`.\n *\n * A random sort can be combined with an ascending or descending sort on a specific column:\n *\n * ```json\n * POST /db/demo:main/tables/table/query\n * {\n *   \"sort\": [\n *     {\n *       \"name\": \"desc\"\n *     },\n *     {\n *       \"*\": \"random\"\n *     }\n *   ]\n * }\n * ```\n *\n * This will sort on the `name` column, breaking ties randomly.\n *\n * ### Pagination\n *\n * We offer cursor pagination and offset pagination. The cursor pagination method can be used for sequential scrolling with unrestricted depth. The offset pagination can be used to skip pages and is limited to 1000 records.\n *\n * Example of cursor pagination:\n *\n * ```json\n * POST /db/demo:main/tables/table/query\n * {\n *   \"page\": {\n *     \"after\":\"fMoxCsIwFIDh3WP8c4amDai5hO5SJCRNfaVSeC9b6d1FD\"\n *   }\n * }\n * ```\n *\n * In the above example, the value of the `page.after` parameter is the cursor returned by the previous query. A sample response is shown below:\n *\n * ```json\n * {\n *   \"meta\": {\n *     \"page\": {\n *       \"cursor\": \"fMoxCsIwFIDh3WP8c4amDai5hO5SJCRNfaVSeC9b6d1FD\",\n *       \"more\": true\n *     }\n *   },\n *   \"records\": [...]\n * }\n * ```\n *\n * The `page` object might contain the follow keys, in addition to `size` and `offset` that were introduced before:\n *\n * - `after`: Return the next page 'after' the current cursor\n * - `before`: Return the previous page 'before' the current cursor.\n * - `start`: Resets the given cursor position to the beginning of the query result set.\n * Will return the first N records from the query result, where N is the `page.size` parameter.\n * - `end`: Resets the give cursor position to the end for the query result set.\n * Returns the last N records from the query result, where N is the `page.size` parameter.\n *\n * The request will fail if an invalid cursor value is given to `page.before`,\n * `page.after`, `page.start` , or `page.end`. No other cursor setting can be\n * used if `page.start` or `page.end` is set in a query.\n *\n * If both `page.before` and `page.after` parameters are present we treat the\n * request as a range query. The range query will return all entries after\n * `page.after`, but before `page.before`, up to `page.size` or the maximum\n * page size. This query requires both cursors to use the same filters and sort\n * settings, plus we require `page.after < page.before`. The range query returns\n * a new cursor. If the range encompass multiple pages the next page in the range\n * can be queried by update `page.after` to the returned cursor while keeping the\n * `page.before` cursor from the first range query.\n *\n * The `filter` , `columns`, `sort` , and `page.size` configuration will be\n * encoded with the cursor. The pagination request will be invalid if\n * `filter` or `sort` is set. The columns returned and page size can be changed\n * anytime by passing the `columns` or `page.size` settings to the next query.\n *\n * In the following example of size + offset pagination we retrieve the third page of up to 100 results:\n *\n * ```json\n * POST /db/demo:main/tables/table/query\n * {\n *   \"page\": {\n *     \"size\": 100,\n *     \"offset\": 200\n *   }\n * }\n * ```\n *\n * The `page.size` parameter represents the maximum number of records returned by this query. It has a default value of 20 and a maximum value of 200.\n * The `page.offset` parameter represents the number of matching records to skip. It has a default value of 0 and a maximum value of 800.\n *\n * Cursor pagination also works in combination with offset pagination. For example, starting from a specific cursor position, using a page size of 200 and an offset of 800, you can skip up to 5 pages of 200 records forwards or backwards from the cursor's position:\n *\n * ```json\n * POST /db/demo:main/tables/table/query\n * {\n *   \"page\": {\n *     \"size\": 200,\n *     \"offset\": 800,\n *     \"after\": \"fMoxCsIwFIDh3WP8c4amDai5hO5SJCRNfaVSeC9b6d1FD\"\n *   }\n * }\n * ```\n *\n * **Special cursors:**\n *\n * - `page.after=end`: Result points past the last entry. The list of records\n *   returned is empty, but `page.meta.cursor` will include a cursor that can be\n *   used to \"tail\" the table from the end waiting for new data to be inserted.\n * - `page.before=end`: This cursor returns the last page.\n * - `page.start=$cursor`: Start at the beginning of the result set of the $cursor query. This is equivalent to querying the\n *   first page without a cursor but applying `filter` and `sort` . Yet the `page.start`\n *   cursor can be convenient at times as user code does not need to remember the\n *   filter, sort, columns or page size configuration. All these information are\n *   read from the cursor.\n * - `page.end=$cursor`: Move to the end of the result set of the $cursor query. This is equivalent to querying the\n *   last page with `page.before=end`, `filter`, and `sort` . Yet the\n *   `page.end` cursor can be more convenient at times as user code does not\n *   need to remember the filter, sort, columns or page size configuration. All\n *   these information are read from the cursor.\n *\n * When using special cursors like `page.after=\"end\"` or `page.before=\"end\"`, we\n * still allow `filter` and `sort` to be set.\n *\n * Example of getting the last page:\n *\n * ```json\n * POST /db/demo:main/tables/table/query\n * {\n *   \"page\": {\n *     \"size\": 10,\n *     \"before\": \"end\"\n *   }\n * }\n * ```\n */\nexport const queryTable = (variables: QueryTableVariables, signal?: AbortSignal) =>\n  dataPlaneFetch<Responses.QueryResponse, QueryTableError, QueryTableRequestBody, {}, {}, QueryTablePathParams>({\n    url: '/db/{dbBranchName}/tables/{tableName}/query',\n    method: 'post',\n    ...variables,\n    signal\n  });\n\nexport type SearchBranchPathParams = {\n  /**\n   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.\n   */\n  dbBranchName: Schemas.DBBranchName;\n  workspace: string;\n  region: string;\n};\n\nexport type SearchBranchError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n  | {\n      status: 503;\n      payload: Responses.ServiceUnavailableError;\n    }\n>;\n\nexport type SearchBranchRequestBody = {\n  /**\n   * An array with the tables in which to search. By default, all tables are included. Optionally, filters can be included that apply to each table.\n   */\n  tables?: (\n    | string\n    | {\n        /**\n         * The name of the table.\n         */\n        table: string;\n        filter?: Schemas.FilterExpression;\n        target?: Schemas.TargetExpression;\n        boosters?: Schemas.BoosterExpression[];\n      }\n  )[];\n  /**\n   * The query string.\n   *\n   * @minLength 1\n   */\n  query: string;\n  fuzziness?: Schemas.FuzzinessExpression;\n  prefix?: Schemas.PrefixExpression;\n  highlight?: Schemas.HighlightExpression;\n  page?: Schemas.SearchPageConfig;\n};\n\nexport type SearchBranchVariables = {\n  body: SearchBranchRequestBody;\n  pathParams: SearchBranchPathParams;\n} & DataPlaneFetcherExtraProps;\n\n/**\n * Run a free text search operation across the database branch.\n */\nexport const searchBranch = (variables: SearchBranchVariables, signal?: AbortSignal) =>\n  dataPlaneFetch<Responses.SearchResponse, SearchBranchError, SearchBranchRequestBody, {}, {}, SearchBranchPathParams>({\n    url: '/db/{dbBranchName}/search',\n    method: 'post',\n    ...variables,\n    signal\n  });\n\nexport type SearchTablePathParams = {\n  /**\n   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.\n   */\n  dbBranchName: Schemas.DBBranchName;\n  /**\n   * The Table name\n   */\n  tableName: Schemas.TableName;\n  workspace: string;\n  region: string;\n};\n\nexport type SearchTableError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type SearchTableRequestBody = {\n  /**\n   * The query string.\n   *\n   * @minLength 1\n   */\n  query: string;\n  fuzziness?: Schemas.FuzzinessExpression;\n  target?: Schemas.TargetExpression;\n  prefix?: Schemas.PrefixExpression;\n  filter?: Schemas.FilterExpression;\n  highlight?: Schemas.HighlightExpression;\n  boosters?: Schemas.BoosterExpression[];\n  page?: Schemas.SearchPageConfig;\n};\n\nexport type SearchTableVariables = {\n  body: SearchTableRequestBody;\n  pathParams: SearchTablePathParams;\n} & DataPlaneFetcherExtraProps;\n\n/**\n * Run a free text search operation in a particular table.\n *\n * The endpoint accepts a `query` parameter that is used for the free text search and a set of structured filters (via the `filter` parameter) that are applied before the search. The `filter` parameter uses the same syntax as the [query endpoint](/docs/api-reference/db/db_branch_name/tables/table_name/query#filtering) with the following exceptions:\n * * filters `$contains`, `$startsWith`, `$endsWith` don't work on columns of type `text`\n * * filtering on columns of type `multiple` is currently unsupported\n */\nexport const searchTable = (variables: SearchTableVariables, signal?: AbortSignal) =>\n  dataPlaneFetch<Responses.SearchResponse, SearchTableError, SearchTableRequestBody, {}, {}, SearchTablePathParams>({\n    url: '/db/{dbBranchName}/tables/{tableName}/search',\n    method: 'post',\n    ...variables,\n    signal\n  });\n\nexport type VectorSearchTablePathParams = {\n  /**\n   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.\n   */\n  dbBranchName: Schemas.DBBranchName;\n  /**\n   * The Table name\n   */\n  tableName: Schemas.TableName;\n  workspace: string;\n  region: string;\n};\n\nexport type VectorSearchTableError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type VectorSearchTableRequestBody = {\n  /**\n   * The vector to search for similarities. Must have the same dimension as\n   * the vector column used.\n   */\n  queryVector: number[];\n  /**\n   * The vector column in which to search. It must be of type `vector`.\n   */\n  column: string;\n  /**\n   * The function used to measure the distance between two points. Can be one of:\n   * `cosineSimilarity`, `l1`, `l2`. The default is `cosineSimilarity`.\n   *\n   * @default cosineSimilarity\n   */\n  similarityFunction?: string;\n  /**\n   * Number of results to return.\n   *\n   * @default 10\n   * @maximum 100\n   * @minimum 1\n   */\n  size?: number;\n  filter?: Schemas.FilterExpression;\n};\n\nexport type VectorSearchTableVariables = {\n  body: VectorSearchTableRequestBody;\n  pathParams: VectorSearchTablePathParams;\n} & DataPlaneFetcherExtraProps;\n\n/**\n * This endpoint can be used to perform vector-based similarity searches in a table.\n * It can be used for implementing semantic search and product recommendation. To use this\n * endpoint, you need a column of type vector. The input vector must have the same\n * dimension as the vector column.\n */\nexport const vectorSearchTable = (variables: VectorSearchTableVariables, signal?: AbortSignal) =>\n  dataPlaneFetch<\n    Responses.SearchResponse,\n    VectorSearchTableError,\n    VectorSearchTableRequestBody,\n    {},\n    {},\n    VectorSearchTablePathParams\n  >({\n    url: '/db/{dbBranchName}/tables/{tableName}/vectorSearch',\n    method: 'post',\n    ...variables,\n    signal\n  });\n\nexport type AskTablePathParams = {\n  /**\n   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.\n   */\n  dbBranchName: Schemas.DBBranchName;\n  /**\n   * The Table name\n   */\n  tableName: Schemas.TableName;\n  workspace: string;\n  region: string;\n};\n\nexport type AskTableError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n  | {\n      status: 429;\n      payload: Responses.RateLimitError;\n    }\n>;\n\nexport type AskTableResponse = {\n  /**\n   * The answer to the input question\n   */\n  answer: string;\n  /**\n   * The session ID for the chat session.\n   */\n  sessionId: string;\n};\n\nexport type AskTableRequestBody = {\n  /**\n   * The question you'd like to ask.\n   *\n   * @minLength 3\n   */\n  question: string;\n  /**\n   * The type of search to use. If set to `keyword` (the default), the search can be configured by passing\n   * a `search` object with the following fields. For more details about each, see the Search endpoint documentation.\n   * All fields are optional.\n   *   * fuzziness  - typo tolerance\n   *   * target - columns to search into, and weights.\n   *   * prefix - prefix search type.\n   *   * filter - pre-filter before searching.\n   *   * boosters - control relevancy.\n   * If set to `vector`, a `vectorSearch` object must be passed, with the following parameters. For more details, see the Vector\n   * Search endpoint documentation. The `column` and `contentColumn` parameters are required.\n   *   * column - the vector column containing the embeddings.\n   *   * contentColumn - the column that contains the text from which the embeddings where computed.\n   *   * filter - pre-filter before searching.\n   *\n   * @default keyword\n   */\n  searchType?: 'keyword' | 'vector';\n  search?: {\n    fuzziness?: Schemas.FuzzinessExpression;\n    target?: Schemas.TargetExpression;\n    prefix?: Schemas.PrefixExpression;\n    filter?: Schemas.FilterExpression;\n    boosters?: Schemas.BoosterExpression[];\n  };\n  vectorSearch?: {\n    /**\n     * The column to use for vector search. It must be of type `vector`.\n     */\n    column: string;\n    /**\n     * The column containing the text for vector search. Must be of type `text`.\n     */\n    contentColumn: string;\n    filter?: Schemas.FilterExpression;\n  };\n  rules?: string[];\n};\n\nexport type AskTableVariables = {\n  body: AskTableRequestBody;\n  pathParams: AskTablePathParams;\n} & DataPlaneFetcherExtraProps;\n\n/**\n * Ask your table a question. If the `Accept` header is set to `text/event-stream`, Xata will stream the results back as SSE's.\n */\nexport const askTable = (variables: AskTableVariables, signal?: AbortSignal) =>\n  dataPlaneFetch<AskTableResponse, AskTableError, AskTableRequestBody, {}, {}, AskTablePathParams>({\n    url: '/db/{dbBranchName}/tables/{tableName}/ask',\n    method: 'post',\n    ...variables,\n    signal\n  });\n\nexport type AskTableSessionPathParams = {\n  /**\n   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.\n   */\n  dbBranchName: Schemas.DBBranchName;\n  /**\n   * The Table name\n   */\n  tableName: Schemas.TableName;\n  /**\n   * @maxLength 36\n   * @minLength 36\n   */\n  sessionId: string;\n  workspace: string;\n  region: string;\n};\n\nexport type AskTableSessionError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n  | {\n      status: 429;\n      payload: Responses.RateLimitError;\n    }\n  | {\n      status: 503;\n      payload: Responses.ServiceUnavailableError;\n    }\n>;\n\nexport type AskTableSessionResponse = {\n  /**\n   * The answer to the input question\n   */\n  answer: string;\n};\n\nexport type AskTableSessionRequestBody = {\n  /**\n   * The question you'd like to ask.\n   *\n   * @minLength 3\n   */\n  message?: string;\n};\n\nexport type AskTableSessionVariables = {\n  body?: AskTableSessionRequestBody;\n  pathParams: AskTableSessionPathParams;\n} & DataPlaneFetcherExtraProps;\n\n/**\n * Ask a follow-up question. If the `Accept` header is set to `text/event-stream`, Xata will stream the results back as SSE's.\n */\nexport const askTableSession = (variables: AskTableSessionVariables, signal?: AbortSignal) =>\n  dataPlaneFetch<\n    AskTableSessionResponse,\n    AskTableSessionError,\n    AskTableSessionRequestBody,\n    {},\n    {},\n    AskTableSessionPathParams\n  >({\n    url: '/db/{dbBranchName}/tables/{tableName}/ask/{sessionId}',\n    method: 'post',\n    ...variables,\n    signal\n  });\n\nexport type SummarizeTablePathParams = {\n  /**\n   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.\n   */\n  dbBranchName: Schemas.DBBranchName;\n  /**\n   * The Table name\n   */\n  tableName: Schemas.TableName;\n  workspace: string;\n  region: string;\n};\n\nexport type SummarizeTableError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type SummarizeTableRequestBody = {\n  filter?: Schemas.FilterExpression;\n  columns?: Schemas.ColumnsProjection;\n  summaries?: Schemas.SummaryExpressionList;\n  sort?: Schemas.SortExpression;\n  summariesFilter?: Schemas.FilterExpression;\n  /**\n   * The consistency level for this request.\n   *\n   * @default strong\n   */\n  consistency?: 'strong' | 'eventual';\n  page?: {\n    /**\n     * The number of records returned by summarize. If the amount of data you have exceeds this, or you have\n     * more complex reporting requirements, we recommend that you use the aggregate endpoint instead.\n     *\n     * @default 20\n     * @maximum 1000\n     * @minimum 1\n     */\n    size?: number;\n  };\n};\n\nexport type SummarizeTableVariables = {\n  body?: SummarizeTableRequestBody;\n  pathParams: SummarizeTablePathParams;\n} & DataPlaneFetcherExtraProps;\n\n/**\n * This endpoint allows you to (optionally) define groups, and then to run\n * calculations on the values in each group. This is most helpful when\n * you'd like to understand the data you have in your database.\n *\n * A group is a combination of unique values. If you create a group for\n * `sold_by`, `product_name`, we will return one row for every combination\n * of `sold_by` and `product_name` you have in your database. When you\n * want to calculate statistics, you define these groups and ask Xata to\n * calculate data on each group.\n *\n * **Some questions you can ask of your data:**\n *\n * How many records do I have in this table?\n * - Set `columns: []` as we we want data from the entire table, so we ask\n * for no groups.\n * - Set `summaries: {\"total\": {\"count\": \"*\"}}` in order to see the count\n * of all records. We use `count: *` here we'd like to know the total\n * amount of rows; ignoring whether they are `null` or not.\n *\n * What are the top total sales for each product in July 2022 and sold\n * more than 10 units?\n * - Set `filter: {soldAt: {\n *   \"$ge\": \"2022-07-01T00:00:00.000Z\",\n *   \"$lt\": \"2022-08-01T00:00:00.000Z\"}\n * }`\n * in order to limit the result set to sales recorded in July 2022.\n * - Set `columns: [product_name]` as we'd like to run calculations on\n * each unique product name in our table. Setting `columns` like this will\n * produce one row per unique product name.\n * - Set `summaries: {\"total_sales\": {\"count\": \"product_name\"}}` as we'd\n * like to create a field called \"total_sales\" for each group. This field\n * will count all rows in each group with non-null product names.\n * - Set `sort: [{\"total_sales\": \"desc\"}]` in order to bring the rows with\n * the highest total_sales field to the top.\n * - Set `summariesFilter: {\"total_sales\": {\"$ge\": 10}}` to only send back data\n * with greater than or equal to 10 units.\n *\n * `columns`: tells Xata how to create each group. If you add `product_id`\n * we will create a new group for every unique `product_id`.\n *\n * `summaries`: tells Xata which calculations to run on each group. Xata\n * currently supports count, min, max, sum, average.\n *\n * `sort`: tells Xata in which order you'd like to see results. You may\n * sort by fields specified in `columns` as well as the summary names\n * defined in `summaries`.\n *\n * note: Sorting on summarized values can be slower on very large tables;\n * this will impact your rate limit significantly more than other queries.\n * Try use `filter` to reduce the amount of data being processed in order\n * to reduce impact on your limits.\n *\n * `summariesFilter`: tells Xata how to filter the results of a summary.\n * It has the same syntax as `filter`, however, by using `summariesFilter`\n * you may also filter on the results of a query.\n *\n * note: This is a much slower to use than `filter`. We recommend using\n * `filter` wherever possible and `summariesFilter` when it's not\n * possible to use `filter`.\n *\n * `page.size`: tells Xata how many records to return. If unspecified, Xata\n * will return the default size.\n */\nexport const summarizeTable = (variables: SummarizeTableVariables, signal?: AbortSignal) =>\n  dataPlaneFetch<\n    Responses.SummarizeResponse,\n    SummarizeTableError,\n    SummarizeTableRequestBody,\n    {},\n    {},\n    SummarizeTablePathParams\n  >({\n    url: '/db/{dbBranchName}/tables/{tableName}/summarize',\n    method: 'post',\n    ...variables,\n    signal\n  });\n\nexport type AggregateTablePathParams = {\n  /**\n   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.\n   */\n  dbBranchName: Schemas.DBBranchName;\n  /**\n   * The Table name\n   */\n  tableName: Schemas.TableName;\n  workspace: string;\n  region: string;\n};\n\nexport type AggregateTableError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type AggregateTableRequestBody = {\n  filter?: Schemas.FilterExpression;\n  aggs?: Schemas.AggExpressionMap;\n};\n\nexport type AggregateTableVariables = {\n  body?: AggregateTableRequestBody;\n  pathParams: AggregateTablePathParams;\n} & DataPlaneFetcherExtraProps;\n\n/**\n * This endpoint allows you to run aggregations (analytics) on the data from one table.\n * While the summary endpoint is served from a transactional store and the results are strongly\n * consistent, the aggregate endpoint is served from our columnar store and the results are\n * only eventually consistent. On the other hand, the aggregate endpoint uses a\n * store that is more appropriate for analytics, makes use of approximation algorithms\n * (e.g for cardinality), and is generally faster and can do more complex aggregations.\n *\n * For usage, see the [Aggregation documentation](https://xata.io/docs/sdk/aggregate).\n */\nexport const aggregateTable = (variables: AggregateTableVariables, signal?: AbortSignal) =>\n  dataPlaneFetch<\n    Responses.AggResponse,\n    AggregateTableError,\n    AggregateTableRequestBody,\n    {},\n    {},\n    AggregateTablePathParams\n  >({\n    url: '/db/{dbBranchName}/tables/{tableName}/aggregate',\n    method: 'post',\n    ...variables,\n    signal\n  });\n\nexport type FileAccessPathParams = {\n  /**\n   * The File Access Identifier\n   */\n  fileId: Schemas.FileAccessID;\n  workspace: string;\n  region: string;\n};\n\nexport type FileAccessQueryParams = {\n  /**\n   * File access signature\n   */\n  verify?: Schemas.FileSignature;\n};\n\nexport type FileAccessError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type FileAccessVariables = {\n  pathParams: FileAccessPathParams;\n  queryParams?: FileAccessQueryParams;\n} & DataPlaneFetcherExtraProps;\n\n/**\n * Retrieve file content by access id\n */\nexport const fileAccess = (variables: FileAccessVariables, signal?: AbortSignal) =>\n  dataPlaneFetch<Blob, FileAccessError, undefined, {}, FileAccessQueryParams, FileAccessPathParams>({\n    url: '/file/{fileId}',\n    method: 'get',\n    ...variables,\n    signal\n  });\n\nexport type FileUploadPathParams = {\n  /**\n   * The File Access Identifier\n   */\n  fileId: Schemas.FileAccessID;\n  workspace: string;\n  region: string;\n};\n\nexport type FileUploadQueryParams = {\n  /**\n   * File access signature\n   */\n  verify?: Schemas.FileSignature;\n};\n\nexport type FileUploadError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type FileUploadVariables = {\n  body?: Blob;\n  pathParams: FileUploadPathParams;\n  queryParams?: FileUploadQueryParams;\n} & DataPlaneFetcherExtraProps;\n\n/**\n * Upload file using an upload url\n */\nexport const fileUpload = (variables: FileUploadVariables, signal?: AbortSignal) =>\n  dataPlaneFetch<Responses.PutFileResponse, FileUploadError, Blob, {}, FileUploadQueryParams, FileUploadPathParams>({\n    url: '/file/{fileId}',\n    method: 'put',\n    ...variables,\n    signal\n  });\n\nexport type SqlQueryPathParams = {\n  /**\n   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.\n   */\n  dbBranchName: Schemas.DBBranchName;\n  workspace: string;\n  region: string;\n};\n\nexport type SqlQueryError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n  | {\n      status: 503;\n      payload: Responses.ServiceUnavailableError;\n    }\n>;\n\nexport type SqlQueryRequestBody = Schemas.PreparedStatement & {\n  consistency?: Schemas.SQLConsistency;\n  responseType?: Schemas.SQLResponseType;\n};\n\nexport type SqlQueryVariables = {\n  body: SqlQueryRequestBody;\n  pathParams: SqlQueryPathParams;\n} & DataPlaneFetcherExtraProps;\n\n/**\n * Run an SQL query across the database branch.\n */\nexport const sqlQuery = (variables: SqlQueryVariables, signal?: AbortSignal) =>\n  dataPlaneFetch<Responses.SQLResponse, SqlQueryError, SqlQueryRequestBody, {}, {}, SqlQueryPathParams>({\n    url: '/db/{dbBranchName}/sql',\n    method: 'post',\n    ...variables,\n    signal\n  });\n\nexport type SqlBatchQueryPathParams = {\n  /**\n   * The DBBranchName matches the pattern `{db_name}:{branch_name}`.\n   */\n  dbBranchName: Schemas.DBBranchName;\n  workspace: string;\n  region: string;\n};\n\nexport type SqlBatchQueryError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n  | {\n      status: 503;\n      payload: Responses.ServiceUnavailableError;\n    }\n>;\n\nexport type SqlBatchQueryRequestBody = {\n  /**\n   * The SQL statements.\n   *\n   * @x-go-type []sqlproxy.PreparedStatement\n   */\n  statements: Schemas.PreparedStatement[];\n  consistency?: Schemas.SQLConsistency;\n  responseType?: Schemas.SQLResponseType;\n};\n\nexport type SqlBatchQueryVariables = {\n  body: SqlBatchQueryRequestBody;\n  pathParams: SqlBatchQueryPathParams;\n} & DataPlaneFetcherExtraProps;\n\n/**\n * Run multiple SQL queries across the database branch.\n */\nexport const sqlBatchQuery = (variables: SqlBatchQueryVariables, signal?: AbortSignal) =>\n  dataPlaneFetch<\n    Responses.SQLBatchResponse,\n    SqlBatchQueryError,\n    SqlBatchQueryRequestBody,\n    {},\n    {},\n    SqlBatchQueryPathParams\n  >({\n    url: '/db/{dbBranchName}/sql/batch',\n    method: 'post',\n    ...variables,\n    signal\n  });\n\nexport const operationsByTag = {\n  tasks: { getTasks, getTaskStatus },\n  cluster: {\n    listClusterBranches,\n    listClusterExtensions,\n    installClusterExtension,\n    dropClusterExtension,\n    getClusterMetrics\n  },\n  migrations: {\n    applyMigration,\n    startMigration,\n    completeMigration,\n    rollbackMigration,\n    adaptTable,\n    adaptAllTables,\n    getBranchMigrationJobStatus,\n    getMigrationJobs,\n    getMigrationJobStatus,\n    getMigrationHistory,\n    getSchema,\n    getSchemas,\n    getBranchMigrationHistory,\n    getBranchMigrationPlan,\n    executeBranchMigrationPlan,\n    getBranchSchemaHistory,\n    compareBranchWithUserSchema,\n    compareBranchSchemas,\n    updateBranchSchema,\n    previewBranchSchemaEdit,\n    applyBranchSchemaEdit,\n    pushBranchMigrations\n  },\n  branch: {\n    getBranchList,\n    createBranchAsync,\n    getBranchDetails,\n    createBranch,\n    deleteBranch,\n    copyBranch,\n    getBranchMoveStatus,\n    moveBranch,\n    updateBranchMetadata,\n    getBranchMetadata,\n    getBranchStats,\n    getGitBranchesMapping,\n    addGitBranchesEntry,\n    removeGitBranchesEntry,\n    resolveBranch\n  },\n  database: { getDatabaseSettings, updateDatabaseSettings },\n  migrationRequests: {\n    queryMigrationRequests,\n    createMigrationRequest,\n    getMigrationRequest,\n    updateMigrationRequest,\n    listMigrationRequestsCommits,\n    compareMigrationRequest,\n    getMigrationRequestIsMerged,\n    mergeMigrationRequest\n  },\n  table: {\n    createTable,\n    deleteTable,\n    updateTable,\n    getTableSchema,\n    setTableSchema,\n    getTableColumns,\n    addTableColumn,\n    getColumn,\n    updateColumn,\n    deleteColumn\n  },\n  records: {\n    branchTransaction,\n    insertRecord,\n    getRecord,\n    insertRecordWithID,\n    updateRecordWithID,\n    upsertRecordWithID,\n    deleteRecord,\n    bulkInsertTableRecords\n  },\n  files: {\n    getFileItem,\n    putFileItem,\n    deleteFileItem,\n    getFile,\n    putFile,\n    deleteFile,\n    fileAccess,\n    fileUpload\n  },\n  searchAndFilter: {\n    queryTable,\n    searchBranch,\n    searchTable,\n    vectorSearchTable,\n    askTable,\n    askTableSession,\n    summarizeTable,\n    aggregateTable\n  },\n  sql: { sqlQuery, sqlBatchQuery }\n};\n","import { TraceFunction } from '../schema/tracing';\nimport { FetchImpl } from '../util/fetch';\nimport { PossibleErrors } from './errors';\nimport { fetch, WorkspaceApiUrlBuilder } from './fetcher';\n\nexport type ControlPlaneFetcherExtraProps = {\n  apiUrl: string;\n  workspacesApiUrl: string | WorkspaceApiUrlBuilder;\n  fetch: FetchImpl;\n  apiKey: string;\n  trace: TraceFunction;\n  signal?: AbortSignal;\n  clientID?: string;\n  sessionID?: string;\n  clientName?: string;\n  xataAgentExtra?: Record<string, string>;\n};\n\nexport type ErrorWrapper<TError> = TError | { status: 'unknown'; payload: string };\n\nexport type ControlPlaneFetcherOptions<TBody, THeaders, TQueryParams, TPathParams> = {\n  url: string;\n  method: string;\n  body?: TBody;\n  headers?: THeaders;\n  queryParams?: TQueryParams;\n  pathParams?: TPathParams;\n  signal?: AbortSignal;\n} & ControlPlaneFetcherExtraProps;\n\nexport const controlPlaneFetch = async <\n  TData,\n  TError extends ErrorWrapper<{ status: unknown; payload: PossibleErrors }>,\n  TBody extends Record<string, unknown> | undefined | null,\n  THeaders extends Record<string, unknown>,\n  TQueryParams extends Record<string, unknown>,\n  TPathParams extends Partial<Record<string, string | number>>\n>(\n  options: ControlPlaneFetcherOptions<TBody, THeaders, TQueryParams, TPathParams>\n): Promise<TData> =>\n  fetch<TData, TError, TBody, THeaders, TQueryParams, TPathParams>({ ...options, endpoint: 'controlPlane' });\n","/**\n * Generated by @openapi-codegen\n *\n * @version 1.0\n */\nimport type * as Fetcher from './controlPlaneFetcher';\nimport { controlPlaneFetch, ControlPlaneFetcherExtraProps } from './controlPlaneFetcher';\nimport type * as Schemas from './controlPlaneSchemas';\nimport type * as Responses from './controlPlaneResponses';\n\nexport type GetAuthorizationCodeQueryParams = {\n  clientID: string;\n  responseType: Schemas.OAuthResponseType;\n  redirectUri?: string;\n  scopes?: Schemas.OAuthScope[];\n  state?: string;\n};\n\nexport type GetAuthorizationCodeError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n  | {\n      status: 409;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type GetAuthorizationCodeVariables = {\n  queryParams: GetAuthorizationCodeQueryParams;\n} & ControlPlaneFetcherExtraProps;\n\n/**\n * Creates, stores and returns an authorization code to be used by a third party app. Supporting use of GET is required by OAuth2 spec\n */\nexport const getAuthorizationCode = (variables: GetAuthorizationCodeVariables, signal?: AbortSignal) =>\n  controlPlaneFetch<\n    Schemas.AuthorizationCodeResponse,\n    GetAuthorizationCodeError,\n    undefined,\n    {},\n    GetAuthorizationCodeQueryParams,\n    {}\n  >({ url: '/oauth/authorize', method: 'get', ...variables, signal });\n\nexport type GrantAuthorizationCodeError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n  | {\n      status: 409;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type GrantAuthorizationCodeVariables = {\n  body: Schemas.AuthorizationCodeRequest;\n} & ControlPlaneFetcherExtraProps;\n\n/**\n * Creates, stores and returns an authorization code to be used by a third party app\n */\nexport const grantAuthorizationCode = (variables: GrantAuthorizationCodeVariables, signal?: AbortSignal) =>\n  controlPlaneFetch<\n    Schemas.AuthorizationCodeResponse,\n    GrantAuthorizationCodeError,\n    Schemas.AuthorizationCodeRequest,\n    {},\n    {},\n    {}\n  >({ url: '/oauth/authorize', method: 'post', ...variables, signal });\n\nexport type GetUserError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type GetUserVariables = ControlPlaneFetcherExtraProps;\n\n/**\n * Return details of the user making the request\n */\nexport const getUser = (variables: GetUserVariables, signal?: AbortSignal) =>\n  controlPlaneFetch<Schemas.UserWithID, GetUserError, undefined, {}, {}, {}>({\n    url: '/user',\n    method: 'get',\n    ...variables,\n    signal\n  });\n\nexport type UpdateUserError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type UpdateUserVariables = {\n  body: Schemas.User;\n} & ControlPlaneFetcherExtraProps;\n\n/**\n * Update user info\n */\nexport const updateUser = (variables: UpdateUserVariables, signal?: AbortSignal) =>\n  controlPlaneFetch<Schemas.UserWithID, UpdateUserError, Schemas.User, {}, {}, {}>({\n    url: '/user',\n    method: 'put',\n    ...variables,\n    signal\n  });\n\nexport type DeleteUserError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type DeleteUserVariables = ControlPlaneFetcherExtraProps;\n\n/**\n * Delete the user making the request\n */\nexport const deleteUser = (variables: DeleteUserVariables, signal?: AbortSignal) =>\n  controlPlaneFetch<undefined, DeleteUserError, undefined, {}, {}, {}>({\n    url: '/user',\n    method: 'delete',\n    ...variables,\n    signal\n  });\n\nexport type GetUserAPIKeysError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type GetUserAPIKeysResponse = {\n  keys: {\n    name: string;\n    createdAt: Schemas.DateTime;\n  }[];\n};\n\nexport type GetUserAPIKeysVariables = ControlPlaneFetcherExtraProps;\n\n/**\n * Retrieve a list of existing user API keys\n */\nexport const getUserAPIKeys = (variables: GetUserAPIKeysVariables, signal?: AbortSignal) =>\n  controlPlaneFetch<GetUserAPIKeysResponse, GetUserAPIKeysError, undefined, {}, {}, {}>({\n    url: '/user/keys',\n    method: 'get',\n    ...variables,\n    signal\n  });\n\nexport type CreateUserAPIKeyPathParams = {\n  /**\n   * API Key name\n   */\n  keyName: Schemas.APIKeyName;\n};\n\nexport type CreateUserAPIKeyError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type CreateUserAPIKeyResponse = {\n  name: string;\n  key: string;\n  createdAt: Schemas.DateTime;\n};\n\nexport type CreateUserAPIKeyVariables = {\n  pathParams: CreateUserAPIKeyPathParams;\n} & ControlPlaneFetcherExtraProps;\n\n/**\n * Create and return new API key\n */\nexport const createUserAPIKey = (variables: CreateUserAPIKeyVariables, signal?: AbortSignal) =>\n  controlPlaneFetch<CreateUserAPIKeyResponse, CreateUserAPIKeyError, undefined, {}, {}, CreateUserAPIKeyPathParams>({\n    url: '/user/keys/{keyName}',\n    method: 'post',\n    ...variables,\n    signal\n  });\n\nexport type DeleteUserAPIKeyPathParams = {\n  /**\n   * API Key name\n   */\n  keyName: Schemas.APIKeyName;\n};\n\nexport type DeleteUserAPIKeyError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type DeleteUserAPIKeyVariables = {\n  pathParams: DeleteUserAPIKeyPathParams;\n} & ControlPlaneFetcherExtraProps;\n\n/**\n * Delete an existing API key\n */\nexport const deleteUserAPIKey = (variables: DeleteUserAPIKeyVariables, signal?: AbortSignal) =>\n  controlPlaneFetch<undefined, DeleteUserAPIKeyError, undefined, {}, {}, DeleteUserAPIKeyPathParams>({\n    url: '/user/keys/{keyName}',\n    method: 'delete',\n    ...variables,\n    signal\n  });\n\nexport type GetUserOAuthClientsError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type GetUserOAuthClientsResponse = {\n  clients?: Schemas.OAuthClientPublicDetails[];\n};\n\nexport type GetUserOAuthClientsVariables = ControlPlaneFetcherExtraProps;\n\n/**\n * Retrieve the list of OAuth Clients that a user has authorized\n */\nexport const getUserOAuthClients = (variables: GetUserOAuthClientsVariables, signal?: AbortSignal) =>\n  controlPlaneFetch<GetUserOAuthClientsResponse, GetUserOAuthClientsError, undefined, {}, {}, {}>({\n    url: '/user/oauth/clients',\n    method: 'get',\n    ...variables,\n    signal\n  });\n\nexport type DeleteUserOAuthClientPathParams = {\n  clientId: Schemas.OAuthClientID;\n};\n\nexport type DeleteUserOAuthClientError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type DeleteUserOAuthClientVariables = {\n  pathParams: DeleteUserOAuthClientPathParams;\n} & ControlPlaneFetcherExtraProps;\n\n/**\n * Delete the oauth client for the user and revoke all access\n */\nexport const deleteUserOAuthClient = (variables: DeleteUserOAuthClientVariables, signal?: AbortSignal) =>\n  controlPlaneFetch<undefined, DeleteUserOAuthClientError, undefined, {}, {}, DeleteUserOAuthClientPathParams>({\n    url: '/user/oauth/clients/{clientId}',\n    method: 'delete',\n    ...variables,\n    signal\n  });\n\nexport type GetUserOAuthAccessTokensError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type GetUserOAuthAccessTokensResponse = {\n  accessTokens: Schemas.OAuthAccessToken[];\n};\n\nexport type GetUserOAuthAccessTokensVariables = ControlPlaneFetcherExtraProps;\n\n/**\n * Retrieve the list of valid OAuth Access Tokens on the current user's account\n */\nexport const getUserOAuthAccessTokens = (variables: GetUserOAuthAccessTokensVariables, signal?: AbortSignal) =>\n  controlPlaneFetch<GetUserOAuthAccessTokensResponse, GetUserOAuthAccessTokensError, undefined, {}, {}, {}>({\n    url: '/user/oauth/tokens',\n    method: 'get',\n    ...variables,\n    signal\n  });\n\nexport type DeleteOAuthAccessTokenPathParams = {\n  token: Schemas.AccessToken;\n};\n\nexport type DeleteOAuthAccessTokenError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n  | {\n      status: 409;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type DeleteOAuthAccessTokenVariables = {\n  pathParams: DeleteOAuthAccessTokenPathParams;\n} & ControlPlaneFetcherExtraProps;\n\n/**\n * Expires the access token for a third party app\n */\nexport const deleteOAuthAccessToken = (variables: DeleteOAuthAccessTokenVariables, signal?: AbortSignal) =>\n  controlPlaneFetch<undefined, DeleteOAuthAccessTokenError, undefined, {}, {}, DeleteOAuthAccessTokenPathParams>({\n    url: '/user/oauth/tokens/{token}',\n    method: 'delete',\n    ...variables,\n    signal\n  });\n\nexport type UpdateOAuthAccessTokenPathParams = {\n  token: Schemas.AccessToken;\n};\n\nexport type UpdateOAuthAccessTokenError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n  | {\n      status: 409;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type UpdateOAuthAccessTokenRequestBody = {\n  /**\n   * expiration time of the token as a unix timestamp\n   */\n  expires: number;\n};\n\nexport type UpdateOAuthAccessTokenVariables = {\n  body: UpdateOAuthAccessTokenRequestBody;\n  pathParams: UpdateOAuthAccessTokenPathParams;\n} & ControlPlaneFetcherExtraProps;\n\n/**\n * Updates partially the access token for a third party app\n */\nexport const updateOAuthAccessToken = (variables: UpdateOAuthAccessTokenVariables, signal?: AbortSignal) =>\n  controlPlaneFetch<\n    Schemas.OAuthAccessToken,\n    UpdateOAuthAccessTokenError,\n    UpdateOAuthAccessTokenRequestBody,\n    {},\n    {},\n    UpdateOAuthAccessTokenPathParams\n  >({\n    url: '/user/oauth/tokens/{token}',\n    method: 'patch',\n    ...variables,\n    signal\n  });\n\nexport type GetWorkspacesListError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type GetWorkspacesListResponse = {\n  workspaces: {\n    id: Schemas.WorkspaceID;\n    unique_id: string;\n    name: string;\n    slug: string;\n    role: Schemas.Role;\n    plan: Schemas.WorkspacePlan;\n  }[];\n};\n\nexport type GetWorkspacesListVariables = ControlPlaneFetcherExtraProps;\n\n/**\n * Retrieve the list of workspaces the user belongs to\n */\nexport const getWorkspacesList = (variables: GetWorkspacesListVariables, signal?: AbortSignal) =>\n  controlPlaneFetch<GetWorkspacesListResponse, GetWorkspacesListError, undefined, {}, {}, {}>({\n    url: '/workspaces',\n    method: 'get',\n    ...variables,\n    signal\n  });\n\nexport type CreateWorkspaceError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type CreateWorkspaceVariables = {\n  body: Schemas.WorkspaceMeta;\n} & ControlPlaneFetcherExtraProps;\n\n/**\n * Creates a new workspace with the user requesting it as its single owner.\n */\nexport const createWorkspace = (variables: CreateWorkspaceVariables, signal?: AbortSignal) =>\n  controlPlaneFetch<Schemas.Workspace, CreateWorkspaceError, Schemas.WorkspaceMeta, {}, {}, {}>({\n    url: '/workspaces',\n    method: 'post',\n    ...variables,\n    signal\n  });\n\nexport type GetWorkspacePathParams = {\n  /**\n   * Workspace ID\n   */\n  workspaceId: Schemas.WorkspaceID;\n};\n\nexport type GetWorkspaceError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 403;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type GetWorkspaceVariables = {\n  pathParams: GetWorkspacePathParams;\n} & ControlPlaneFetcherExtraProps;\n\n/**\n * Retrieve workspace info from a workspace ID\n */\nexport const getWorkspace = (variables: GetWorkspaceVariables, signal?: AbortSignal) =>\n  controlPlaneFetch<Schemas.Workspace, GetWorkspaceError, undefined, {}, {}, GetWorkspacePathParams>({\n    url: '/workspaces/{workspaceId}',\n    method: 'get',\n    ...variables,\n    signal\n  });\n\nexport type UpdateWorkspacePathParams = {\n  /**\n   * Workspace ID\n   */\n  workspaceId: Schemas.WorkspaceID;\n};\n\nexport type UpdateWorkspaceError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 403;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type UpdateWorkspaceVariables = {\n  body: Schemas.WorkspaceMeta;\n  pathParams: UpdateWorkspacePathParams;\n} & ControlPlaneFetcherExtraProps;\n\n/**\n * Update workspace info\n */\nexport const updateWorkspace = (variables: UpdateWorkspaceVariables, signal?: AbortSignal) =>\n  controlPlaneFetch<Schemas.Workspace, UpdateWorkspaceError, Schemas.WorkspaceMeta, {}, {}, UpdateWorkspacePathParams>({\n    url: '/workspaces/{workspaceId}',\n    method: 'put',\n    ...variables,\n    signal\n  });\n\nexport type DeleteWorkspacePathParams = {\n  /**\n   * Workspace ID\n   */\n  workspaceId: Schemas.WorkspaceID;\n};\n\nexport type DeleteWorkspaceError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 403;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type DeleteWorkspaceVariables = {\n  pathParams: DeleteWorkspacePathParams;\n} & ControlPlaneFetcherExtraProps;\n\n/**\n * Delete the workspace with the provided ID\n */\nexport const deleteWorkspace = (variables: DeleteWorkspaceVariables, signal?: AbortSignal) =>\n  controlPlaneFetch<undefined, DeleteWorkspaceError, undefined, {}, {}, DeleteWorkspacePathParams>({\n    url: '/workspaces/{workspaceId}',\n    method: 'delete',\n    ...variables,\n    signal\n  });\n\nexport type GetWorkspaceSettingsPathParams = {\n  /**\n   * Workspace ID\n   */\n  workspaceId: Schemas.WorkspaceID;\n};\n\nexport type GetWorkspaceSettingsError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 403;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type GetWorkspaceSettingsVariables = {\n  pathParams: GetWorkspaceSettingsPathParams;\n} & ControlPlaneFetcherExtraProps;\n\n/**\n * Retrieve workspace settings from a workspace ID\n */\nexport const getWorkspaceSettings = (variables: GetWorkspaceSettingsVariables, signal?: AbortSignal) =>\n  controlPlaneFetch<\n    Schemas.WorkspaceSettings,\n    GetWorkspaceSettingsError,\n    undefined,\n    {},\n    {},\n    GetWorkspaceSettingsPathParams\n  >({\n    url: '/workspaces/{workspaceId}/settings',\n    method: 'get',\n    ...variables,\n    signal\n  });\n\nexport type UpdateWorkspaceSettingsPathParams = {\n  /**\n   * Workspace ID\n   */\n  workspaceId: Schemas.WorkspaceID;\n};\n\nexport type UpdateWorkspaceSettingsError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 403;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type UpdateWorkspaceSettingsVariables = {\n  body?: Record<string, any>;\n  pathParams: UpdateWorkspaceSettingsPathParams;\n} & ControlPlaneFetcherExtraProps;\n\n/**\n * Update workspace settings\n */\nexport const updateWorkspaceSettings = (variables: UpdateWorkspaceSettingsVariables, signal?: AbortSignal) =>\n  controlPlaneFetch<\n    Schemas.WorkspaceSettings,\n    UpdateWorkspaceSettingsError,\n    Record<string, any>,\n    {},\n    {},\n    UpdateWorkspaceSettingsPathParams\n  >({\n    url: '/workspaces/{workspaceId}/settings',\n    method: 'patch',\n    ...variables,\n    signal\n  });\n\nexport type GetWorkspaceMembersListPathParams = {\n  /**\n   * Workspace ID\n   */\n  workspaceId: Schemas.WorkspaceID;\n};\n\nexport type GetWorkspaceMembersListError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 403;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type GetWorkspaceMembersListVariables = {\n  pathParams: GetWorkspaceMembersListPathParams;\n} & ControlPlaneFetcherExtraProps;\n\n/**\n * Retrieve the list of members of the given workspace\n */\nexport const getWorkspaceMembersList = (variables: GetWorkspaceMembersListVariables, signal?: AbortSignal) =>\n  controlPlaneFetch<\n    Schemas.WorkspaceMembers,\n    GetWorkspaceMembersListError,\n    undefined,\n    {},\n    {},\n    GetWorkspaceMembersListPathParams\n  >({\n    url: '/workspaces/{workspaceId}/members',\n    method: 'get',\n    ...variables,\n    signal\n  });\n\nexport type UpdateWorkspaceMemberRolePathParams = {\n  /**\n   * Workspace ID\n   */\n  workspaceId: Schemas.WorkspaceID;\n  /**\n   * UserID\n   */\n  userId: Schemas.UserID;\n};\n\nexport type UpdateWorkspaceMemberRoleError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 403;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type UpdateWorkspaceMemberRoleRequestBody = {\n  role: Schemas.Role;\n};\n\nexport type UpdateWorkspaceMemberRoleVariables = {\n  body: UpdateWorkspaceMemberRoleRequestBody;\n  pathParams: UpdateWorkspaceMemberRolePathParams;\n} & ControlPlaneFetcherExtraProps;\n\n/**\n * Update a workspace member role. Workspaces must always have at least one owner, so this operation will fail if trying to remove owner role from the last owner in the workspace.\n */\nexport const updateWorkspaceMemberRole = (variables: UpdateWorkspaceMemberRoleVariables, signal?: AbortSignal) =>\n  controlPlaneFetch<\n    undefined,\n    UpdateWorkspaceMemberRoleError,\n    UpdateWorkspaceMemberRoleRequestBody,\n    {},\n    {},\n    UpdateWorkspaceMemberRolePathParams\n  >({\n    url: '/workspaces/{workspaceId}/members/{userId}',\n    method: 'put',\n    ...variables,\n    signal\n  });\n\nexport type RemoveWorkspaceMemberPathParams = {\n  /**\n   * Workspace ID\n   */\n  workspaceId: Schemas.WorkspaceID;\n  /**\n   * UserID\n   */\n  userId: Schemas.UserID;\n};\n\nexport type RemoveWorkspaceMemberError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 403;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type RemoveWorkspaceMemberVariables = {\n  pathParams: RemoveWorkspaceMemberPathParams;\n} & ControlPlaneFetcherExtraProps;\n\n/**\n * Remove the member from the workspace\n */\nexport const removeWorkspaceMember = (variables: RemoveWorkspaceMemberVariables, signal?: AbortSignal) =>\n  controlPlaneFetch<undefined, RemoveWorkspaceMemberError, undefined, {}, {}, RemoveWorkspaceMemberPathParams>({\n    url: '/workspaces/{workspaceId}/members/{userId}',\n    method: 'delete',\n    ...variables,\n    signal\n  });\n\nexport type InviteWorkspaceMemberPathParams = {\n  /**\n   * Workspace ID\n   */\n  workspaceId: Schemas.WorkspaceID;\n};\n\nexport type InviteWorkspaceMemberError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 403;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n  | {\n      status: 409;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type InviteWorkspaceMemberRequestBody = {\n  /**\n   * @format email\n   */\n  email: string;\n  role: Schemas.Role;\n};\n\nexport type InviteWorkspaceMemberVariables = {\n  body: InviteWorkspaceMemberRequestBody;\n  pathParams: InviteWorkspaceMemberPathParams;\n} & ControlPlaneFetcherExtraProps;\n\n/**\n * Invite some user to join the workspace with the given role\n */\nexport const inviteWorkspaceMember = (variables: InviteWorkspaceMemberVariables, signal?: AbortSignal) =>\n  controlPlaneFetch<\n    Schemas.WorkspaceInvite,\n    InviteWorkspaceMemberError,\n    InviteWorkspaceMemberRequestBody,\n    {},\n    {},\n    InviteWorkspaceMemberPathParams\n  >({\n    url: '/workspaces/{workspaceId}/invites',\n    method: 'post',\n    ...variables,\n    signal\n  });\n\nexport type UpdateWorkspaceMemberInvitePathParams = {\n  /**\n   * Workspace ID\n   */\n  workspaceId: Schemas.WorkspaceID;\n  /**\n   * Invite identifier\n   */\n  inviteId: Schemas.InviteID;\n};\n\nexport type UpdateWorkspaceMemberInviteError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 403;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n  | {\n      status: 422;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type UpdateWorkspaceMemberInviteRequestBody = {\n  role: Schemas.Role;\n};\n\nexport type UpdateWorkspaceMemberInviteVariables = {\n  body: UpdateWorkspaceMemberInviteRequestBody;\n  pathParams: UpdateWorkspaceMemberInvitePathParams;\n} & ControlPlaneFetcherExtraProps;\n\n/**\n * This operation provides a way to update an existing invite. Updates are performed in-place; they do not change the invite link, the expiry time, nor do they re-notify the recipient of the invite.\n */\nexport const updateWorkspaceMemberInvite = (variables: UpdateWorkspaceMemberInviteVariables, signal?: AbortSignal) =>\n  controlPlaneFetch<\n    Schemas.WorkspaceInvite,\n    UpdateWorkspaceMemberInviteError,\n    UpdateWorkspaceMemberInviteRequestBody,\n    {},\n    {},\n    UpdateWorkspaceMemberInvitePathParams\n  >({\n    url: '/workspaces/{workspaceId}/invites/{inviteId}',\n    method: 'patch',\n    ...variables,\n    signal\n  });\n\nexport type CancelWorkspaceMemberInvitePathParams = {\n  /**\n   * Workspace ID\n   */\n  workspaceId: Schemas.WorkspaceID;\n  /**\n   * Invite identifier\n   */\n  inviteId: Schemas.InviteID;\n};\n\nexport type CancelWorkspaceMemberInviteError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 403;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type CancelWorkspaceMemberInviteVariables = {\n  pathParams: CancelWorkspaceMemberInvitePathParams;\n} & ControlPlaneFetcherExtraProps;\n\n/**\n * This operation provides a way to cancel invites by deleting them. Already accepted invites cannot be deleted.\n */\nexport const cancelWorkspaceMemberInvite = (variables: CancelWorkspaceMemberInviteVariables, signal?: AbortSignal) =>\n  controlPlaneFetch<\n    undefined,\n    CancelWorkspaceMemberInviteError,\n    undefined,\n    {},\n    {},\n    CancelWorkspaceMemberInvitePathParams\n  >({\n    url: '/workspaces/{workspaceId}/invites/{inviteId}',\n    method: 'delete',\n    ...variables,\n    signal\n  });\n\nexport type AcceptWorkspaceMemberInvitePathParams = {\n  /**\n   * Workspace ID\n   */\n  workspaceId: Schemas.WorkspaceID;\n  /**\n   * Invite Key (secret) for the invited user\n   */\n  inviteKey: Schemas.InviteKey;\n};\n\nexport type AcceptWorkspaceMemberInviteError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 403;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type AcceptWorkspaceMemberInviteVariables = {\n  pathParams: AcceptWorkspaceMemberInvitePathParams;\n} & ControlPlaneFetcherExtraProps;\n\n/**\n * Accept the invitation to join a workspace. If the operation succeeds the user will be a member of the workspace\n */\nexport const acceptWorkspaceMemberInvite = (variables: AcceptWorkspaceMemberInviteVariables, signal?: AbortSignal) =>\n  controlPlaneFetch<\n    undefined,\n    AcceptWorkspaceMemberInviteError,\n    undefined,\n    {},\n    {},\n    AcceptWorkspaceMemberInvitePathParams\n  >({\n    url: '/workspaces/{workspaceId}/invites/{inviteKey}/accept',\n    method: 'post',\n    ...variables,\n    signal\n  });\n\nexport type ResendWorkspaceMemberInvitePathParams = {\n  /**\n   * Workspace ID\n   */\n  workspaceId: Schemas.WorkspaceID;\n  /**\n   * Invite identifier\n   */\n  inviteId: Schemas.InviteID;\n};\n\nexport type ResendWorkspaceMemberInviteError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 403;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type ResendWorkspaceMemberInviteVariables = {\n  pathParams: ResendWorkspaceMemberInvitePathParams;\n} & ControlPlaneFetcherExtraProps;\n\n/**\n * This operation provides a way to resend an Invite notification. Invite notifications can only be sent for Invites not yet accepted.\n */\nexport const resendWorkspaceMemberInvite = (variables: ResendWorkspaceMemberInviteVariables, signal?: AbortSignal) =>\n  controlPlaneFetch<\n    undefined,\n    ResendWorkspaceMemberInviteError,\n    undefined,\n    {},\n    {},\n    ResendWorkspaceMemberInvitePathParams\n  >({\n    url: '/workspaces/{workspaceId}/invites/{inviteId}/resend',\n    method: 'post',\n    ...variables,\n    signal\n  });\n\nexport type ListClustersPathParams = {\n  /**\n   * Workspace ID\n   */\n  workspaceId: Schemas.WorkspaceID;\n};\n\nexport type ListClustersQueryParams = {\n  /**\n   * Page size\n   */\n  page?: Schemas.PageSize;\n  /**\n   * Page token\n   */\n  token?: Schemas.PageToken;\n};\n\nexport type ListClustersError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n>;\n\nexport type ListClustersVariables = {\n  pathParams: ListClustersPathParams;\n  queryParams?: ListClustersQueryParams;\n} & ControlPlaneFetcherExtraProps;\n\n/**\n * List all clusters available in your Workspace.\n */\nexport const listClusters = (variables: ListClustersVariables, signal?: AbortSignal) =>\n  controlPlaneFetch<\n    Schemas.ListClustersResponse,\n    ListClustersError,\n    undefined,\n    {},\n    ListClustersQueryParams,\n    ListClustersPathParams\n  >({\n    url: '/workspaces/{workspaceId}/clusters',\n    method: 'get',\n    ...variables,\n    signal\n  });\n\nexport type CreateClusterPathParams = {\n  /**\n   * Workspace ID\n   */\n  workspaceId: Schemas.WorkspaceID;\n};\n\nexport type CreateClusterError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 422;\n      payload: Responses.SimpleError;\n    }\n  | {\n      status: 423;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type CreateClusterVariables = {\n  body: Schemas.ClusterCreateDetails;\n  pathParams: CreateClusterPathParams;\n} & ControlPlaneFetcherExtraProps;\n\nexport const createCluster = (variables: CreateClusterVariables, signal?: AbortSignal) =>\n  controlPlaneFetch<\n    Schemas.ClusterResponse,\n    CreateClusterError,\n    Schemas.ClusterCreateDetails,\n    {},\n    {},\n    CreateClusterPathParams\n  >({\n    url: '/workspaces/{workspaceId}/clusters',\n    method: 'post',\n    ...variables,\n    signal\n  });\n\nexport type GetClusterPathParams = {\n  /**\n   * Workspace ID\n   */\n  workspaceId: Schemas.WorkspaceID;\n  /**\n   * Cluster ID\n   */\n  clusterId: Schemas.ClusterID;\n};\n\nexport type GetClusterError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n>;\n\nexport type GetClusterVariables = {\n  pathParams: GetClusterPathParams;\n} & ControlPlaneFetcherExtraProps;\n\n/**\n * Retrieve metadata for given cluster ID\n */\nexport const getCluster = (variables: GetClusterVariables, signal?: AbortSignal) =>\n  controlPlaneFetch<Schemas.ClusterMetadata, GetClusterError, undefined, {}, {}, GetClusterPathParams>({\n    url: '/workspaces/{workspaceId}/clusters/{clusterId}',\n    method: 'get',\n    ...variables,\n    signal\n  });\n\nexport type UpdateClusterPathParams = {\n  /**\n   * Workspace ID\n   */\n  workspaceId: Schemas.WorkspaceID;\n  /**\n   * Cluster ID\n   */\n  clusterId: Schemas.ClusterID;\n};\n\nexport type UpdateClusterError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n>;\n\nexport type UpdateClusterVariables = {\n  body: Schemas.ClusterUpdateDetails;\n  pathParams: UpdateClusterPathParams;\n} & ControlPlaneFetcherExtraProps;\n\n/**\n * Update cluster for given cluster ID\n */\nexport const updateCluster = (variables: UpdateClusterVariables, signal?: AbortSignal) =>\n  controlPlaneFetch<\n    Schemas.ClusterUpdateMetadata,\n    UpdateClusterError,\n    Schemas.ClusterUpdateDetails,\n    {},\n    {},\n    UpdateClusterPathParams\n  >({\n    url: '/workspaces/{workspaceId}/clusters/{clusterId}',\n    method: 'patch',\n    ...variables,\n    signal\n  });\n\nexport type DeleteClusterPathParams = {\n  /**\n   * Workspace ID\n   */\n  workspaceId: Schemas.WorkspaceID;\n  /**\n   * Cluster ID\n   */\n  clusterId: Schemas.ClusterID;\n};\n\nexport type DeleteClusterError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n>;\n\nexport type DeleteClusterVariables = {\n  pathParams: DeleteClusterPathParams;\n} & ControlPlaneFetcherExtraProps;\n\n/**\n * Delete cluster with given cluster ID\n */\nexport const deleteCluster = (variables: DeleteClusterVariables, signal?: AbortSignal) =>\n  controlPlaneFetch<Schemas.ClusterDeleteMetadata, DeleteClusterError, undefined, {}, {}, DeleteClusterPathParams>({\n    url: '/workspaces/{workspaceId}/clusters/{clusterId}',\n    method: 'delete',\n    ...variables,\n    signal\n  });\n\nexport type GetDatabaseListPathParams = {\n  /**\n   * Workspace ID\n   */\n  workspaceId: Schemas.WorkspaceID;\n};\n\nexport type GetDatabaseListError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n>;\n\nexport type GetDatabaseListVariables = {\n  pathParams: GetDatabaseListPathParams;\n} & ControlPlaneFetcherExtraProps;\n\n/**\n * List all databases available in your Workspace.\n */\nexport const getDatabaseList = (variables: GetDatabaseListVariables, signal?: AbortSignal) =>\n  controlPlaneFetch<Schemas.ListDatabasesResponse, GetDatabaseListError, undefined, {}, {}, GetDatabaseListPathParams>({\n    url: '/workspaces/{workspaceId}/dbs',\n    method: 'get',\n    ...variables,\n    signal\n  });\n\nexport type CreateDatabasePathParams = {\n  /**\n   * Workspace ID\n   */\n  workspaceId: Schemas.WorkspaceID;\n  /**\n   * The Database Name\n   */\n  dbName: Schemas.DBName;\n};\n\nexport type CreateDatabaseError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 422;\n      payload: Responses.SimpleError;\n    }\n  | {\n      status: 423;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type CreateDatabaseResponse = {\n  /**\n   * @minLength 1\n   */\n  databaseName: string;\n  branchName?: string;\n  status: Schemas.MigrationStatus;\n};\n\nexport type CreateDatabaseRequestBody = {\n  /**\n   * @minLength 1\n   */\n  branchName?: string;\n  /**\n   * @minLength 1\n   */\n  region: string;\n  /**\n   * Enable postgres access for this database\n   *\n   * @default false\n   */\n  postgresEnabled?: boolean;\n  /**\n   * The dedicated cluster where branches from this database will be created. Defaults to 'shared-cluster'.\n   *\n   * @minLength 1\n   * @x-internal true\n   */\n  defaultClusterID?: string;\n  ui?: {\n    color?: string;\n  };\n  metadata?: Schemas.BranchMetadata;\n};\n\nexport type CreateDatabaseVariables = {\n  body: CreateDatabaseRequestBody;\n  pathParams: CreateDatabasePathParams;\n} & ControlPlaneFetcherExtraProps;\n\n/**\n * Create Database with identifier name\n */\nexport const createDatabase = (variables: CreateDatabaseVariables, signal?: AbortSignal) =>\n  controlPlaneFetch<\n    CreateDatabaseResponse,\n    CreateDatabaseError,\n    CreateDatabaseRequestBody,\n    {},\n    {},\n    CreateDatabasePathParams\n  >({\n    url: '/workspaces/{workspaceId}/dbs/{dbName}',\n    method: 'put',\n    ...variables,\n    signal\n  });\n\nexport type DeleteDatabasePathParams = {\n  /**\n   * Workspace ID\n   */\n  workspaceId: Schemas.WorkspaceID;\n  /**\n   * The Database Name\n   */\n  dbName: Schemas.DBName;\n};\n\nexport type DeleteDatabaseError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type DeleteDatabaseResponse = {\n  status: Schemas.MigrationStatus;\n};\n\nexport type DeleteDatabaseVariables = {\n  pathParams: DeleteDatabasePathParams;\n} & ControlPlaneFetcherExtraProps;\n\n/**\n * Delete a database and all of its branches and tables permanently.\n */\nexport const deleteDatabase = (variables: DeleteDatabaseVariables, signal?: AbortSignal) =>\n  controlPlaneFetch<DeleteDatabaseResponse, DeleteDatabaseError, undefined, {}, {}, DeleteDatabasePathParams>({\n    url: '/workspaces/{workspaceId}/dbs/{dbName}',\n    method: 'delete',\n    ...variables,\n    signal\n  });\n\nexport type GetDatabaseMetadataPathParams = {\n  /**\n   * Workspace ID\n   */\n  workspaceId: Schemas.WorkspaceID;\n  /**\n   * The Database Name\n   */\n  dbName: Schemas.DBName;\n};\n\nexport type GetDatabaseMetadataError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type GetDatabaseMetadataVariables = {\n  pathParams: GetDatabaseMetadataPathParams;\n} & ControlPlaneFetcherExtraProps;\n\n/**\n * Retrieve metadata of the given database\n */\nexport const getDatabaseMetadata = (variables: GetDatabaseMetadataVariables, signal?: AbortSignal) =>\n  controlPlaneFetch<\n    Schemas.DatabaseMetadata,\n    GetDatabaseMetadataError,\n    undefined,\n    {},\n    {},\n    GetDatabaseMetadataPathParams\n  >({\n    url: '/workspaces/{workspaceId}/dbs/{dbName}',\n    method: 'get',\n    ...variables,\n    signal\n  });\n\nexport type UpdateDatabaseMetadataPathParams = {\n  /**\n   * Workspace ID\n   */\n  workspaceId: Schemas.WorkspaceID;\n  /**\n   * The Database Name\n   */\n  dbName: Schemas.DBName;\n};\n\nexport type UpdateDatabaseMetadataError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type UpdateDatabaseMetadataRequestBody = {\n  ui?: {\n    /**\n     * @minLength 1\n     */\n    color?: string;\n  };\n  /**\n   * The dedicated cluster where branches from this database will be created. Defaults to 'shared-cluster'.\n   *\n   * @minLength 1\n   * @x-internal true\n   */\n  defaultClusterID?: string;\n};\n\nexport type UpdateDatabaseMetadataVariables = {\n  body?: UpdateDatabaseMetadataRequestBody;\n  pathParams: UpdateDatabaseMetadataPathParams;\n} & ControlPlaneFetcherExtraProps;\n\n/**\n * Update the color of the selected database\n */\nexport const updateDatabaseMetadata = (variables: UpdateDatabaseMetadataVariables, signal?: AbortSignal) =>\n  controlPlaneFetch<\n    Schemas.DatabaseMetadata,\n    UpdateDatabaseMetadataError,\n    UpdateDatabaseMetadataRequestBody,\n    {},\n    {},\n    UpdateDatabaseMetadataPathParams\n  >({\n    url: '/workspaces/{workspaceId}/dbs/{dbName}',\n    method: 'patch',\n    ...variables,\n    signal\n  });\n\nexport type RenameDatabasePathParams = {\n  /**\n   * Workspace ID\n   */\n  workspaceId: Schemas.WorkspaceID;\n  /**\n   * The Database Name\n   */\n  dbName: Schemas.DBName;\n};\n\nexport type RenameDatabaseError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 422;\n      payload: Responses.SimpleError;\n    }\n  | {\n      status: 423;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type RenameDatabaseRequestBody = {\n  /**\n   * @minLength 1\n   */\n  newName: string;\n};\n\nexport type RenameDatabaseVariables = {\n  body: RenameDatabaseRequestBody;\n  pathParams: RenameDatabasePathParams;\n} & ControlPlaneFetcherExtraProps;\n\n/**\n * Change the name of an existing database\n */\nexport const renameDatabase = (variables: RenameDatabaseVariables, signal?: AbortSignal) =>\n  controlPlaneFetch<\n    Schemas.DatabaseMetadata,\n    RenameDatabaseError,\n    RenameDatabaseRequestBody,\n    {},\n    {},\n    RenameDatabasePathParams\n  >({\n    url: '/workspaces/{workspaceId}/dbs/{dbName}/rename',\n    method: 'post',\n    ...variables,\n    signal\n  });\n\nexport type GetDatabaseGithubSettingsPathParams = {\n  /**\n   * Workspace ID\n   */\n  workspaceId: Schemas.WorkspaceID;\n  /**\n   * The Database Name\n   */\n  dbName: Schemas.DBName;\n};\n\nexport type GetDatabaseGithubSettingsError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type GetDatabaseGithubSettingsVariables = {\n  pathParams: GetDatabaseGithubSettingsPathParams;\n} & ControlPlaneFetcherExtraProps;\n\n/**\n * Retrieve current Github database settings\n */\nexport const getDatabaseGithubSettings = (variables: GetDatabaseGithubSettingsVariables, signal?: AbortSignal) =>\n  controlPlaneFetch<\n    Schemas.DatabaseGithubSettings,\n    GetDatabaseGithubSettingsError,\n    undefined,\n    {},\n    {},\n    GetDatabaseGithubSettingsPathParams\n  >({\n    url: '/workspaces/{workspaceId}/dbs/{dbName}/github',\n    method: 'get',\n    ...variables,\n    signal\n  });\n\nexport type UpdateDatabaseGithubSettingsPathParams = {\n  /**\n   * Workspace ID\n   */\n  workspaceId: Schemas.WorkspaceID;\n  /**\n   * The Database Name\n   */\n  dbName: Schemas.DBName;\n};\n\nexport type UpdateDatabaseGithubSettingsError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 422;\n      payload: Responses.SimpleError;\n    }\n  | {\n      status: 423;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type UpdateDatabaseGithubSettingsVariables = {\n  body: Schemas.DatabaseGithubSettings;\n  pathParams: UpdateDatabaseGithubSettingsPathParams;\n} & ControlPlaneFetcherExtraProps;\n\n/**\n * Map the database to a Github repository, Xata will create database branch previews for all new branches/PRs in the repo.\n */\nexport const updateDatabaseGithubSettings = (variables: UpdateDatabaseGithubSettingsVariables, signal?: AbortSignal) =>\n  controlPlaneFetch<\n    Schemas.DatabaseGithubSettings,\n    UpdateDatabaseGithubSettingsError,\n    Schemas.DatabaseGithubSettings,\n    {},\n    {},\n    UpdateDatabaseGithubSettingsPathParams\n  >({\n    url: '/workspaces/{workspaceId}/dbs/{dbName}/github',\n    method: 'put',\n    ...variables,\n    signal\n  });\n\nexport type DeleteDatabaseGithubSettingsPathParams = {\n  /**\n   * Workspace ID\n   */\n  workspaceId: Schemas.WorkspaceID;\n  /**\n   * The Database Name\n   */\n  dbName: Schemas.DBName;\n};\n\nexport type DeleteDatabaseGithubSettingsError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n  | {\n      status: 404;\n      payload: Responses.SimpleError;\n    }\n>;\n\nexport type DeleteDatabaseGithubSettingsVariables = {\n  pathParams: DeleteDatabaseGithubSettingsPathParams;\n} & ControlPlaneFetcherExtraProps;\n\n/**\n * Delete any existing database Github settings\n */\nexport const deleteDatabaseGithubSettings = (variables: DeleteDatabaseGithubSettingsVariables, signal?: AbortSignal) =>\n  controlPlaneFetch<\n    undefined,\n    DeleteDatabaseGithubSettingsError,\n    undefined,\n    {},\n    {},\n    DeleteDatabaseGithubSettingsPathParams\n  >({\n    url: '/workspaces/{workspaceId}/dbs/{dbName}/github',\n    method: 'delete',\n    ...variables,\n    signal\n  });\n\nexport type ListRegionsPathParams = {\n  /**\n   * Workspace ID\n   */\n  workspaceId: Schemas.WorkspaceID;\n};\n\nexport type ListRegionsError = Fetcher.ErrorWrapper<\n  | {\n      status: 400;\n      payload: Responses.BadRequestError;\n    }\n  | {\n      status: 401;\n      payload: Responses.AuthError;\n    }\n>;\n\nexport type ListRegionsVariables = {\n  pathParams: ListRegionsPathParams;\n} & ControlPlaneFetcherExtraProps;\n\n/**\n * List regions available to create a database on\n */\nexport const listRegions = (variables: ListRegionsVariables, signal?: AbortSignal) =>\n  controlPlaneFetch<Schemas.ListRegionsResponse, ListRegionsError, undefined, {}, {}, ListRegionsPathParams>({\n    url: '/workspaces/{workspaceId}/regions',\n    method: 'get',\n    ...variables,\n    signal\n  });\n\nexport const operationsByTag = {\n  oAuth: {\n    getAuthorizationCode,\n    grantAuthorizationCode,\n    getUserOAuthClients,\n    deleteUserOAuthClient,\n    getUserOAuthAccessTokens,\n    deleteOAuthAccessToken,\n    updateOAuthAccessToken\n  },\n  users: { getUser, updateUser, deleteUser },\n  authentication: { getUserAPIKeys, createUserAPIKey, deleteUserAPIKey },\n  workspaces: {\n    getWorkspacesList,\n    createWorkspace,\n    getWorkspace,\n    updateWorkspace,\n    deleteWorkspace,\n    getWorkspaceSettings,\n    updateWorkspaceSettings,\n    getWorkspaceMembersList,\n    updateWorkspaceMemberRole,\n    removeWorkspaceMember\n  },\n  invites: {\n    inviteWorkspaceMember,\n    updateWorkspaceMemberInvite,\n    cancelWorkspaceMemberInvite,\n    acceptWorkspaceMemberInvite,\n    resendWorkspaceMemberInvite\n  },\n  xbcontrolOther: {\n    listClusters,\n    createCluster,\n    getCluster,\n    updateCluster,\n    deleteCluster\n  },\n  databases: {\n    getDatabaseList,\n    createDatabase,\n    deleteDatabase,\n    getDatabaseMetadata,\n    updateDatabaseMetadata,\n    renameDatabase,\n    getDatabaseGithubSettings,\n    updateDatabaseGithubSettings,\n    deleteDatabaseGithubSettings,\n    listRegions\n  }\n};\n","export * from './dataPlaneComponents';\nexport * from './controlPlaneComponents';\n\nimport { operationsByTag as dataPlaneOperations } from './dataPlaneComponents';\nimport { operationsByTag as controlPlaneOperations } from './controlPlaneComponents';\n\nimport { deepMerge } from '../util/lang';\n\nexport const operationsByTag = deepMerge(dataPlaneOperations, controlPlaneOperations);\n","import { defaultTrace, TraceFunction } from '../schema/tracing';\nimport { FetchImpl, getFetchImplementation } from '../util/fetch';\nimport { RequiredKeys } from '../util/types';\nimport { generateUUID } from '../util/uuid';\nimport { operationsByTag } from './components';\nimport type { FetcherExtraProps } from './fetcher';\nimport { getHostUrl, HostProvider } from './providers';\n\nexport type ApiExtraProps = Omit<FetcherExtraProps, 'endpoint'>;\n\nexport interface XataApiClientOptions {\n  fetch?: FetchImpl;\n  apiKey?: string;\n  host?: HostProvider;\n  trace?: TraceFunction;\n  clientName?: string;\n  xataAgentExtra?: Record<string, string>;\n}\n\ntype UserProps = {\n  headers?: Record<string, unknown>;\n};\n\ntype XataApiProxy = {\n  [Tag in keyof typeof operationsByTag]: {\n    [Method in keyof (typeof operationsByTag)[Tag]]: (typeof operationsByTag)[Tag][Method] extends infer Operation extends (\n      ...args: any\n    ) => any\n      ? Omit<Parameters<Operation>[0], keyof ApiExtraProps> extends infer Params\n        ? RequiredKeys<Params> extends never\n          ? (params?: Params & UserProps) => ReturnType<Operation>\n          : (params: Params & UserProps) => ReturnType<Operation>\n        : never\n      : never;\n  };\n};\n\nconst buildApiClient = () =>\n  class {\n    constructor(options: XataApiClientOptions = {}) {\n      const provider = options.host ?? 'production';\n      const apiKey = options.apiKey;\n      const trace = options.trace ?? defaultTrace;\n      const clientID = generateUUID();\n\n      if (!apiKey) {\n        throw new Error('Could not resolve a valid apiKey');\n      }\n\n      const extraProps: ApiExtraProps = {\n        apiUrl: getHostUrl(provider, 'main'),\n        workspacesApiUrl: getHostUrl(provider, 'workspaces'),\n        fetch: getFetchImplementation(options.fetch),\n        apiKey,\n        trace,\n        clientName: options.clientName,\n        xataAgentExtra: options.xataAgentExtra,\n        clientID\n      };\n\n      return new Proxy(this, {\n        get: (_target, namespace: keyof typeof operationsByTag) => {\n          if (operationsByTag[namespace] === undefined) {\n            return undefined;\n          }\n\n          return new Proxy(\n            {},\n            {\n              get: (_target, operation: keyof (typeof operationsByTag)[keyof typeof operationsByTag]) => {\n                if (operationsByTag[namespace][operation] === undefined) {\n                  return undefined;\n                }\n\n                const method = operationsByTag[namespace][operation] as any;\n\n                return async (params: Record<string, unknown>) => {\n                  return await method({ ...params, ...extraProps });\n                };\n              }\n            }\n          );\n        }\n      });\n    }\n  } as unknown as { new (options?: XataApiClientOptions): XataApiProxy };\n\nexport class XataApiClient extends buildApiClient() {}\n","import { XataPlugin, XataPluginOptions } from '../plugins';\nimport { XataApiClient } from './client';\nimport { operationsByTag } from './components';\nimport type * as Responses from './responses';\nimport type * as Schemas from './schemas';\n\nexport type { FetchImpl } from '../util/fetch';\nexport * from './client';\nexport * from './components';\nexport { FetcherError } from './errors';\nexport type { FetcherExtraProps } from './fetcher';\nexport * from './providers';\nexport { operationsByTag as Operations };\nexport type { Responses, Schemas };\n\nexport class XataApiPlugin implements XataPlugin {\n  build(options: XataPluginOptions) {\n    return new XataApiClient(options);\n  }\n}\n","import { ApiExtraProps, HostProvider, Schemas } from './api';\n\nexport abstract class XataPlugin {\n  abstract build(options: XataPluginOptions): unknown;\n}\n\nexport type XataPluginOptions = ApiExtraProps & {\n  host: HostProvider;\n  tables: Schemas.Table[];\n  branch: string;\n};\n","import { isDefined } from '../util/lang';\n\n// Example of private URLs\n// https://us-west-2.xata.sh/file/id?verify=mrkusp0000000vd3i4bgi51glgk73f33g2uvibuc35kqne5ckiohoflsekv56f0r\n// https://us-west-2.xata.sh/transform/rotate=90/file/id?verify=mrkusp0000000vd3i4bgi51glgk73f33g2uvibuc35kqne5ckiohoflsekv56f0r\n// Example of public URLs\n// https://us-west-2.storage.xata.sh/id\n// https://us-west-2.storage.xata.sh/transform/rotate=90/id\n\nexport interface ImageTransformations {\n  /**\n   * Whether to preserve animation frames from input files. Default is true.\n   * Setting it to false reduces animations to still images. This setting is\n   * recommended when enlarging images or processing arbitrary user content,\n   * because large GIF animations can weigh tens or even hundreds of megabytes.\n   * It is also useful to set anim:false when using format:\"json\" to get the\n   * response quicker without the number of frames.\n   */\n  anim?: boolean;\n  /**\n   * Background color to add underneath the image. Applies only to images with\n   * transparency (such as PNG). Accepts any CSS color (#RRGGBB, rgba(),\n   * hsl(), etc.)\n   */\n  background?: string;\n  /**\n   * Radius of a blur filter (approximate gaussian). Maximum supported radius\n   * is 250.\n   */\n  blur?: number;\n  /**\n   * Increase brightness by a factor. A value of 1.0 equals no change, a value\n   * of 0.5 equals half brightness, and a value of 2.0 equals twice as bright.\n   * 0 is ignored.\n   */\n  brightness?: number;\n  /**\n   * Slightly reduces latency on a cache miss by selecting a\n   * quickest-to-compress file format, at a cost of increased file size and\n   * lower image quality. It will usually override the format option and choose\n   * JPEG over WebP or AVIF. We do not recommend using this option, except in\n   * unusual circumstances like resizing uncacheable dynamically-generated\n   * images.\n   */\n  compression?: 'fast';\n  /**\n   * Increase contrast by a factor. A value of 1.0 equals no change, a value of\n   * 0.5 equals low contrast, and a value of 2.0 equals high contrast. 0 is\n   * ignored.\n   */\n  contrast?: number;\n  /**\n   * Download file. Forces browser to download the image.\n   * Value is used for the download file name. Extension is optional.\n   */\n  download?: string;\n  /**\n   * Device Pixel Ratio. Default 1. Multiplier for width/height that makes it\n   * easier to specify higher-DPI sizes in <img srcset>.\n   */\n  dpr?: number;\n  /**\n   * Resizing mode as a string. It affects interpretation of width and height\n   * options:\n   *  - scale-down: Similar to contain, but the image is never enlarged. If\n   *    the image is larger than given width or height, it will be resized.\n   *    Otherwise its original size will be kept.\n   *  - contain: Resizes to maximum size that fits within the given width and\n   *    height. If only a single dimension is given (e.g. only width), the\n   *    image will be shrunk or enlarged to exactly match that dimension.\n   *    Aspect ratio is always preserved.\n   *  - cover: Resizes (shrinks or enlarges) to fill the entire area of width\n   *    and height. If the image has an aspect ratio different from the ratio\n   *    of width and height, it will be cropped to fit.\n   *  - crop: The image will be shrunk and cropped to fit within the area\n   *    specified by width and height. The image will not be enlarged. For images\n   *    smaller than the given dimensions it's the same as scale-down. For\n   *    images larger than the given dimensions, it's the same as cover.\n   *    See also trim.\n   *  - pad: Resizes to the maximum size that fits within the given width and\n   *    height, and then fills the remaining area with a background color\n   *    (white by default). Use of this mode is not recommended, as the same\n   *    effect can be more efficiently achieved with the contain mode and the\n   *    CSS object-fit: contain property.\n   */\n  fit?: 'scale-down' | 'contain' | 'cover' | 'crop' | 'pad';\n  /**\n   * Output format to generate. It can be:\n   *  - avif: generate images in AVIF format.\n   *  - webp: generate images in Google WebP format. Set quality to 100 to get\n   *    the WebP-lossless format.\n   *  - json: instead of generating an image, outputs information about the\n   *    image, in JSON format. The JSON object will contain image size\n   *    (before and after resizing), source images MIME type, file size, etc.\n   * - jpeg: generate images in JPEG format.\n   * - png: generate images in PNG format.\n   */\n  format?: 'auto' | 'avif' | 'webp' | 'json' | 'jpeg' | 'png';\n  /**\n   * Increase exposure by a factor. A value of 1.0 equals no change, a value of\n   * 0.5 darkens the image, and a value of 2.0 lightens the image. 0 is ignored.\n   */\n  gamma?: number;\n  /**\n   * When cropping with fit: \"cover\", this defines the side or point that should\n   * be left uncropped. The value is either a string\n   * \"left\", \"right\", \"top\", \"bottom\", \"auto\", or \"center\" (the default),\n   * or an object {x, y} containing focal point coordinates in the original\n   * image expressed as fractions ranging from 0.0 (top or left) to 1.0\n   * (bottom or right), 0.5 being the center. {fit: \"cover\", gravity: \"top\"} will\n   * crop bottom or left and right sides as necessary, but wont crop anything\n   * from the top. {fit: \"cover\", gravity: {x:0.5, y:0.2}} will crop each side to\n   * preserve as much as possible around a point at 20% of the height of the\n   * source image.\n   */\n  gravity?: 'left' | 'right' | 'top' | 'bottom' | 'center' | 'auto' | { x: number; y: number };\n  /**\n   * Maximum height in image pixels. The value must be an integer.\n   */\n  height?: number;\n  /**\n   * What EXIF data should be preserved in the output image. Note that EXIF\n   * rotation and embedded color profiles are always applied (\"baked in\" into\n   * the image), and aren't affected by this option. Note that if the Polish\n   * feature is enabled, all metadata may have been removed already and this\n   * option may have no effect.\n   *  - keep: Preserve most of EXIF metadata, including GPS location if there's\n   *    any.\n   *  - copyright: Only keep the copyright tag, and discard everything else.\n   *    This is the default behavior for JPEG files.\n   *  - none: Discard all invisible EXIF metadata. Currently WebP and PNG\n   *    output formats always discard metadata.\n   */\n  metadata?: 'keep' | 'copyright' | 'none';\n  /**\n   * Quality setting from 1-100 (useful values are in 60-90 range). Lower values\n   * make images look worse, but load faster. The default is 85. It applies only\n   * to JPEG and WebP images. It doesnt have any effect on PNG.\n   */\n  quality?: number;\n  /**\n   * Number of degrees (90, 180, 270) to rotate the image by. width and height\n   * options refer to axes after rotation.\n   */\n  rotate?: 0 | 90 | 180 | 270 | 360;\n  /**\n   * Strength of sharpening filter to apply to the image. Floating-point\n   * number between 0 (no sharpening, default) and 10 (maximum). 1.0 is a\n   * recommended value for downscaled images.\n   */\n  sharpen?: number;\n  /**\n   * An object with four properties {left, top, right, bottom} that specify\n   * a number of pixels to cut off on each side. Allows removal of borders\n   * or cutting out a specific fragment of an image. Trimming is performed\n   * before resizing or rotation. Takes dpr into account.\n   */\n  trim?: {\n    left?: number;\n    top?: number;\n    right?: number;\n    bottom?: number;\n  };\n  /**\n   * Maximum width in image pixels. The value must be an integer.\n   */\n  width?: number;\n}\n\nexport function buildTransformString(transformations: ImageTransformations[]): string {\n  return transformations\n    .flatMap((t) =>\n      Object.entries(t).map(([key, value]) => {\n        // Trim: top;right;bottom;left\n        if (key === 'trim') {\n          const { left = 0, top = 0, right = 0, bottom = 0 } = value;\n          return `${key}=${[top, right, bottom, left].join(';')}`;\n        }\n\n        // Gravity: 0x1\n        if (key === 'gravity' && typeof value === 'object') {\n          const { x = 0.5, y = 0.5 } = value;\n          return `${key}=${[x, y].join('x')}`;\n        }\n\n        return `${key}=${value}`;\n      })\n    )\n    .join(',');\n}\n\nexport function transformImage(url: string, ...transformations: ImageTransformations[]): string;\nexport function transformImage(url: string | undefined, ...transformations: ImageTransformations[]): string | undefined;\nexport function transformImage(url: string | undefined, ...transformations: ImageTransformations[]) {\n  if (!isDefined(url)) return undefined;\n\n  const newTransformations = buildTransformString(transformations);\n\n  const { hostname, pathname, search } = new URL(url);\n\n  // If pathname includes transform, we need to remove them\n  const pathParts = pathname.split('/');\n  const transformIndex = pathParts.findIndex((part) => part === 'transform');\n  const removedItems = transformIndex >= 0 ? pathParts.splice(transformIndex, 2) : [];\n\n  // Build the new URL parts\n  const transform = `/transform/${[removedItems[1], newTransformations].filter(isDefined).join(',')}`;\n  const path = pathParts.join('/');\n\n  return `https://${hostname}${transform}${path}${search}`;\n}\n","import { InputFileEntry } from '../api/schemas';\nimport { ImageTransformations, transformImage } from '../files/transformations';\nimport { Buffer } from '../util/buffer';\nimport { compactObject, isDefined } from '../util/lang';\nimport { StringKeys } from '../util/types';\nimport { Identifiable, InputXataFile } from './record';\n\nexport type XataFileEditableFields = Partial<Pick<XataArrayFile, keyof InputFileEntry>>;\nexport type XataFileFields = Partial<\n  Pick<\n    XataArrayFile,\n    { [K in StringKeys<XataArrayFile>]: XataArrayFile[K] extends Function ? never : K }[keyof XataArrayFile]\n  >\n>;\n\nexport class XataFile {\n  /**\n   * Identifier of the file.\n   */\n  public id?: string;\n  /**\n   * Name of the file.\n   */\n  public name?: string;\n  /**\n   * Media type of the file.\n   */\n  public mediaType?: string;\n  /**\n   * Base64 encoded content of the file.\n   */\n  public base64Content?: string;\n  /**\n   * Whether to enable public url for the file.\n   */\n  public enablePublicUrl?: boolean;\n  /**\n   * Timeout for the signed url in seconds. Default: 60 seconds (1 minute).\n   */\n  public signedUrlTimeout?: number;\n  /**\n   * Time to live for upload URLs in seconds. Default: 86400 seconds (24 hours).\n   */\n  public uploadUrlTimeout?: number;\n  /**\n   * Size of the file.\n   */\n  public size?: number;\n  /**\n   * Version of the file.\n   */\n  public version?: number;\n  /**\n   * Url of the file.\n   */\n  public url?: string;\n  /**\n   * Signed url of the file (if requested, a temporary signed url will be returned).\n   */\n  public signedUrl?: string;\n  /**\n   * Upload url of the file (if requested, a temporary upload url will be returned).\n   */\n  public uploadUrl?: string;\n  /**\n   * Attributes of the file.\n   */\n  public attributes?: Record<string, any>;\n\n  constructor(file: Partial<XataFile>) {\n    this.id = file.id;\n    this.name = file.name;\n    this.mediaType = file.mediaType;\n    this.base64Content = file.base64Content;\n    this.enablePublicUrl = file.enablePublicUrl;\n    this.signedUrlTimeout = file.signedUrlTimeout;\n    this.uploadUrlTimeout = file.uploadUrlTimeout;\n    this.size = file.size;\n    this.version = file.version;\n    this.url = file.url;\n    this.signedUrl = file.signedUrl;\n    this.uploadUrl = file.uploadUrl;\n    this.attributes = file.attributes;\n  }\n\n  static fromBuffer(buffer: Buffer, options: XataFileEditableFields = {}): XataFile {\n    const base64Content = buffer.toString('base64');\n    return new XataFile({ ...options, base64Content });\n  }\n\n  public toBuffer(): Buffer {\n    if (!this.base64Content) {\n      throw new Error(`File content is not available, please select property \"base64Content\" when querying the file`);\n    }\n\n    return Buffer.from(this.base64Content, 'base64');\n  }\n\n  static fromArrayBuffer(arrayBuffer: ArrayBuffer, options: XataFileEditableFields = {}) {\n    const uint8Array = new Uint8Array(arrayBuffer);\n    return this.fromUint8Array(uint8Array, options);\n  }\n\n  public toArrayBuffer(): ArrayBuffer {\n    if (!this.base64Content) {\n      throw new Error(`File content is not available, please select property \"base64Content\" when querying the file`);\n    }\n\n    const binary = atob(this.base64Content);\n    return new ArrayBuffer(binary.length);\n  }\n\n  static fromUint8Array(uint8Array: Uint8Array, options: XataFileEditableFields = {}) {\n    let binary = '';\n\n    for (let i = 0; i < uint8Array.byteLength; i++) {\n      binary += String.fromCharCode(uint8Array[i]);\n    }\n\n    const base64Content = btoa(binary);\n    return new XataFile({ ...options, base64Content });\n  }\n\n  public toUint8Array(): Uint8Array {\n    if (!this.base64Content) {\n      throw new Error(`File content is not available, please select property \"base64Content\" when querying the file`);\n    }\n\n    const binary = atob(this.base64Content);\n    const uint8Array = new Uint8Array(binary.length);\n\n    for (let i = 0; i < binary.length; i++) {\n      uint8Array[i] = binary.charCodeAt(i);\n    }\n\n    return uint8Array;\n  }\n\n  static async fromBlob(file: Blob, options: XataFileEditableFields = {}) {\n    // @ts-ignore - Blob doesn't have a name property, File which extends Blob does\n    const name = options.name ?? file.name;\n    const mediaType = file.type;\n    const arrayBuffer = await file.arrayBuffer();\n\n    return this.fromArrayBuffer(arrayBuffer, { ...options, name, mediaType });\n  }\n\n  public toBlob(): Blob {\n    if (!this.base64Content) {\n      throw new Error(`File content is not available, please select property \"base64Content\" when querying the file`);\n    }\n\n    const binary = atob(this.base64Content);\n    const uint8Array = new Uint8Array(binary.length);\n\n    for (let i = 0; i < binary.length; i++) {\n      uint8Array[i] = binary.charCodeAt(i);\n    }\n\n    return new Blob([uint8Array], { type: this.mediaType });\n  }\n\n  static fromString(string: string, options: XataFileEditableFields = {}): XataFile {\n    const base64Content = btoa(string);\n    return new XataFile({ ...options, base64Content });\n  }\n\n  public toString(): string {\n    if (!this.base64Content) {\n      throw new Error(`File content is not available, please select property \"base64Content\" when querying the file`);\n    }\n\n    return atob(this.base64Content);\n  }\n\n  static fromBase64(base64Content: string, options: XataFileEditableFields = {}): XataFile {\n    return new XataFile({ ...options, base64Content });\n  }\n\n  public toBase64(): string {\n    if (!this.base64Content) {\n      throw new Error(`File content is not available, please select property \"base64Content\" when querying the file`);\n    }\n\n    return this.base64Content;\n  }\n\n  public transform(...options: ImageTransformations[]) {\n    return {\n      url: transformImage(this.url, ...options),\n      signedUrl: transformImage(this.signedUrl, ...options),\n      metadataUrl: transformImage(this.url, ...options, { format: 'json' }),\n      metadataSignedUrl: transformImage(this.signedUrl, ...options, { format: 'json' })\n    };\n  }\n}\n\nexport type XataArrayFile = Identifiable & XataFile;\n\nexport const parseInputFileEntry = async (entry: InputXataFile): Promise<InputFileEntry | null> => {\n  if (!isDefined(entry)) return null;\n\n  const { id, name, mediaType, base64Content, enablePublicUrl, signedUrlTimeout, uploadUrlTimeout } = await entry;\n  return compactObject({\n    id,\n    // Name cannot be an empty string in our API\n    name: name ? name : undefined,\n    mediaType,\n    base64Content,\n    enablePublicUrl,\n    signedUrlTimeout,\n    uploadUrlTimeout\n  });\n};\n","import { FilterExpression, FilterPredicate } from '../api/schemas';\nimport { isDefined, isObject } from '../util/lang';\nimport { SingleOrArray, Values } from '../util/types';\nimport { JSONValue } from './json';\nimport { ColumnsByValue, ValueAtColumn } from './selection';\n\nexport type JSONFilterColumns<Record> = Values<{\n  [K in keyof Record]: NonNullable<Record[K]> extends JSONValue<any>\n    ? K extends string\n      ? `${K}->${string}`\n      : never\n    : never;\n}>;\n\nexport type FilterColumns<T> = ColumnsByValue<T, any>;\n\nexport type FilterValueAtColumn<Record, F> = NonNullable<ValueAtColumn<Record, F>> extends JSONValue<any>\n  ? PropertyFilter<any>\n  : Filter<NonNullable<ValueAtColumn<Record, F>>>;\n\n/**\n * PropertyMatchFilter\n * Example:\n{\n  \"filter\": {\n    \"name\": \"value\",\n    \"name\": {\n       \"$is\":  \"value\",\n       \"$any\": [ \"value1\", \"value2\" ],\n    },\n  }\n}\n*/\ntype PropertyAccessFilter<Record> = {\n  [key in FilterColumns<Record>]?:\n    | NestedApiFilter<ValueAtColumn<Record, key>>\n    | PropertyFilter<ValueAtColumn<Record, key>>;\n} & {\n  [key in JSONFilterColumns<Record>]?: PropertyFilter<Record[keyof Record]>;\n};\n\nexport type PropertyFilter<T> = T | { $is: T } | { $isNot: T } | { $any: T[] } | { $none: T[] } | ValueTypeFilters<T>;\n\ntype IncludesFilter<T> =\n  | PropertyFilter<T>\n  | {\n      [key in '$all' | '$none' | '$any']?: IncludesFilter<T> | Array<IncludesFilter<T> | { $not: IncludesFilter<T> }>;\n    };\n\nexport type StringTypeFilter = {\n  [key in '$contains' | '$iContains' | '$pattern' | '$iPattern' | '$startsWith' | '$endsWith']?: string;\n};\nexport type ComparableType = number | Date;\nexport type ComparableTypeFilter<T extends ComparableType> = { [key in '$gt' | '$lt' | '$ge' | '$le']?: T };\nexport type ArrayFilter<T> =\n  | {\n      [key in '$includes']?: SingleOrArray<PropertyFilter<T> | ValueTypeFilters<T>> | IncludesFilter<T>;\n    }\n  | {\n      [key in '$includesAll' | '$includesNone' | '$includesAny']?:\n        | T\n        | Array<PropertyFilter<T> | { $not: PropertyFilter<T> }>;\n    };\n\ntype ValueTypeFilters<T> = T | T extends string\n  ? StringTypeFilter\n  : T extends number\n  ? ComparableTypeFilter<number>\n  : T extends Date\n  ? ComparableTypeFilter<Date>\n  : T extends Array<infer T>\n  ? ArrayFilter<T>\n  : never;\n\n/**\n * AggregatorFilter\n * Example:\n{\n  \"filter\": {\n      \"$any\": {\n        \"dark\": true,\n        \"plan\": \"free\"\n      }\n  },\n}\n{\n  \"filter\": {\n    \"$any\": [\n      {\n        \"name\": \"r1\",\n      },\n      {\n        \"name\": \"r2\",\n      },\n    ],\n}\n*/\ntype AggregatorFilter<T> = {\n  [key in '$all' | '$any' | '$not' | '$none']?: SingleOrArray<Filter<T>>;\n};\n\n/**\n * Existance filter\n * Example: { filter: { $exists: \"dark\" } }\n */\nexport type ExistanceFilter<Record> = {\n  [key in '$exists' | '$notExists']?: FilterColumns<Record>;\n};\n\ntype BaseApiFilter<Record> = PropertyAccessFilter<Record> | AggregatorFilter<Record> | ExistanceFilter<Record>;\n\n/**\n * Nested filter\n * Injects the Api filters on nested properties\n * Example: { filter: { settings: { plan: { $any: ['free', 'trial'] } } } }\n */\ntype NestedApiFilter<T> = {\n  [key in keyof T]?: T[key] extends Record<string, any> ? SingleOrArray<Filter<T[key]>> : PropertyFilter<T[key]>;\n};\n\nexport type Filter<T> = T extends Record<string, any>\n  ? T extends (infer ArrayType)[] // Arrays have a special filter\n    ? ArrayType | ArrayType[] | ArrayFilter<ArrayType> | ArrayFilter<ArrayType[]>\n    : T extends Date // Date extends object but we treat it as a primitive\n    ? PropertyFilter<T>\n    : BaseApiFilter<T> | NestedApiFilter<T>\n  : PropertyFilter<T>;\n\nexport function cleanFilter(filter?: FilterExpression | FilterPredicate): any {\n  if (!isDefined(filter)) return undefined;\n  if (!isObject(filter)) return filter;\n\n  const values = Object.fromEntries(\n    Object.entries(filter).reduce((acc, [key, value]) => {\n      // Remove null and undefined values\n      if (!isDefined(value)) return acc;\n\n      if (Array.isArray(value)) {\n        // Remove empty objects from arrays\n        const clean = value.map((item) => cleanFilter(item)).filter((item) => isDefined(item));\n\n        // Remove empty arrays\n        if (clean.length === 0) return acc;\n\n        return [...acc, [key, clean]];\n      }\n\n      if (isObject(value)) {\n        // Remove empty objects\n        const clean = cleanFilter(value);\n        if (!isDefined(clean)) return acc;\n\n        return [...acc, [key, clean]];\n      }\n\n      return [...acc, [key, value]];\n    }, [] as [string, any][])\n  );\n\n  return Object.keys(values).length > 0 ? values : undefined;\n}\n","import { isDefined, isString } from '../util/lang';\n\nexport type JSONValue<Value> = Value & { __json: true };\n\nexport function stringifyJson(value: string): string;\nexport function stringifyJson(value: null): null;\nexport function stringifyJson(value: undefined): undefined;\nexport function stringifyJson(value: string | null | undefined): string | null | undefined;\nexport function stringifyJson(value: any): string | null | undefined;\nexport function stringifyJson(value: any) {\n  if (!isDefined(value)) return value;\n  if (isString(value)) return value;\n\n  try {\n    return JSON.stringify(value);\n  } catch (e) {\n    return value;\n  }\n}\n\nexport function parseJson(value: string) {\n  try {\n    return JSON.parse(value);\n  } catch (e) {\n    return value;\n  }\n}\n","import { isDefined, isObject } from '../util/lang';\nimport { Query } from './query';\nimport { JSONData, XataRecord } from './record';\n\nexport type PaginationQueryMeta = { page: { cursor: string; more: boolean; size: number } };\n\nexport interface Paginable<Record extends XataRecord, Result extends XataRecord = Record> {\n  meta: PaginationQueryMeta;\n  records: PageRecordArray<Result>;\n\n  nextPage(size?: number, offset?: number): Promise<Page<Record, Result>>;\n  previousPage(size?: number, offset?: number): Promise<Page<Record, Result>>;\n  startPage(size?: number, offset?: number): Promise<Page<Record, Result>>;\n  endPage(size?: number, offset?: number): Promise<Page<Record, Result>>;\n\n  hasNextPage(): boolean;\n}\n\n/**\n * A Page contains a set of results from a query plus metadata about the retrieved\n * set of values such as the cursor, required to retrieve additional records.\n */\nexport class Page<Record extends XataRecord, Result extends XataRecord = Record> implements Paginable<Record, Result> {\n  #query: Query<Record, Result>;\n  /**\n   * Page metadata, required to retrieve additional records.\n   */\n  readonly meta: PaginationQueryMeta;\n  /**\n   * The set of results for this page.\n   */\n  readonly records: PageRecordArray<Result>;\n\n  constructor(query: Query<Record, Result>, meta: PaginationQueryMeta, records: Result[] = []) {\n    this.#query = query;\n    this.meta = meta;\n    this.records = new PageRecordArray(this, records);\n  }\n\n  /**\n   * Retrieves the next page of results.\n   * @param size Maximum number of results to be retrieved.\n   * @param offset Number of results to skip when retrieving the results.\n   * @returns The next page or results.\n   */\n  async nextPage(size?: number, offset?: number): Promise<Page<Record, Result>> {\n    return this.#query.getPaginated({ pagination: { size, offset, after: this.meta.page.cursor } });\n  }\n\n  /**\n   * Retrieves the previous page of results.\n   * @param size Maximum number of results to be retrieved.\n   * @param offset Number of results to skip when retrieving the results.\n   * @returns The previous page or results.\n   */\n  async previousPage(size?: number, offset?: number): Promise<Page<Record, Result>> {\n    return this.#query.getPaginated({ pagination: { size, offset, before: this.meta.page.cursor } });\n  }\n\n  /**\n   * Retrieves the start page of results.\n   * @param size Maximum number of results to be retrieved.\n   * @param offset Number of results to skip when retrieving the results.\n   * @returns The start page or results.\n   */\n  async startPage(size?: number, offset?: number): Promise<Page<Record, Result>> {\n    return this.#query.getPaginated({ pagination: { size, offset, start: this.meta.page.cursor } });\n  }\n\n  /**\n   * Retrieves the end page of results.\n   * @param size Maximum number of results to be retrieved.\n   * @param offset Number of results to skip when retrieving the results.\n   * @returns The end page or results.\n   */\n  async endPage(size?: number, offset?: number): Promise<Page<Record, Result>> {\n    return this.#query.getPaginated({ pagination: { size, offset, end: this.meta.page.cursor } });\n  }\n\n  /**\n   * Shortcut method to check if there will be additional results if the next page of results is retrieved.\n   * @returns Whether or not there will be additional results in the next page of results.\n   */\n  hasNextPage(): boolean {\n    return this.meta.page.more;\n  }\n}\n\nexport type CursorNavigationOptions = { start?: string } | { end?: string } | { after?: string; before?: string };\nexport type OffsetNavigationOptions = { size?: number; offset?: number };\n\nexport const PAGINATION_MAX_SIZE = 1000;\nexport const PAGINATION_DEFAULT_SIZE = 20;\nexport const PAGINATION_MAX_OFFSET = 49000;\nexport const PAGINATION_DEFAULT_OFFSET = 0;\n\nexport function isCursorPaginationOptions(\n  options: Record<string, unknown> | undefined | null\n): options is CursorNavigationOptions {\n  return (\n    isDefined(options) &&\n    (isDefined(options.start) || isDefined(options.end) || isDefined(options.after) || isDefined(options.before))\n  );\n}\n\nexport class RecordArray<Result extends XataRecord> extends Array<Result> {\n  constructor(overrideRecords?: Result[]);\n  constructor(...args: any[]) {\n    super(...RecordArray.parseConstructorParams(...args));\n  }\n\n  static parseConstructorParams(...args: any[]) {\n    // new <T>(arrayLength: number): T[]\n    if (args.length === 1 && typeof args[0] === 'number') {\n      return new Array(args[0]);\n    }\n\n    // new <T>(overrideRecords: Array | undefined): T[>]\n    if (args.length <= 1 && Array.isArray(args[0] ?? [])) {\n      const result = args[0] ?? [];\n      return new Array(...result);\n    }\n\n    // <T>(...items: T[]): T[]\n    return new Array(...args);\n  }\n\n  toArray(): Result[] {\n    return new Array(...this);\n  }\n\n  toSerializable(): JSONData<Result>[] {\n    return JSON.parse(this.toString());\n  }\n\n  toString(): string {\n    return JSON.stringify(this.toArray());\n  }\n\n  map<U>(callbackfn: (value: Result, index: number, array: Result[]) => U, thisArg?: any): U[] {\n    return this.toArray().map(callbackfn, thisArg);\n  }\n}\n\nexport class PageRecordArray<Result extends XataRecord> extends Array<Result> {\n  #page: Paginable<Result, Result>;\n\n  constructor(page: Paginable<any, Result>, overrideRecords?: Result[]);\n  constructor(...args: any[]) {\n    super(...PageRecordArray.parseConstructorParams(...args));\n\n    // In the case of serialization/deserialization, the page might be lost\n    this.#page = isObject(args[0]?.meta) ? args[0] : { meta: { page: { cursor: '', more: false } }, records: [] };\n  }\n\n  static parseConstructorParams(...args: any[]) {\n    // new <T>(arrayLength: number): T[]\n    if (args.length === 1 && typeof args[0] === 'number') {\n      return new Array(args[0]);\n    }\n\n    // new <T>(page: Page, overrideRecords: Array | undefined): T[>]\n    if (args.length <= 2 && isObject(args[0]?.meta) && Array.isArray(args[1] ?? [])) {\n      const result = args[1] ?? args[0].records ?? [];\n      return new Array(...result);\n    }\n\n    // <T>(...items: T[]): T[]\n    return new Array(...args);\n  }\n\n  toArray(): Result[] {\n    return new Array(...this);\n  }\n\n  toSerializable(): JSONData<Result>[] {\n    return JSON.parse(this.toString());\n  }\n\n  toString(): string {\n    return JSON.stringify(this.toArray());\n  }\n\n  map<U>(callbackfn: (value: Result, index: number, array: Result[]) => U, thisArg?: any): U[] {\n    return this.toArray().map(callbackfn, thisArg);\n  }\n\n  /**\n   * Retrieve next page of records\n   *\n   * @returns A new array of objects\n   */\n  async nextPage(size?: number, offset?: number): Promise<PageRecordArray<Result>> {\n    const newPage = await this.#page.nextPage(size, offset);\n    return new PageRecordArray(newPage);\n  }\n\n  /**\n   * Retrieve previous page of records\n   *\n   * @returns A new array of objects\n   */\n  async previousPage(size?: number, offset?: number): Promise<PageRecordArray<Result>> {\n    const newPage = await this.#page.previousPage(size, offset);\n    return new PageRecordArray(newPage);\n  }\n\n  /**\n   * Retrieve start page of records\n   *\n   * @returns A new array of objects\n   */\n  async startPage(size?: number, offset?: number): Promise<PageRecordArray<Result>> {\n    const newPage = await this.#page.startPage(size, offset);\n    return new PageRecordArray(newPage);\n  }\n\n  /**\n   * Retrieve end page of records\n   *\n   * @returns A new array of objects\n   */\n  async endPage(size?: number, offset?: number): Promise<PageRecordArray<Result>> {\n    const newPage = await this.#page.endPage(size, offset);\n    return new PageRecordArray(newPage);\n  }\n\n  /**\n   * @returns Boolean indicating if there is a next page\n   */\n  hasNextPage(): boolean {\n    return this.#page.meta.page.more;\n  }\n}\n","import { Schemas } from '../api';\nimport { FilterExpression } from '../api/schemas';\nimport { compact, isDefined, isObject, isString, isStringArray, toBase64 } from '../util/lang';\nimport { Dictionary, OmitBy, RequiredBy, SingleOrArray } from '../util/types';\nimport { Filter, FilterColumns, FilterValueAtColumn, JSONFilterColumns } from './filters';\nimport {\n  CursorNavigationOptions,\n  OffsetNavigationOptions,\n  PAGINATION_DEFAULT_SIZE,\n  PAGINATION_MAX_SIZE,\n  Page,\n  Paginable,\n  PaginationQueryMeta,\n  PageRecordArray,\n  isCursorPaginationOptions,\n  RecordArray\n} from './pagination';\nimport { XataRecord } from './record';\nimport { RestRepository } from './repository';\nimport { SelectableColumn, SelectableColumnWithObjectNotation, SelectedPick } from './selection';\nimport { SortColumns, SortDirection, SortFilter } from './sorting';\nimport { SummarizeExpression, SummarizeParams, SummarizeResult } from './summarize';\n\ntype BaseOptions<T extends XataRecord> = {\n  columns?: SelectableColumnWithObjectNotation<T>[];\n  consistency?: 'strong' | 'eventual';\n  fetchOptions?: Record<string, unknown>;\n};\n\ntype CursorQueryOptions = {\n  pagination?: CursorNavigationOptions & OffsetNavigationOptions;\n  filter?: never;\n  sort?: never;\n};\n\ntype OffsetQueryOptions<T extends XataRecord> = {\n  pagination?: OffsetNavigationOptions;\n  filter?: FilterExpression;\n  sort?: SingleOrArray<SortFilter<T>>;\n};\n\nexport type QueryOptions<T extends XataRecord> = BaseOptions<T> & (CursorQueryOptions | OffsetQueryOptions<T>);\n\n/**\n * Query objects contain the information of all filters, sorting, etc. to be included in the database query.\n *\n * Query objects are immutable. Any method that adds more constraints or options to the query will return\n * a new Query object containing the both the previous and the new constraints and options.\n */\nexport class Query<Record extends XataRecord, Result extends XataRecord = Record> implements Paginable<Record, Result> {\n  #table: { name: string; schema?: Schemas.Table };\n  #repository: RestRepository<Record>;\n  #data: QueryOptions<Record> = { filter: {} };\n\n  // Implements pagination\n  readonly meta: PaginationQueryMeta = { page: { cursor: 'start', more: true, size: PAGINATION_DEFAULT_SIZE } };\n  readonly records: PageRecordArray<Result> = new PageRecordArray<Result>(this, []);\n\n  constructor(\n    repository: RestRepository<Record> | null,\n    table: { name: string; schema?: Schemas.Table },\n    data: Partial<QueryOptions<Record>>,\n    rawParent?: Partial<QueryOptions<Record>>\n  ) {\n    this.#table = table;\n\n    if (repository) {\n      this.#repository = repository;\n    } else {\n      this.#repository = this as any;\n    }\n\n    // Clean parent query options if new query is cursor based\n    const parent = cleanParent(data, rawParent);\n\n    this.#data.filter = data.filter ?? parent?.filter ?? {};\n    this.#data.filter.$any = data.filter?.$any ?? parent?.filter?.$any;\n    this.#data.filter.$all = data.filter?.$all ?? parent?.filter?.$all;\n    this.#data.filter.$not = data.filter?.$not ?? parent?.filter?.$not;\n    this.#data.filter.$none = data.filter?.$none ?? parent?.filter?.$none;\n    this.#data.sort = (data.sort ?? parent?.sort) as QueryOptions<Record>['sort']; // Fix for TS =4.7\n    this.#data.columns = data.columns ?? parent?.columns;\n    this.#data.consistency = data.consistency ?? parent?.consistency;\n    this.#data.pagination = data.pagination ?? parent?.pagination;\n    this.#data.fetchOptions = data.fetchOptions ?? parent?.fetchOptions;\n\n    this.any = this.any.bind(this);\n    this.all = this.all.bind(this);\n    this.not = this.not.bind(this);\n    this.filter = this.filter.bind(this);\n    this.sort = this.sort.bind(this);\n    this.none = this.none.bind(this);\n\n    Object.defineProperty(this, 'table', { enumerable: false });\n    Object.defineProperty(this, 'repository', { enumerable: false });\n  }\n\n  getQueryOptions(): QueryOptions<Record> {\n    return this.#data;\n  }\n\n  key(): string {\n    const { columns = [], filter = {}, sort = [], pagination = {} } = this.#data;\n    const key = JSON.stringify({ columns, filter, sort, pagination });\n    return toBase64(key);\n  }\n\n  /**\n   * Builds a new query object representing a logical OR between the given subqueries.\n   * @param queries An array of subqueries.\n   * @returns A new Query object.\n   */\n  any(...queries: Query<Record, any>[]): Query<Record, Result> {\n    const $any = queries.map((query) => query.getQueryOptions().filter ?? {});\n    return new Query<Record, Result>(this.#repository, this.#table, { filter: { $any } }, this.#data);\n  }\n\n  /**\n   * Builds a new query object representing a logical AND between the given subqueries.\n   * @param queries An array of subqueries.\n   * @returns A new Query object.\n   */\n  all(...queries: Query<Record, any>[]): Query<Record, Result> {\n    const $all = queries.map((query) => query.getQueryOptions().filter ?? {});\n    return new Query<Record, Result>(this.#repository, this.#table, { filter: { $all } }, this.#data);\n  }\n\n  /**\n   * Builds a new query object representing a logical OR negating each subquery. In pseudo-code: !q1 OR !q2\n   * @param queries An array of subqueries.\n   * @returns A new Query object.\n   */\n  not(...queries: Query<Record, any>[]): Query<Record, Result> {\n    const $not = queries.map((query) => query.getQueryOptions().filter ?? {});\n    return new Query<Record, Result>(this.#repository, this.#table, { filter: { $not } }, this.#data);\n  }\n\n  /**\n   * Builds a new query object representing a logical AND negating each subquery. In pseudo-code: !q1 AND !q2\n   * @param queries An array of subqueries.\n   * @returns A new Query object.\n   */\n  none(...queries: Query<Record, any>[]): Query<Record, Result> {\n    const $none = queries.map((query) => query.getQueryOptions().filter ?? {});\n    return new Query<Record, Result>(this.#repository, this.#table, { filter: { $none } }, this.#data);\n  }\n\n  /**\n   * Builds a new query object adding one or more constraints. Examples:\n   *\n   * ```\n   * query.filter(\"columnName\", columnValue)\n   * query.filter(\"columnName\", operator(columnValue)) // Use gt, gte, lt, lte, startsWith,...\n   * ```\n   *\n   * @param column The name of the column to filter.\n   * @param value The value to filter.\n   * @returns A new Query object.\n   */\n  filter<F extends FilterColumns<Record> | JSONFilterColumns<Record>>(\n    column: F,\n    value: FilterValueAtColumn<Record, F>\n  ): Query<Record, Result>;\n\n  /**\n   * Builds a new query object adding one or more constraints. Examples:\n   *\n   * ```\n   * query.filter({ \"columnName\": columnValue })\n   * query.filter({\n   *   \"columnName\": operator(columnValue) // Use gt, gte, lt, lte, startsWith,...\n   * })\n   * ```\n   *\n   * @param filter A filter object\n   * @returns A new Query object.\n   */\n  filter(filter?: Filter<Record>): Query<Record, Result>;\n\n  filter(a: any, b?: any): Query<Record, Result> {\n    if (arguments.length === 1) {\n      const constraints = Object.entries(a ?? {}).map(([column, constraint]) => ({\n        [column]: this.#cleanFilterConstraint(column, constraint) as any\n      }));\n      const $all = compact([this.#data.filter?.$all].flat().concat(constraints));\n\n      return new Query<Record, Result>(this.#repository, this.#table, { filter: { $all } }, this.#data);\n    } else {\n      const constraints = isDefined(a) && isDefined(b) ? [{ [a]: this.#cleanFilterConstraint(a, b) }] : undefined;\n      const $all = compact([this.#data.filter?.$all].flat().concat(constraints));\n\n      return new Query<Record, Result>(this.#repository, this.#table, { filter: { $all } }, this.#data);\n    }\n  }\n\n  #cleanFilterConstraint<T>(column: string, value: T) {\n    const columnType = this.#table.schema?.columns.find(({ name }) => name === column)?.type;\n\n    // TODO: Fix when we support more array types than string\n    if (columnType === 'multiple' && (isString(value) || isStringArray(value))) {\n      return { $includes: value };\n    }\n\n    if (columnType === 'link' && isObject(value) && isString(value.xata_id)) {\n      return value.xata_id;\n    }\n\n    return value;\n  }\n\n  /**\n   * Builds a new query with a new sort option.\n   * @param column The column name.\n   * @param direction The direction. Either ascending or descending.\n   * @returns A new Query object.\n   */\n  sort<F extends SortColumns<Record>>(column: F, direction: SortDirection): Query<Record, Result>;\n  sort(column: '*', direction: 'random'): Query<Record, Result>;\n  sort<F extends SortColumns<Record>>(column: F): Query<Record, Result>;\n  sort(column: string, direction = 'asc'): Query<Record, Result> {\n    const originalSort = [this.#data.sort ?? []].flat() as SortFilter<Record, any>[];\n    const sort = [...originalSort, { column, direction }];\n    return new Query<Record, Result>(this.#repository, this.#table, { sort }, this.#data);\n  }\n\n  /**\n   * Builds a new query specifying the set of columns to be returned in the query response.\n   * @param columns Array of column names to be returned by the query.\n   * @returns A new Query object.\n   */\n  select<K extends SelectableColumnWithObjectNotation<Record>>(columns: K[]) {\n    return new Query<Record, SelectedPick<Record, typeof columns>>(\n      this.#repository,\n      this.#table,\n      { columns },\n      this.#data\n    );\n  }\n\n  /**\n   * Get paginated results\n   *\n   * @returns A page of results\n   */\n  getPaginated(): Promise<Page<Record, Result>>;\n\n  /**\n   * Get paginated results\n   *\n   * @param options Pagination options\n   * @returns A page of results\n   */\n  getPaginated(options: OmitBy<QueryOptions<Record>, 'columns'>): Promise<Page<Record, Result>>;\n\n  /**\n   * Get paginated results\n   *\n   * @param options Pagination options\n   * @returns A page of results\n   */\n  getPaginated<Options extends RequiredBy<QueryOptions<Record>, 'columns'>>(\n    options: Options\n  ): Promise<Page<Record, SelectedPick<Record, (typeof options)['columns']>>>;\n\n  getPaginated<Result extends XataRecord>(options: QueryOptions<Record> = {}): Promise<Page<Record, Result>> {\n    const query = new Query<Record, Result>(this.#repository, this.#table, options, this.#data);\n    return this.#repository.query(query);\n  }\n\n  /**\n   * Get results in an iterator\n   *\n   * @async\n   * @returns Async interable of results\n   */\n  async *[Symbol.asyncIterator](): AsyncIterableIterator<Result> {\n    for await (const [record] of this.getIterator({ batchSize: 1 })) {\n      yield record;\n    }\n  }\n\n  /**\n   * Build an iterator of results\n   *\n   * @returns Async generator of results array\n   */\n  getIterator(): AsyncGenerator<Result[]>;\n\n  /**\n   * Build an iterator of results\n   *\n   * @param options Pagination options with batchSize\n   * @returns Async generator of results array\n   */\n  getIterator(\n    options: OmitBy<QueryOptions<Record>, 'columns' | 'pagination'> & { batchSize?: number }\n  ): AsyncGenerator<Result[]>;\n\n  /**\n   * Build an iterator of results\n   *\n   * @param options Pagination options with batchSize\n   * @returns Async generator of results array\n   */\n  getIterator<\n    Options extends RequiredBy<OmitBy<QueryOptions<Record>, 'pagination'>, 'columns'> & { batchSize?: number }\n  >(options: Options): AsyncGenerator<SelectedPick<Record, (typeof options)['columns']>[]>;\n\n  async *getIterator<Result extends XataRecord>(\n    options: QueryOptions<Record> & { batchSize?: number } = {}\n  ): AsyncGenerator<Result[]> {\n    const { batchSize = 1 } = options;\n\n    let page = await this.getPaginated({ ...options, pagination: { size: batchSize, offset: 0 } });\n    let more = page.hasNextPage();\n\n    yield page.records as unknown as Result[];\n\n    while (more) {\n      page = await page.nextPage();\n      more = page.hasNextPage();\n\n      yield page.records as unknown as Result[];\n    }\n  }\n\n  /**\n   * Performs the query in the database and returns a set of results.\n   * @returns An array of records from the database.\n   */\n  getMany(): Promise<PageRecordArray<Result>>;\n\n  /**\n   * Performs the query in the database and returns a set of results.\n   * @param options Additional options to be used when performing the query.\n   * @returns An array of records from the database.\n   */\n  getMany<Options extends RequiredBy<QueryOptions<Record>, 'columns'>>(\n    options: Options\n  ): Promise<PageRecordArray<SelectedPick<Record, (typeof options)['columns']>>>;\n\n  /**\n   * Performs the query in the database and returns a set of results.\n   * @param options Additional options to be used when performing the query.\n   * @returns An array of records from the database.\n   */\n  getMany(options: OmitBy<QueryOptions<Record>, 'columns'>): Promise<PageRecordArray<Result>>;\n\n  async getMany<Result extends XataRecord>(options: QueryOptions<Record> = {}): Promise<PageRecordArray<Result>> {\n    const { pagination = {}, ...rest } = options;\n    const { size = PAGINATION_DEFAULT_SIZE, offset } = pagination;\n    const batchSize = size <= PAGINATION_MAX_SIZE ? size : PAGINATION_MAX_SIZE;\n\n    let page = await this.getPaginated({ ...rest, pagination: { size: batchSize, offset } });\n    const results = [...page.records];\n\n    while (page.hasNextPage() && results.length < size) {\n      page = await page.nextPage();\n      results.push(...page.records);\n    }\n\n    if (page.hasNextPage() && options.pagination?.size === undefined) {\n      console.trace('Calling getMany does not return all results. Paginate to get all results or call getAll.');\n    }\n\n    const array = new PageRecordArray(page, results.slice(0, size));\n\n    // Method overloading does not provide type inference for the return type.\n    return array as unknown as PageRecordArray<Result>;\n  }\n\n  /**\n   * Performs the query in the database and returns all the results.\n   * Warning: If there are a large number of results, this method can have performance implications.\n   * @returns An array of records from the database.\n   */\n  getAll(): Promise<RecordArray<Result>>;\n\n  /**\n   * Performs the query in the database and returns all the results.\n   * Warning: If there are a large number of results, this method can have performance implications.\n   * @param options Additional options to be used when performing the query.\n   * @returns An array of records from the database.\n   */\n  getAll<Options extends RequiredBy<OmitBy<QueryOptions<Record>, 'pagination'>, 'columns'> & { batchSize?: number }>(\n    options: Options\n  ): Promise<RecordArray<SelectedPick<Record, (typeof options)['columns']>>>;\n\n  /**\n   * Performs the query in the database and returns all the results.\n   * Warning: If there are a large number of results, this method can have performance implications.\n   * @param options Additional options to be used when performing the query.\n   * @returns An array of records from the database.\n   */\n  getAll(\n    options: OmitBy<QueryOptions<Record>, 'columns' | 'pagination'> & { batchSize?: number }\n  ): Promise<RecordArray<Result>>;\n\n  async getAll<Result extends XataRecord>(\n    options: QueryOptions<Record> & { batchSize?: number } = {}\n  ): Promise<RecordArray<Result>> {\n    const { batchSize = PAGINATION_MAX_SIZE, ...rest } = options;\n    const results = [];\n\n    for await (const page of this.getIterator({ ...rest, batchSize })) {\n      results.push(...page);\n    }\n\n    // Method overloading does not provide type inference for the return type.\n    return new RecordArray(results) as unknown as RecordArray<Result>;\n  }\n\n  /**\n   * Performs the query in the database and returns the first result.\n   * @returns The first record that matches the query, or null if no record matched the query.\n   */\n  getFirst(): Promise<Result | null>;\n\n  /**\n   * Performs the query in the database and returns the first result.\n   * @param options Additional options to be used when performing the query.\n   * @returns The first record that matches the query, or null if no record matched the query.\n   */\n  getFirst<Options extends RequiredBy<OmitBy<QueryOptions<Record>, 'pagination'>, 'columns'>>(\n    options: Options\n  ): Promise<SelectedPick<Record, (typeof options)['columns']> | null>;\n\n  /**\n   * Performs the query in the database and returns the first result.\n   * @param options Additional options to be used when performing the query.\n   * @returns The first record that matches the query, or null if no record matched the query.\n   */\n  getFirst(options: OmitBy<QueryOptions<Record>, 'columns' | 'pagination'>): Promise<Result | null>;\n\n  async getFirst<Result extends XataRecord>(options: QueryOptions<Record> = {}): Promise<Result | null> {\n    const records = await this.getMany({ ...options, pagination: { size: 1 } });\n\n    // Method overloading does not provide type inference for the return type.\n    return (records[0] as unknown as Result) ?? null;\n  }\n\n  /**\n   * Performs the query in the database and returns the first result.\n   * @returns The first record that matches the query, or null if no record matched the query.\n   * @throws if there are no results.\n   */\n  getFirstOrThrow(): Promise<Result>;\n\n  /**\n   * Performs the query in the database and returns the first result.\n   * @param options Additional options to be used when performing the query.\n   * @returns The first record that matches the query, or null if no record matched the query.\n   * @throws if there are no results.\n   */\n  getFirstOrThrow<Options extends RequiredBy<OmitBy<QueryOptions<Record>, 'pagination'>, 'columns'>>(\n    options: Options\n  ): Promise<SelectedPick<Record, (typeof options)['columns']>>;\n\n  /**\n   * Performs the query in the database and returns the first result.\n   * @param options Additional options to be used when performing the query.\n   * @returns The first record that matches the query, or null if no record matched the query.\n   * @throws if there are no results.\n   */\n  getFirstOrThrow(options: OmitBy<QueryOptions<Record>, 'columns' | 'pagination'>): Promise<Result>;\n\n  async getFirstOrThrow<Result extends XataRecord>(options: QueryOptions<Record> = {}): Promise<Result> {\n    const records = await this.getMany({ ...options, pagination: { size: 1 } });\n    if (records[0] === undefined) throw new Error('No results found.');\n\n    // Method overloading does not provide type inference for the return type.\n    return records[0] as unknown as Result;\n  }\n\n  async summarize<\n    Expression extends Dictionary<SummarizeExpression<Record>>,\n    Columns extends SelectableColumn<Record>[]\n  >(params: SummarizeParams<Record, Expression, Columns> = {}): Promise<SummarizeResult<Record, Expression, Columns>> {\n    const { summaries, summariesFilter, ...options } = params;\n    const query = new Query<Record, Result>(\n      this.#repository,\n      this.#table,\n      options as Partial<QueryOptions<Record>>,\n      this.#data\n    );\n\n    return this.#repository.summarizeTable(query, summaries, summariesFilter as Schemas.FilterExpression) as any;\n  }\n\n  /**\n   * Retrieve next page of records\n   *\n   * @returns A new page object.\n   */\n  nextPage(size?: number, offset?: number): Promise<Page<Record, Result>> {\n    return this.startPage(size, offset);\n  }\n\n  /**\n   * Retrieve previous page of records\n   *\n   * @returns A new page object\n   */\n  previousPage(size?: number, offset?: number): Promise<Page<Record, Result>> {\n    return this.startPage(size, offset);\n  }\n\n  /**\n   * Retrieve start page of records\n   *\n   * @returns A new page object\n   */\n  startPage(size?: number, offset?: number): Promise<Page<Record, Result>> {\n    return this.getPaginated({ pagination: { size, offset } });\n  }\n\n  /**\n   * Retrieve last page of records\n   *\n   * @returns A new page object\n   */\n  endPage(size?: number, offset?: number): Promise<Page<Record, Result>> {\n    return this.getPaginated({ pagination: { size, offset, before: 'end' } });\n  }\n\n  /**\n   * @returns Boolean indicating if there is a next page\n   */\n  hasNextPage(): boolean {\n    return this.meta.page.more;\n  }\n}\n\n// When using cursor based pagination, it is not allowed to send new sorting/filtering\n// We removed the sorting/filtering from the query options to avoid the error from the API\nfunction cleanParent<Record extends XataRecord>(\n  data: Partial<QueryOptions<Record>>,\n  parent?: Partial<QueryOptions<Record>>\n) {\n  if (isCursorPaginationOptions(data.pagination)) {\n    return { ...parent, sort: undefined, filter: undefined };\n  }\n\n  return parent;\n}\n","import { isObject, isString } from '../util/lang';\nimport { ExclusiveOr } from '../util/types';\nimport { XataArrayFile, XataFile } from './files';\nimport { SelectableColumn, SelectedPick } from './selection';\n\nexport const RecordColumnTypes = [\n  'bool',\n  'int',\n  'float',\n  'string',\n  'text',\n  'email',\n  'multiple',\n  'link',\n  'datetime',\n  'vector',\n  'file[]',\n  'file',\n  'json'\n] as const;\n\nexport type Identifier = string;\n\n/**\n * Represents an identifiable record from the database.\n */\nexport interface Identifiable {\n  /**\n   * Unique id of this record.\n   */\n  xata_id: Identifier;\n}\n\nexport interface BaseData {\n  [key: string]: any;\n}\n\n/**\n * Represents a persisted record from the database.\n */\nexport interface XataRecord<OriginalRecord extends XataRecord<any> = XataRecord<any>> extends Identifiable {\n  /**\n   * Get an object representation of this record.\n   */\n  toSerializable(): JSONData<OriginalRecord>;\n\n  /**\n   * Get a string representation of this record.\n   */\n  toString(): string;\n\n  /**\n   * Retrieves a refreshed copy of the current record from the database.\n   * @param columns The columns to retrieve. If not specified, all first level properties are retrieved.\n   * @returns The persisted record with the selected columns, null if not found.\n   */\n  read<K extends SelectableColumn<OriginalRecord>>(\n    columns: K[]\n  ): Promise<Readonly<SelectedPick<OriginalRecord, typeof columns>> | null>;\n\n  /**\n   * Retrieves a refreshed copy of the current record from the database.\n   * @returns The persisted record with all first level properties, null if not found.\n   */\n  read(): Promise<Readonly<SelectedPick<OriginalRecord, ['*']>> | null>;\n\n  /**\n   * Performs a partial update of the current record. On success a new object is\n   * returned and the current object is not mutated.\n   * @param partialUpdate The columns and their values that have to be updated.\n   * @param columns The columns to retrieve. If not specified, all first level properties are retrieved.\n   * @returns The persisted record with the selected columns, null if not found.\n   */\n  update<K extends SelectableColumn<OriginalRecord>>(\n    partialUpdate: Partial<EditableData<OriginalRecord>>,\n    columns: K[],\n    options?: { ifVersion?: number }\n  ): Promise<Readonly<SelectedPick<OriginalRecord, typeof columns>> | null>;\n\n  /**\n   * Performs a partial update of the current record. On success a new object is\n   * returned and the current object is not mutated.\n   * @param partialUpdate The columns and their values that have to be updated.\n   * @returns The persisted record with all first level properties, null if not found.\n   */\n  update(\n    partialUpdate: Partial<EditableData<OriginalRecord>>,\n    options?: { ifVersion?: number }\n  ): Promise<Readonly<SelectedPick<OriginalRecord, ['*']>> | null>;\n\n  /**\n   * Performs a replace of the current record. On success a new object is\n   * returned and the current object is not mutated.\n   * @param partialUpdate The columns and their values that have to be updated.\n   * @param columns The columns to retrieve. If not specified, all first level properties are retrieved.\n   * @returns The persisted record with the selected columns, null if not found.\n   */\n  replace<K extends SelectableColumn<OriginalRecord>>(\n    object: Partial<EditableData<OriginalRecord>>,\n    columns: K[],\n    options?: { ifVersion?: number }\n  ): Promise<Readonly<SelectedPick<OriginalRecord, typeof columns>> | null>;\n\n  /**\n   * Performs a replace of the current record. On success a new object is\n   * returned and the current object is not mutated.\n   * @param partialUpdate The columns and their values that have to be updated.\n   * @returns The persisted record with all first level properties, null if not found.\n   */\n  replace(\n    object: Partial<EditableData<OriginalRecord>>,\n    options?: { ifVersion?: number }\n  ): Promise<Readonly<SelectedPick<OriginalRecord, ['*']>> | null>;\n\n  /**\n   * Performs a deletion of the current record in the database.\n   * @param columns The columns to retrieve. If not specified, all first level properties are retrieved.\n   * @returns The deleted record, null if not found.\n   */\n  delete<K extends SelectableColumn<OriginalRecord>>(\n    columns: K[]\n  ): Promise<Readonly<SelectedPick<OriginalRecord, typeof columns>> | null>;\n\n  /**\n   * Performs a deletion of the current record in the database.\n   * @returns The deleted record, null if not found.\n\n   */\n  delete(): Promise<Readonly<SelectedPick<OriginalRecord, ['*']>> | null>;\n}\n\nexport type Link<Record extends XataRecord> = XataRecord<Record>;\n\nexport function isIdentifiable(x: any): x is Identifiable & Record<string, unknown> {\n  return isObject(x) && isString(x?.xata_id);\n}\n\ntype NumericOperator = ExclusiveOr<\n  { $increment: number },\n  ExclusiveOr<{ $decrement: number }, ExclusiveOr<{ $multiply: number }, { $divide: number }>>\n>;\n\nexport type InputXataFile = Partial<XataArrayFile> | Promise<Partial<XataArrayFile>>;\n\ntype EditableDataFields<T> = T extends XataRecord\n  ? { xata_id: Identifier } | Identifier\n  : NonNullable<T> extends XataRecord\n  ? { xata_id: Identifier } | Identifier | null | undefined\n  : T extends Date\n  ? string | Date\n  : NonNullable<T> extends Date\n  ? string | Date | null | undefined\n  : T extends XataFile\n  ? InputXataFile\n  : T extends XataFile[]\n  ? InputXataFile[]\n  : T extends number\n  ? number | NumericOperator\n  : T;\n\nexport type EditableData<O extends XataRecord> = Identifiable &\n  Partial<\n    Omit<\n      {\n        [K in keyof O]: EditableDataFields<O[K]>;\n      },\n      keyof XataRecord\n    >\n  >;\n\ntype JSONDataFile = {\n  [K in keyof XataFile]: XataFile[K] extends Function ? never : XataFile[K];\n};\n\ntype JSONDataFields<T> = T extends null | undefined | void\n  ? null | undefined\n  : T extends XataFile\n  ? JSONDataFile\n  : NonNullable<T> extends XataFile\n  ? JSONDataFile | null | undefined\n  : T extends XataRecord\n  ? JSONData<T>\n  : NonNullable<T> extends XataRecord\n  ? JSONData<T> | null | undefined\n  : T extends Date\n  ? string\n  : NonNullable<T> extends Date\n  ? string | null | undefined\n  : T;\n\ntype JSONDataBase = Identifiable & {\n  /**\n   * Timestamp when the record was created.\n   */\n  xata_createdat: string;\n  /**\n   * Timestamp when the record was last updated.\n   */\n  xata_updatedat: string;\n  /**\n   * Number that is increased every time the record is updated.\n   */\n  xata_version: number;\n};\n\nexport type JSONData<O> = JSONDataBase &\n  Partial<\n    Omit<\n      {\n        [K in keyof O]: JSONDataFields<O[K]>;\n      },\n      keyof XataRecord\n    >\n  >;\n","import { isObject, isString } from '../util/lang';\nimport { If, IsArray, IsObject, StringKeys, UnionToIntersection, Values } from '../util/types';\nimport { XataArrayFile, XataFile, XataFileFields } from './files';\nimport { Link, XataRecord } from './record';\n\n// Public: Utility type to get a union with the selectable columns of an object\nexport type SelectableColumn<O, RecursivePath extends any[] = []> =\n  // Alias for any property\n  | '*'\n  // Properties of the current level\n  | DataProps<O>\n  // Nested properties of the lower levels\n  | NestedColumns<O, RecursivePath>;\n\ntype ExpandedColumnNotation = {\n  name: string;\n  columns?: SelectableColumn<any>[];\n  as?: string;\n  limit?: number;\n  offset?: number;\n  order?: { column: string; order: 'asc' | 'desc' }[];\n};\n\n// Right now, we only support object notation in queryTable endpoint\n// Once we support it in other endpoints, we can remove this and use SelectableColumn<O> instead\nexport type SelectableColumnWithObjectNotation<O, RecursivePath extends any[] = []> =\n  | SelectableColumn<O, RecursivePath>\n  | ExpandedColumnNotation;\n\nexport function isValidExpandedColumn(column: any): column is ExpandedColumnNotation {\n  return isObject(column) && isString(column.name);\n}\n\nexport function isValidSelectableColumns(columns: any): columns is SelectableColumn<any>[] {\n  if (!Array.isArray(columns)) {\n    return false;\n  }\n\n  return columns.every((column) => {\n    if (typeof column === 'string') {\n      return true;\n    }\n\n    if (typeof column === 'object') {\n      return isValidExpandedColumn(column);\n    }\n\n    return false;\n  });\n}\n\ntype StringColumns<T> = T extends string ? T : never;\ntype ProjectionColumns<T> = T extends string\n  ? never\n  : T extends { as: infer As }\n  ? NonNullable<As> extends string\n    ? NonNullable<As>\n    : never\n  : never;\n\n// Private: Returns columns ending with a wildcard\ntype WildcardColumns<O> = Values<{\n  [K in SelectableColumn<O>]: K extends `${string}*` ? K : never;\n}>;\n\n// Public: Utility type to get a union with the selectable columns of an object by a given type\nexport type ColumnsByValue<O, Value> = Values<{\n  [K in SelectableColumn<O>]: ValueAtColumn<O, K> extends infer C\n    ? C extends Value\n      ? K extends WildcardColumns<O>\n        ? never\n        : K\n      : never\n    : never;\n}>;\n\n// Public: Utility type to get the XataRecord built from a list of selected columns\nexport type SelectedPick<O extends XataRecord, Key extends SelectableColumnWithObjectNotation<O>[]> = XataRecord<O> &\n  // For each column, we get its nested value and join it as an intersection\n  UnionToIntersection<\n    Values<{\n      [K in StringColumns<Key[number]>]: NestedValueAtColumn<O, K> & XataRecord<O>;\n    }>\n  > &\n  // For each column projection, we get its nested value and join it as an intersection\n  // The typings here are a bit tricky, but it works, can definetely be improved\n  UnionToIntersection<\n    Values<{\n      [K in ProjectionColumns<Key[number]>]: { [Key in K]: { records: (Record<string, any> & XataRecord<O>)[] } };\n    }>\n  >;\n\n// Public: Utility type to get the value of a column at a given path\nexport type ValueAtColumn<Obj, Key, RecursivePath extends any[] = []> = RecursivePath['length'] extends MAX_RECURSION\n  ? never\n  : Key extends '*'\n  ? Values<Obj> // Alias for any property\n  : Key extends keyof Obj\n  ? Obj[Key] // Properties of the current level\n  : Key extends `${infer K}.${infer V}`\n  ? K extends keyof Obj\n    ? Values<\n        NonNullable<Obj[K]> extends infer Item\n          ? Item extends Record<string, any>\n            ? V extends SelectableColumn<Item>\n              ? { V: ValueAtColumn<Item, V, [...RecursivePath, Item]> }\n              : never\n            : Obj[K]\n          : never\n      >\n    : never\n  : never;\n\n// Private: To avoid circular dependencies, we limit the recursion depth\ntype MAX_RECURSION = 3;\n\n// Private: Utility type to get a union with the columns below the current level\n// Exclude type in union: never\ntype NestedColumns<O, RecursivePath extends any[]> = RecursivePath['length'] extends MAX_RECURSION\n  ? never\n  : If<\n      IsObject<O>,\n      Values<{\n        [K in DataProps<O>]: NonNullable<O[K]> extends infer Item\n          ? If<\n              IsArray<Item>,\n              Item extends (infer Type)[]\n                ? Type extends XataArrayFile\n                  ? K | `${K}.${keyof XataFileFields | '*'}`\n                  : K | `${K}.${StringKeys<Type> | '*'}`\n                : never,\n              If<\n                IsObject<Item>,\n                Item extends XataRecord\n                  ? SelectableColumn<Item, [...RecursivePath, Item]> extends infer Column\n                    ? Column extends string\n                      ? K | `${K}.${Column}`\n                      : never\n                    : never\n                  : Item extends Date\n                  ? K\n                  : Item extends XataFile\n                  ? K | `${K}.${keyof XataFileFields | '*'}` // This allows usage of objects that are not links\n                  : `${K}.${StringKeys<Item> | '*'}`, // This allows usage of objects that are not links\n                K\n              >\n            >\n          : never;\n      }>,\n      never\n    >;\n\n// Private: Utility type to get object properties without XataRecord ones\ntype DataProps<O> = Exclude<StringKeys<O>, StringKeys<Omit<XataRecord, 'xata_id'>>>;\n\n// Private: Utility type to get the value of a column at a given path (nested object value)\n// For \"foo.bar.baz\" we return { foo: { bar: { baz: type } } }\ntype NestedValueAtColumn<O, Key extends SelectableColumn<O>> =\n  // If a column is a nested property, infer N and M\n  Key extends `${infer N}.${infer M}`\n    ? N extends DataProps<O>\n      ? {\n          [K in N]: M extends SelectableColumn<NonNullable<O[K]>>\n            ? NonNullable<O[K]> extends XataFile\n              ? ForwardNullable<O[K], XataFile>\n              : NonNullable<O[K]> extends XataRecord\n              ? ForwardNullable<O[K], NestedValueAtColumn<NonNullable<O[K]>, M> & XataRecord>\n              : ForwardNullable<O[K], NestedValueAtColumn<NonNullable<O[K]>, M>>\n            : NonNullable<O[K]> extends (infer ArrayType)[]\n            ? ArrayType extends XataArrayFile\n              ? ForwardNullable<O[K], XataArrayFile[]>\n              : M extends SelectableColumn<NonNullable<ArrayType>>\n              ? ForwardNullable<O[K], NestedValueAtColumn<NonNullable<ArrayType>, M>[]>\n              : unknown //`Property ${M} is not selectable on type ${ArrayType}`\n            : unknown; //`Property ${M} is not selectable on type ${K}`\n        }\n      : unknown //`Property ${N} is not a property of type ${O}`\n    : Key extends DataProps<O>\n    ? {\n        [K in Key]: NonNullable<O[K]> extends XataRecord\n          ? // If the property is a link, we forward the type of the internal XataRecord\n            // Since it can be nullable, we use ForwardNullable to avoid loosing the internal type\n            // Links that are not expanded [\"link\"] instead of [\"link.*\"] don't have the xata property\n            ForwardNullable<O[K], SelectedPick<NonNullable<O[K]>, ['*']>>\n          : O[K];\n      }\n    : Key extends '*'\n    ? {\n        [K in StringKeys<O>]: NonNullable<O[K]> extends XataRecord\n          ? ForwardNullable<O[K], Link<NonNullable<O[K]>>> // Link forwards read/update method signatures to avoid loosing the internal type\n          : O[K];\n      }\n    : unknown; //`Property ${Key} is invalid`;\n\ntype ForwardNullable<T, R> = T extends NonNullable<T> ? R : R | null;\n","import { isObject, isString } from '../util/lang';\nimport { SingleOrArray, Values } from '../util/types';\nimport { XataRecord } from './record';\nimport { ColumnsByValue } from './selection';\n\nexport type SortDirection = 'asc' | 'desc';\n\ntype RandomFilter = { '*': 'random' };\ntype RandomFilterExtended = { column: '*'; direction: 'random' };\n\nexport type SortColumns<T extends XataRecord> = ColumnsByValue<T, any>;\n\nexport type SortFilterExtended<T extends XataRecord, Columns extends string = SortColumns<T>> =\n  | RandomFilterExtended\n  | {\n      column: Columns;\n      direction?: SortDirection;\n    };\n\nexport type SortFilter<T extends XataRecord, Columns extends string = SortColumns<T>> =\n  | Columns\n  | SortFilterExtended<T, Columns>\n  | SortFilterBase<T, Columns>\n  | RandomFilter;\n\ntype SortFilterBase<T extends XataRecord, Columns extends string = SortColumns<T>> = Values<{\n  [Key in Columns]: { [K in Key]: SortDirection };\n}>;\n\nexport type ApiSortFilter<T extends XataRecord, Columns extends string = SortColumns<T>> = SingleOrArray<\n  | RandomFilter\n  | Values<{\n      [Key in Columns]: { [K in Key]: SortDirection };\n    }>\n>;\n\nexport function isSortFilterString<T extends XataRecord>(value: any): value is SortColumns<T> {\n  return isString(value);\n}\n\nexport function isSortFilterBase<T extends XataRecord>(filter: SortFilter<T, any>): filter is SortFilterBase<T> {\n  return (\n    isObject(filter) &&\n    Object.entries(filter).every(([key, value]) => {\n      // Check for the random sorting operator\n      if (key === '*') return value === 'random';\n\n      return value === 'asc' || value === 'desc';\n    })\n  );\n}\n\nexport function isSortFilterObject<T extends XataRecord>(filter: SortFilter<T, any>): filter is SortFilterExtended<T> {\n  return isObject(filter) && !isSortFilterBase(filter) && filter.column !== undefined;\n}\n\nexport function buildSortFilter<T extends XataRecord>(\n  filter: SingleOrArray<SortFilter<T, any>>\n): ApiSortFilter<T, any> {\n  if (isSortFilterString(filter)) {\n    return { [filter]: 'asc' } as { [key in SortColumns<T>]: SortDirection };\n  } else if (Array.isArray(filter)) {\n    return filter.map((item) => buildSortFilter(item)) as { [key in SortColumns<T>]: SortDirection }[];\n  } else if (isSortFilterBase(filter)) {\n    return filter as { [key in SortColumns<T>]: SortDirection };\n  } else if (isSortFilterObject(filter)) {\n    return { [filter.column]: filter.direction ?? 'asc' } as { [key in SortColumns<T>]: SortDirection };\n  } else {\n    throw new Error(`Invalid sort filter: ${filter}`);\n  }\n}\n","import { SchemaPluginResult } from '.';\nimport {\n  ApiExtraProps,\n  Schemas,\n  aggregateTable,\n  askTableSession,\n  branchTransaction,\n  deleteRecord,\n  getBranchDetails,\n  getRecord,\n  insertRecord,\n  insertRecordWithID,\n  queryTable,\n  searchTable,\n  summarizeTable,\n  updateRecordWithID,\n  upsertRecordWithID,\n  vectorSearchTable\n} from '../api';\nimport { fetchSSERequest } from '../api/fetcher';\nimport {\n  FuzzinessExpression,\n  HighlightExpression,\n  PrefixExpression,\n  SearchPageConfig,\n  TransactionOperation\n} from '../api/schemas';\nimport { XataPluginOptions } from '../plugins';\nimport { SearchXataRecord, TotalCount } from '../search';\nimport { Boosters } from '../search/boosters';\nimport { TargetColumn } from '../search/target';\nimport { chunk, compact, isDefined, isNumber, isObject, isString, promiseMap } from '../util/lang';\nimport { Dictionary } from '../util/types';\nimport { generateUUID } from '../util/uuid';\nimport { VERSION } from '../version';\nimport { AggregationExpression, AggregationResult } from './aggregate';\nimport { AskOptions, AskResult } from './ask';\nimport { XataArrayFile, XataFile, parseInputFileEntry } from './files';\nimport { Filter, cleanFilter } from './filters';\nimport { parseJson, stringifyJson } from './json';\nimport { Page } from './pagination';\nimport { Query } from './query';\nimport { EditableData, Identifiable, Identifier, InputXataFile, XataRecord, isIdentifiable } from './record';\nimport {\n  ColumnsByValue,\n  SelectableColumn,\n  SelectableColumnWithObjectNotation,\n  SelectedPick,\n  isValidSelectableColumns\n} from './selection';\nimport { buildSortFilter } from './sorting';\nimport { SummarizeExpression } from './summarize';\nimport { AttributeDictionary, TraceAttributes, TraceFunction, defaultTrace } from './tracing';\n\nconst BULK_OPERATION_MAX_SIZE = 1000;\n\n/**\n * Common interface for performing operations on a table.\n */\nexport abstract class Repository<Record extends XataRecord> extends Query<\n  Record,\n  Readonly<SelectedPick<Record, ['*']>>\n> {\n  /*\n   * Creates a single record in the table.\n   * @param object Object containing the column names with their values to be stored in the table.\n   * @param columns Array of columns to be returned. If not specified, first level columns will be returned.\n   * @returns The full persisted record.\n   */\n  abstract create<K extends SelectableColumn<Record>>(\n    object: Omit<EditableData<Record>, 'xata_id'> & Partial<Identifiable>,\n    columns: K[],\n    options?: { ifVersion?: number }\n  ): Promise<Readonly<SelectedPick<Record, typeof columns>>>;\n\n  /*\n   * Creates a single record in the table.\n   * @param object Object containing the column names with their values to be stored in the table.\n   * @returns The full persisted record.\n   */\n  abstract create(\n    object: Omit<EditableData<Record>, 'xata_id'> & Partial<Identifiable>,\n    options?: { ifVersion?: number }\n  ): Promise<Readonly<SelectedPick<Record, ['*']>>>;\n\n  /**\n   * Creates a single record in the table with a unique id.\n   * @param id The unique id.\n   * @param object Object containing the column names with their values to be stored in the table.\n   * @param columns Array of columns to be returned. If not specified, first level columns will be returned.\n   * @returns The full persisted record.\n   */\n  abstract create<K extends SelectableColumn<Record>>(\n    id: Identifier,\n    object: Omit<EditableData<Record>, 'xata_id'>,\n    columns: K[],\n    options?: { ifVersion?: number }\n  ): Promise<Readonly<SelectedPick<Record, typeof columns>>>;\n\n  /**\n   * Creates a single record in the table with a unique id.\n   * @param id The unique id.\n   * @param object Object containing the column names with their values to be stored in the table.\n   * @returns The full persisted record.\n   */\n  abstract create(\n    id: Identifier,\n    object: Omit<EditableData<Record>, 'xata_id'>,\n    options?: { ifVersion?: number }\n  ): Promise<Readonly<SelectedPick<Record, ['*']>>>;\n\n  /**\n   * Creates multiple records in the table.\n   * @param objects Array of objects with the column names and the values to be stored in the table.\n   * @param columns Array of columns to be returned. If not specified, first level columns will be returned.\n   * @returns Array of the persisted records in order.\n   */\n  abstract create<K extends SelectableColumn<Record>>(\n    objects: Array<Omit<EditableData<Record>, 'xata_id'> & Partial<Identifiable>>,\n    columns: K[]\n  ): Promise<Readonly<SelectedPick<Record, typeof columns>>[]>;\n\n  /**\n   * Creates multiple records in the table.\n   * @param objects Array of objects with the column names and the values to be stored in the table.\n   * @returns Array of the persisted records in order.\n   */\n  abstract create(\n    objects: Array<Omit<EditableData<Record>, 'xata_id'> & Partial<Identifiable>>\n  ): Promise<Readonly<SelectedPick<Record, ['*']>>[]>;\n\n  /**\n   * Queries a single record from the table given its unique id.\n   * @param id The unique id.\n   * @param columns Array of columns to be returned. If not specified, first level columns will be returned.\n   * @returns The persisted record for the given id or null if the record could not be found.\n   */\n  abstract read<K extends SelectableColumn<Record>>(\n    id: Identifier,\n    columns: K[]\n  ): Promise<Readonly<SelectedPick<Record, typeof columns> | null>>;\n\n  /**\n   * Queries a single record from the table given its unique id.\n   * @param id The unique id.\n   * @returns The persisted record for the given id or null if the record could not be found.\n   */\n  abstract read(id: Identifier): Promise<Readonly<SelectedPick<Record, ['*']> | null>>;\n\n  /**\n   * Queries multiple records from the table given their unique id.\n   * @param ids The unique ids array.\n   * @param columns Array of columns to be returned. If not specified, first level columns will be returned.\n   * @returns The persisted records for the given ids in order (if a record could not be found null is returned).\n   */\n  abstract read<K extends SelectableColumn<Record>>(\n    ids: ReadonlyArray<Identifier>,\n    columns: K[]\n  ): Promise<Array<Readonly<SelectedPick<Record, typeof columns>> | null>>;\n\n  /**\n   * Queries multiple records from the table given their unique id.\n   * @param ids The unique ids array.\n   * @returns The persisted records for the given ids in order (if a record could not be found null is returned).\n   */\n  abstract read(ids: ReadonlyArray<Identifier>): Promise<Array<Readonly<SelectedPick<Record, ['*']>> | null>>;\n\n  /**\n   * Queries a single record from the table by the id in the object.\n   * @param object Object containing the id of the record.\n   * @param columns Array of columns to be returned. If not specified, first level columns will be returned.\n   * @returns The persisted record for the given id or null if the record could not be found.\n   */\n  abstract read<K extends SelectableColumn<Record>>(\n    object: Identifiable,\n    columns: K[]\n  ): Promise<Readonly<SelectedPick<Record, typeof columns> | null>>;\n\n  /**\n   * Queries a single record from the table by the id in the object.\n   * @param object Object containing the id of the record.\n   * @returns The persisted record for the given id or null if the record could not be found.\n   */\n  abstract read(object: Identifiable): Promise<Readonly<SelectedPick<Record, ['*']> | null>>;\n\n  /**\n   * Queries multiple records from the table by the ids in the objects.\n   * @param objects Array of objects containing the ids of the records.\n   * @param columns Array of columns to be returned. If not specified, first level columns will be returned.\n   * @returns The persisted records for the given ids in order (if a record could not be found null is returned).\n   */\n  abstract read<K extends SelectableColumn<Record>>(\n    objects: Identifiable[],\n    columns: K[]\n  ): Promise<Array<Readonly<SelectedPick<Record, typeof columns>> | null>>;\n\n  /**\n   * Queries multiple records from the table by the ids in the objects.\n   * @param objects Array of objects containing the ids of the records.\n   * @returns The persisted records for the given ids in order (if a record could not be found null is returned).\n   */\n  abstract read(objects: Identifiable[]): Promise<Array<Readonly<SelectedPick<Record, ['*']>> | null>>;\n\n  /**\n   * Queries a single record from the table given its unique id.\n   * @param id The unique id.\n   * @param columns Array of columns to be returned. If not specified, first level columns will be returned.\n   * @returns The persisted record for the given id.\n   * @throws If the record could not be found.\n   */\n  abstract readOrThrow<K extends SelectableColumn<Record>>(\n    id: Identifier,\n    columns: K[]\n  ): Promise<Readonly<SelectedPick<Record, typeof columns>>>;\n\n  /**\n   * Queries a single record from the table given its unique id.\n   * @param id The unique id.\n   * @returns The persisted record for the given id.\n   * @throws If the record could not be found.\n   */\n  abstract readOrThrow(id: Identifier): Promise<Readonly<SelectedPick<Record, ['*']>>>;\n\n  /**\n   * Queries multiple records from the table given their unique id.\n   * @param ids The unique ids array.\n   * @param columns Array of columns to be returned. If not specified, first level columns will be returned.\n   * @returns The persisted records for the given ids in order.\n   * @throws If one or more records could not be found.\n   */\n  abstract readOrThrow<K extends SelectableColumn<Record>>(\n    ids: ReadonlyArray<Identifier>,\n    columns: K[]\n  ): Promise<Array<Readonly<SelectedPick<Record, typeof columns>>>>;\n\n  /**\n   * Queries multiple records from the table given their unique id.\n   * @param ids The unique ids array.\n   * @returns The persisted records for the given ids in order.\n   * @throws If one or more records could not be found.\n   */\n  abstract readOrThrow(ids: ReadonlyArray<Identifier>): Promise<Array<Readonly<SelectedPick<Record, ['*']>>>>;\n\n  /**\n   * Queries a single record from the table by the id in the object.\n   * @param object Object containing the id of the record.\n   * @param columns Array of columns to be returned. If not specified, first level columns will be returned.\n   * @returns The persisted record for the given id.\n   * @throws If the record could not be found.\n   */\n  abstract readOrThrow<K extends SelectableColumn<Record>>(\n    object: Identifiable,\n    columns: K[]\n  ): Promise<Readonly<SelectedPick<Record, typeof columns>>>;\n\n  /**\n   * Queries a single record from the table by the id in the object.\n   * @param object Object containing the id of the record.\n   * @returns The persisted record for the given id.\n   * @throws If the record could not be found.\n   */\n  abstract readOrThrow(object: Identifiable): Promise<Readonly<SelectedPick<Record, ['*']>>>;\n\n  /**\n   * Queries multiple records from the table by the ids in the objects.\n   * @param objects Array of objects containing the ids of the records.\n   * @param columns Array of columns to be returned. If not specified, first level columns will be returned.\n   * @returns The persisted records for the given ids in order.\n   * @throws If one or more records could not be found.\n   */\n  abstract readOrThrow<K extends SelectableColumn<Record>>(\n    objects: Identifiable[],\n    columns: K[]\n  ): Promise<Array<Readonly<SelectedPick<Record, typeof columns>>>>;\n\n  /**\n   * Queries multiple records from the table by the ids in the objects.\n   * @param objects Array of objects containing the ids of the records.\n   * @returns The persisted records for the given ids in order.\n   * @throws If one or more records could not be found.\n   */\n  abstract readOrThrow(objects: Identifiable[]): Promise<Array<Readonly<SelectedPick<Record, ['*']>>>>;\n\n  /**\n   * Partially update a single record.\n   * @param object An object with its id and the columns to be updated.\n   * @param columns Array of columns to be returned. If not specified, first level columns will be returned.\n   * @returns The full persisted record, null if the record could not be found.\n   */\n  abstract update<K extends SelectableColumn<Record>>(\n    object: Partial<EditableData<Record>> & Identifiable,\n    columns: K[],\n    options?: { ifVersion?: number }\n  ): Promise<Readonly<SelectedPick<Record, typeof columns>> | null>;\n\n  /**\n   * Partially update a single record.\n   * @param object An object with its id and the columns to be updated.\n   * @returns The full persisted record, null if the record could not be found.\n   */\n  abstract update(\n    object: Partial<EditableData<Record>> & Identifiable,\n    options?: { ifVersion?: number }\n  ): Promise<Readonly<SelectedPick<Record, ['*']>> | null>;\n\n  /**\n   * Partially update a single record given its unique id.\n   * @param id The unique id.\n   * @param object The column names and their values that have to be updated.\n   * @param columns Array of columns to be returned. If not specified, first level columns will be returned.\n   * @returns The full persisted record, null if the record could not be found.\n   */\n  abstract update<K extends SelectableColumn<Record>>(\n    id: Identifier,\n    object: Partial<EditableData<Record>>,\n    columns: K[],\n    options?: { ifVersion?: number }\n  ): Promise<Readonly<SelectedPick<Record, typeof columns>> | null>;\n\n  /**\n   * Partially update a single record given its unique id.\n   * @param id The unique id.\n   * @param object The column names and their values that have to be updated.\n   * @returns The full persisted record, null if the record could not be found.\n   */\n  abstract update(\n    id: Identifier,\n    object: Partial<EditableData<Record>>,\n    options?: { ifVersion?: number }\n  ): Promise<Readonly<SelectedPick<Record, ['*']>> | null>;\n\n  /**\n   * Partially updates multiple records.\n   * @param objects An array of objects with their ids and columns to be updated.\n   * @param columns Array of columns to be returned. If not specified, first level columns will be returned.\n   * @returns Array of the persisted records in order (if a record could not be found null is returned).\n   */\n  abstract update<K extends SelectableColumn<Record>>(\n    objects: Array<Partial<EditableData<Record>> & Identifiable>,\n    columns: K[]\n  ): Promise<Array<Readonly<SelectedPick<Record, typeof columns>> | null>>;\n\n  /**\n   * Partially updates multiple records.\n   * @param objects An array of objects with their ids and columns to be updated.\n   * @returns Array of the persisted records in order (if a record could not be found null is returned).\n   */\n  abstract update(\n    objects: Array<Partial<EditableData<Record>> & Identifiable>\n  ): Promise<Array<Readonly<SelectedPick<Record, ['*']>> | null>>;\n\n  /**\n   * Partially update a single record.\n   * @param object An object with its id and the columns to be updated.\n   * @param columns Array of columns to be returned. If not specified, first level columns will be returned.\n   * @returns The full persisted record.\n   * @throws If the record could not be found.\n   */\n  abstract updateOrThrow<K extends SelectableColumn<Record>>(\n    object: Partial<EditableData<Record>> & Identifiable,\n    columns: K[],\n    options?: { ifVersion?: number }\n  ): Promise<Readonly<SelectedPick<Record, typeof columns>>>;\n\n  /**\n   * Partially update a single record.\n   * @param object An object with its id and the columns to be updated.\n   * @returns The full persisted record.\n   * @throws If the record could not be found.\n   */\n  abstract updateOrThrow(\n    object: Partial<EditableData<Record>> & Identifiable,\n    options?: { ifVersion?: number }\n  ): Promise<Readonly<SelectedPick<Record, ['*']>>>;\n\n  /**\n   * Partially update a single record given its unique id.\n   * @param id The unique id.\n   * @param object The column names and their values that have to be updated.\n   * @param columns Array of columns to be returned. If not specified, first level columns will be returned.\n   * @returns The full persisted record.\n   * @throws If the record could not be found.\n   */\n  abstract updateOrThrow<K extends SelectableColumn<Record>>(\n    id: Identifier,\n    object: Partial<EditableData<Record>>,\n    columns: K[],\n    options?: { ifVersion?: number }\n  ): Promise<Readonly<SelectedPick<Record, typeof columns>>>;\n\n  /**\n   * Partially update a single record given its unique id.\n   * @param id The unique id.\n   * @param object The column names and their values that have to be updated.\n   * @returns The full persisted record.\n   * @throws If the record could not be found.\n   */\n  abstract updateOrThrow(\n    id: Identifier,\n    object: Partial<EditableData<Record>>,\n    options?: { ifVersion?: number }\n  ): Promise<Readonly<SelectedPick<Record, ['*']>>>;\n\n  /**\n   * Partially updates multiple records.\n   * @param objects An array of objects with their ids and columns to be updated.\n   * @param columns Array of columns to be returned. If not specified, first level columns will be returned.\n   * @returns Array of the persisted records in order.\n   * @throws If one or more records could not be found.\n   */\n  abstract updateOrThrow<K extends SelectableColumn<Record>>(\n    objects: Array<Partial<EditableData<Record>> & Identifiable>,\n    columns: K[]\n  ): Promise<Readonly<SelectedPick<Record, typeof columns>>[]>;\n\n  /**\n   * Partially updates multiple records.\n   * @param objects An array of objects with their ids and columns to be updated.\n   * @returns Array of the persisted records in order.\n   * @throws If one or more records could not be found.\n   */\n  abstract updateOrThrow(\n    objects: Array<Partial<EditableData<Record>> & Identifiable>\n  ): Promise<Readonly<SelectedPick<Record, ['*']>>[]>;\n\n  /**\n   * Creates or updates a single record. If a record exists with the given id,\n   * it will be partially updated, otherwise a new record will be created.\n   * @param object Object containing the column names with their values to be persisted in the table.\n   * @param columns Array of columns to be returned. If not specified, first level columns will be returned.\n   * @returns The full persisted record.\n   */\n  abstract createOrUpdate<K extends SelectableColumn<Record>>(\n    object: Omit<EditableData<Record>, 'xata_id'> & Partial<Identifiable>,\n    columns: K[],\n    options?: { ifVersion?: number }\n  ): Promise<Readonly<SelectedPick<Record, typeof columns>>>;\n\n  /**\n   * Creates or updates a single record. If a record exists with the given id,\n   * it will be partially updated, otherwise a new record will be created.\n   * @param object Object containing the column names with their values to be persisted in the table.\n   * @returns The full persisted record.\n   */\n  abstract createOrUpdate(\n    object: Omit<EditableData<Record>, 'xata_id'> & Partial<Identifiable>,\n    options?: { ifVersion?: number }\n  ): Promise<Readonly<SelectedPick<Record, ['*']>>>;\n\n  /**\n   * Creates or updates a single record. If a record exists with the given id,\n   * it will be partially updated, otherwise a new record will be created.\n   * @param id A unique id.\n   * @param object The column names and the values to be persisted.\n   * @param columns Array of columns to be returned. If not specified, first level columns will be returned.\n   * @returns The full persisted record.\n   */\n  abstract createOrUpdate<K extends SelectableColumn<Record>>(\n    id: Identifier | undefined,\n    object: Omit<EditableData<Record>, 'xata_id'>,\n    columns: K[],\n    options?: { ifVersion?: number }\n  ): Promise<Readonly<SelectedPick<Record, typeof columns>>>;\n\n  /**\n   * Creates or updates a single record. If a record exists with the given id,\n   * it will be partially updated, otherwise a new record will be created.\n   * @param id A unique id.\n   * @param object The column names and the values to be persisted.\n   * @returns The full persisted record.\n   */\n  abstract createOrUpdate(\n    id: Identifier | undefined,\n    object: Omit<EditableData<Record>, 'xata_id'>,\n    options?: { ifVersion?: number }\n  ): Promise<Readonly<SelectedPick<Record, ['*']>>>;\n\n  /**\n   * Creates or updates a single record. If a record exists with the given id,\n   * it will be partially updated, otherwise a new record will be created.\n   * @param objects Array of objects with the column names and the values to be stored in the table.\n   * @param columns Array of columns to be returned. If not specified, first level columns will be returned.\n   * @returns Array of the persisted records.\n   */\n  abstract createOrUpdate<K extends SelectableColumn<Record>>(\n    objects: Array<Omit<EditableData<Record>, 'xata_id'> & Partial<Identifiable>>,\n    columns: K[]\n  ): Promise<Readonly<SelectedPick<Record, typeof columns>>[]>;\n\n  /**\n   * Creates or updates a single record. If a record exists with the given id,\n   * it will be partially updated, otherwise a new record will be created.\n   * @param objects Array of objects with the column names and the values to be stored in the table.\n   * @returns Array of the persisted records.\n   */\n  abstract createOrUpdate(\n    objects: Array<Omit<EditableData<Record>, 'xata_id'> & Partial<Identifiable>>\n  ): Promise<Readonly<SelectedPick<Record, ['*']>>[]>;\n\n  /**\n   * Creates or replaces a single record. If a record exists with the given id,\n   * it will be replaced, otherwise a new record will be created.\n   * @param object Object containing the column names with their values to be persisted in the table.\n   * @param columns Array of columns to be returned. If not specified, first level columns will be returned.\n   * @returns The full persisted record.\n   */\n  abstract createOrReplace<K extends SelectableColumn<Record>>(\n    object: Omit<EditableData<Record>, 'xata_id'> & Partial<Identifiable>,\n    columns: K[],\n    options?: { ifVersion?: number }\n  ): Promise<Readonly<SelectedPick<Record, typeof columns>>>;\n\n  /**\n   * Creates or replaces a single record. If a record exists with the given id,\n   * it will be replaced, otherwise a new record will be created.\n   * @param object Object containing the column names with their values to be persisted in the table.\n   * @returns The full persisted record.\n   */\n  abstract createOrReplace(\n    object: Omit<EditableData<Record>, 'xata_id'> & Partial<Identifiable>,\n    options?: { ifVersion?: number }\n  ): Promise<Readonly<SelectedPick<Record, ['*']>>>;\n\n  /**\n   * Creates or replaces a single record. If a record exists with the given id,\n   * it will be replaced, otherwise a new record will be created.\n   * @param id A unique id.\n   * @param object The column names and the values to be persisted.\n   * @param columns Array of columns to be returned. If not specified, first level columns will be returned.\n   * @returns The full persisted record.\n   */\n  abstract createOrReplace<K extends SelectableColumn<Record>>(\n    id: Identifier | undefined,\n    object: Omit<EditableData<Record>, 'xata_id'>,\n    columns: K[],\n    options?: { ifVersion?: number }\n  ): Promise<Readonly<SelectedPick<Record, typeof columns>>>;\n\n  /**\n   * Creates or replaces a single record. If a record exists with the given id,\n   * it will be replaced, otherwise a new record will be created.\n   * @param id A unique id.\n   * @param object The column names and the values to be persisted.\n   * @returns The full persisted record.\n   */\n  abstract createOrReplace(\n    id: Identifier | undefined,\n    object: Omit<EditableData<Record>, 'xata_id'>,\n    options?: { ifVersion?: number }\n  ): Promise<Readonly<SelectedPick<Record, ['*']>>>;\n\n  /**\n   * Creates or replaces a single record. If a record exists with the given id,\n   * it will be replaced, otherwise a new record will be created.\n   * @param objects Array of objects with the column names and the values to be stored in the table.\n   * @param columns Array of columns to be returned. If not specified, first level columns will be returned.\n   * @returns Array of the persisted records.\n   */\n  abstract createOrReplace<K extends SelectableColumn<Record>>(\n    objects: Array<Omit<EditableData<Record>, 'xata_id'> & Partial<Identifiable>>,\n    columns: K[]\n  ): Promise<Readonly<SelectedPick<Record, typeof columns>>[]>;\n\n  /**\n   * Creates or replaces a single record. If a record exists with the given id,\n   * it will be replaced, otherwise a new record will be created.\n   * @param objects Array of objects with the column names and the values to be stored in the table.\n   * @returns Array of the persisted records.\n   */\n  abstract createOrReplace(\n    objects: Array<Omit<EditableData<Record>, 'xata_id'> & Partial<Identifiable>>\n  ): Promise<Readonly<SelectedPick<Record, ['*']>>[]>;\n\n  /**\n   * Deletes a record given its unique id.\n   * @param object An object with a unique id.\n   * @param columns Array of columns to be returned. If not specified, first level columns will be returned.\n   * @returns The deleted record, null if the record could not be found.\n   */\n  abstract delete<K extends SelectableColumn<Record>>(\n    object: Identifiable & Partial<EditableData<Record>>,\n    columns: K[]\n  ): Promise<Readonly<SelectedPick<Record, typeof columns>> | null>;\n\n  /**\n   * Deletes a record given its unique id.\n   * @param object An object with a unique id.\n   * @returns The deleted record, null if the record could not be found.\n   */\n  abstract delete(\n    object: Identifiable & Partial<EditableData<Record>>\n  ): Promise<Readonly<SelectedPick<Record, ['*']>> | null>;\n\n  /**\n   * Deletes a record given a unique id.\n   * @param id The unique id.\n   * @param columns Array of columns to be returned. If not specified, first level columns will be returned.\n   * @returns The deleted record, null if the record could not be found.\n   */\n  abstract delete<K extends SelectableColumn<Record>>(\n    id: Identifier,\n    columns: K[]\n  ): Promise<Readonly<SelectedPick<Record, typeof columns>> | null>;\n\n  /**\n   * Deletes a record given a unique id.\n   * @param id The unique id.\n   * @returns The deleted record, null if the record could not be found.\n   */\n  abstract delete(id: Identifier): Promise<Readonly<SelectedPick<Record, ['*']>> | null>;\n\n  /**\n   * Deletes multiple records given an array of objects with ids.\n   * @param objects An array of objects with unique ids.\n   * @param columns Array of columns to be returned. If not specified, first level columns will be returned.\n   * @returns Array of the deleted records in order (if a record could not be found null is returned).\n   */\n  abstract delete<K extends SelectableColumn<Record>>(\n    objects: Array<Partial<EditableData<Record>> & Identifiable>,\n    columns: K[]\n  ): Promise<Array<Readonly<SelectedPick<Record, typeof columns>> | null>>;\n\n  /**\n   * Deletes multiple records given an array of objects with ids.\n   * @param objects An array of objects with unique ids.\n   * @returns Array of the deleted records in order (if a record could not be found null is returned).\n   */\n  abstract delete(\n    objects: Array<Partial<EditableData<Record>> & Identifiable>\n  ): Promise<Array<Readonly<SelectedPick<Record, ['*']>> | null>>;\n\n  /**\n   * Deletes multiple records given an array of unique ids.\n   * @param objects An array of ids.\n   * @param columns Array of columns to be returned. If not specified, first level columns will be returned.\n   * @returns Array of the deleted records in order (if a record could not be found null is returned).\n   */\n  abstract delete<K extends SelectableColumn<Record>>(\n    objects: Identifier[],\n    columns: K[]\n  ): Promise<Array<Readonly<SelectedPick<Record, typeof columns>> | null>>;\n\n  /**\n   * Deletes multiple records given an array of unique ids.\n   * @param objects An array of ids.\n   * @returns Array of the deleted records in order (if a record could not be found null is returned).\n   */\n  abstract delete(objects: Identifier[]): Promise<Array<Readonly<SelectedPick<Record, ['*']>> | null>>;\n\n  /**\n   * Deletes a record given its unique id.\n   * @param object An object with a unique id.\n   * @param columns Array of columns to be returned. If not specified, first level columns will be returned.\n   * @returns The deleted record, null if the record could not be found.\n   * @throws If the record could not be found.\n   */\n  abstract deleteOrThrow<K extends SelectableColumn<Record>>(\n    object: Identifiable,\n    columns: K[]\n  ): Promise<Readonly<SelectedPick<Record, typeof columns>>>;\n\n  /**\n   * Deletes a record given its unique id.\n   * @param object An object with a unique id.\n   * @returns The deleted record, null if the record could not be found.\n   * @throws If the record could not be found.\n   */\n  abstract deleteOrThrow(object: Identifiable): Promise<Readonly<SelectedPick<Record, ['*']>>>;\n\n  /**\n   * Deletes a record given a unique id.\n   * @param id The unique id.\n   * @param columns Array of columns to be returned. If not specified, first level columns will be returned.\n   * @returns The deleted record, null if the record could not be found.\n   * @throws If the record could not be found.\n   */\n  abstract deleteOrThrow<K extends SelectableColumn<Record>>(\n    id: Identifier,\n    columns: K[]\n  ): Promise<Readonly<SelectedPick<Record, typeof columns>>>;\n\n  /**\n   * Deletes a record given a unique id.\n   * @param id The unique id.\n   * @returns The deleted record, null if the record could not be found.\n   * @throws If the record could not be found.\n   */\n  abstract deleteOrThrow(id: Identifier): Promise<Readonly<SelectedPick<Record, ['*']>>>;\n\n  /**\n   * Deletes multiple records given an array of objects with ids.\n   * @param objects An array of objects with unique ids.\n   * @param columns Array of columns to be returned. If not specified, first level columns will be returned.\n   * @returns Array of the deleted records in order (if a record could not be found null is returned).\n   * @throws If one or more records could not be found.\n   */\n  abstract deleteOrThrow<K extends SelectableColumn<Record>>(\n    objects: Array<Partial<EditableData<Record>> & Identifiable>,\n    columns: K[]\n  ): Promise<Array<Readonly<SelectedPick<Record, typeof columns>>>>;\n\n  /**\n   * Deletes multiple records given an array of objects with ids.\n   * @param objects An array of objects with unique ids.\n   * @returns Array of the deleted records in order (if a record could not be found null is returned).\n   * @throws If one or more records could not be found.\n   */\n  abstract deleteOrThrow(\n    objects: Array<Partial<EditableData<Record>> & Identifiable>\n  ): Promise<Array<Readonly<SelectedPick<Record, ['*']>>>>;\n\n  /**\n   * Deletes multiple records given an array of unique ids.\n   * @param objects An array of ids.\n   * @param columns Array of columns to be returned. If not specified, first level columns will be returned.\n   * @returns Array of the deleted records in order (if a record could not be found null is returned).\n   * @throws If one or more records could not be found.\n   */\n  abstract deleteOrThrow<K extends SelectableColumn<Record>>(\n    objects: Identifier[],\n    columns: K[]\n  ): Promise<Array<Readonly<SelectedPick<Record, typeof columns>>>>;\n\n  /**\n   * Deletes multiple records given an array of unique ids.\n   * @param objects An array of ids.\n   * @returns Array of the deleted records in order.\n   * @throws If one or more records could not be found.\n   */\n  abstract deleteOrThrow(objects: Identifier[]): Promise<Array<Readonly<SelectedPick<Record, ['*']>>>>;\n\n  /**\n   * Search for records in the table.\n   * @param query The query to search for.\n   * @param options The options to search with (like: fuzziness)\n   * @returns The found records.\n   */\n  abstract search(\n    query: string,\n    options?: {\n      fuzziness?: FuzzinessExpression;\n      prefix?: PrefixExpression;\n      highlight?: HighlightExpression;\n      filter?: Filter<Record>;\n      boosters?: Boosters<Record>[];\n      page?: SearchPageConfig;\n      target?: TargetColumn<Record>[];\n    }\n  ): Promise<{ records: SearchXataRecord<SelectedPick<Record, ['*']>>[] } & TotalCount>;\n\n  /**\n   * Search for vectors in the table.\n   * @param column The column to search for.\n   * @param query The vector to search for similarities. Must have the same dimension as the vector column used.\n   * @param options The options to search with (like: spaceFunction)\n   */\n  abstract vectorSearch<F extends ColumnsByValue<Record, number[]>>(\n    column: F,\n    query: number[],\n    options?: {\n      /**\n       * The function used to measure the distance between two points. Can be one of:\n       * `cosineSimilarity`, `l1`, `l2`. The default is `cosineSimilarity`.\n       *\n       * @default cosineSimilarity\n       */\n      similarityFunction?: string;\n      /**\n       * Number of results to return.\n       *\n       * @default 10\n       * @maximum 100\n       * @minimum 1\n       */\n      size?: number;\n      filter?: Filter<Record>;\n    }\n  ): Promise<{ records: SearchXataRecord<SelectedPick<Record, ['*']>>[] } & TotalCount>;\n\n  /**\n   * Aggregates records in the table.\n   * @param expression The aggregations to perform.\n   * @param filter The filter to apply to the queried records.\n   * @returns The requested aggregations.\n   */\n  abstract aggregate<Expression extends Dictionary<AggregationExpression<Record>>>(\n    expression?: Expression,\n    filter?: Filter<Record>\n  ): Promise<AggregationResult<Record, Expression>>;\n\n  /**\n   * Experimental: Ask the database to perform a natural language question.\n   */\n  abstract ask(question: string, options?: AskOptions<Record>): Promise<AskResult>;\n\n  /**\n   * Experimental: Ask the database to perform a natural language question.\n   */\n  abstract ask(question: string, options: AskOptions<Record>): Promise<AskResult>;\n\n  /**\n   * Experimental: Ask the database to perform a natural language question.\n   */\n  abstract ask(question: string, options: AskOptions<Record> & { onMessage: (message: AskResult) => void }): void;\n\n  abstract query<Result extends XataRecord>(query: Query<Record, Result>): Promise<Page<Record, Result>>;\n}\n\nexport class RestRepository<Record extends XataRecord>\n  extends Query<Record, SelectedPick<Record, ['*']>>\n  implements Repository<Record>\n{\n  #table: string;\n  #getFetchProps: () => ApiExtraProps;\n  #db: SchemaPluginResult<any>;\n  #schemaTables?: Schemas.Table[];\n  #trace: TraceFunction;\n\n  constructor(options: {\n    table: string;\n    db: SchemaPluginResult<any>;\n    pluginOptions: XataPluginOptions;\n    schemaTables?: Schemas.Table[];\n  }) {\n    super(\n      null,\n      { name: options.table, schema: options.schemaTables?.find((table) => table.name === options.table) },\n      {}\n    );\n\n    this.#table = options.table;\n    this.#db = options.db;\n    this.#schemaTables = options.schemaTables;\n    this.#getFetchProps = () => ({ ...options.pluginOptions, sessionID: generateUUID() });\n\n    const trace = options.pluginOptions.trace ?? defaultTrace;\n    this.#trace = async <T>(\n      name: string,\n      fn: (options: { setAttributes: (attrs: AttributeDictionary) => void }) => T,\n      options: AttributeDictionary = {}\n    ) => {\n      return trace<T>(name, fn, {\n        ...options,\n        [TraceAttributes.TABLE]: this.#table,\n        [TraceAttributes.KIND]: 'sdk-operation',\n        [TraceAttributes.VERSION]: VERSION\n      });\n    };\n  }\n\n  async create<K extends SelectableColumn<Record>>(\n    object: EditableData<Record> & Partial<Identifiable>,\n    columns: K[],\n    options?: { ifVersion?: number }\n  ): Promise<Readonly<SelectedPick<Record, typeof columns>>>;\n  async create(\n    object: EditableData<Record> & Partial<Identifiable>,\n    options?: { ifVersion?: number }\n  ): Promise<Readonly<SelectedPick<Record, ['*']>>>;\n  async create<K extends SelectableColumn<Record>>(\n    id: Identifier,\n    object: EditableData<Record>,\n    columns: K[],\n    options?: { ifVersion?: number }\n  ): Promise<Readonly<SelectedPick<Record, typeof columns>>>;\n  async create(\n    id: Identifier,\n    object: EditableData<Record>,\n    options?: { ifVersion?: number }\n  ): Promise<Readonly<SelectedPick<Record, ['*']>>>;\n  async create<K extends SelectableColumn<Record>>(\n    objects: Array<EditableData<Record> & Partial<Identifiable>>,\n    columns: K[]\n  ): Promise<Readonly<SelectedPick<Record, typeof columns>>[]>;\n  async create(\n    objects: Array<EditableData<Record> & Partial<Identifiable>>\n  ): Promise<Readonly<SelectedPick<Record, ['*']>>[]>;\n  async create<K extends SelectableColumn<Record>>(\n    a:\n      | Identifier\n      | (EditableData<Record> & Partial<Identifiable>)\n      | Array<EditableData<Record> & Partial<Identifiable>>,\n    b?: EditableData<Record> | K[] | { ifVersion?: number },\n    c?: K[] | { ifVersion?: number },\n    d?: { ifVersion?: number }\n  ): Promise<\n    | Readonly<SelectedPick<Record, K[]>>\n    | Readonly<SelectedPick<Record, K[]>>[]\n    | Readonly<SelectedPick<Record, ['*']>>\n    | Readonly<SelectedPick<Record, ['*']>>[]\n  > {\n    return this.#trace('create', async () => {\n      const ifVersion = parseIfVersion(b, c, d);\n\n      // Create many records\n      if (Array.isArray(a)) {\n        if (a.length === 0) return [];\n\n        const ids = await this.#insertRecords(a, { ifVersion, createOnly: true });\n\n        const columns = isValidSelectableColumns(b) ? b : (['*'] as K[]);\n\n        // TODO: Transaction API does not support column projection\n        const result = await this.read(ids as string[], columns);\n        return result;\n      }\n\n      // Create one record with id as param\n      if (isString(a) && isObject(b)) {\n        if (a === '') throw new Error(\"The id can't be empty\");\n\n        const columns = isValidSelectableColumns(c) ? c : undefined;\n        return await this.#insertRecordWithId(a, b as EditableData<Record>, columns, { createOnly: true, ifVersion });\n      }\n\n      // Create one record with id as property\n      if (isObject(a) && isString(a.xata_id)) {\n        if (a.xata_id === '') throw new Error(\"The id can't be empty\");\n\n        const columns = isValidSelectableColumns(b) ? b : undefined;\n        return await this.#insertRecordWithId(a.xata_id, { ...a, xata_id: undefined }, columns, {\n          createOnly: true,\n          ifVersion\n        });\n      }\n\n      // Create one record without id\n      if (isObject(a)) {\n        const columns = isValidSelectableColumns(b) ? b : undefined;\n        return this.#insertRecordWithoutId(a, columns);\n      }\n\n      throw new Error('Invalid arguments for create method');\n    });\n  }\n\n  async #insertRecordWithoutId(object: EditableData<Record>, columns: SelectableColumn<Record>[] = ['*']) {\n    const record = await this.#transformObjectToApi(object);\n\n    const response = await insertRecord({\n      pathParams: {\n        workspace: '{workspaceId}',\n        dbBranchName: '{dbBranch}',\n        region: '{region}',\n        tableName: this.#table\n      },\n      queryParams: { columns },\n      body: record,\n      ...this.#getFetchProps()\n    });\n\n    const schemaTables = await this.#getSchemaTables();\n    return initObject(this.#db, schemaTables, this.#table, response, columns) as any;\n  }\n\n  async #insertRecordWithId(\n    recordId: Identifier,\n    object: EditableData<Record>,\n    columns: SelectableColumn<Record>[] = ['*'],\n    { createOnly, ifVersion }: { createOnly: boolean; ifVersion?: number }\n  ) {\n    if (!recordId) return null;\n\n    const record = await this.#transformObjectToApi(object);\n\n    const response = await insertRecordWithID({\n      pathParams: {\n        workspace: '{workspaceId}',\n        dbBranchName: '{dbBranch}',\n        region: '{region}',\n        tableName: this.#table,\n        recordId\n      },\n      body: record,\n      queryParams: { createOnly, columns, ifVersion },\n      ...this.#getFetchProps()\n    });\n\n    const schemaTables = await this.#getSchemaTables();\n    return initObject(this.#db, schemaTables, this.#table, response, columns) as any;\n  }\n\n  async #insertRecords(\n    objects: EditableData<Record>[],\n    { createOnly, ifVersion }: { createOnly: boolean; ifVersion?: number }\n  ) {\n    const operations = await promiseMap(objects, async (object) => {\n      const record = await this.#transformObjectToApi(object);\n      return { insert: { table: this.#table, record, createOnly, ifVersion } };\n    });\n\n    const chunkedOperations: TransactionOperation[][] = chunk(operations, BULK_OPERATION_MAX_SIZE);\n\n    const ids = [];\n\n    for (const operations of chunkedOperations) {\n      const { results } = await branchTransaction({\n        pathParams: {\n          workspace: '{workspaceId}',\n          dbBranchName: '{dbBranch}',\n          region: '{region}'\n        },\n        body: { operations },\n        ...this.#getFetchProps()\n      });\n\n      for (const result of results) {\n        if (result.operation === 'insert') {\n          ids.push(result.id);\n        } else {\n          ids.push(null);\n        }\n      }\n    }\n\n    return ids;\n  }\n\n  async read<K extends SelectableColumn<Record>>(\n    id: Identifier,\n    columns: K[]\n  ): Promise<Readonly<SelectedPick<Record, typeof columns> | null>>;\n  async read(id: string): Promise<Readonly<SelectedPick<Record, ['*']> | null>>;\n  async read<K extends SelectableColumn<Record>>(\n    ids: ReadonlyArray<Identifier>,\n    columns: K[]\n  ): Promise<Array<Readonly<SelectedPick<Record, typeof columns>> | null>>;\n  async read(ids: ReadonlyArray<Identifier>): Promise<Array<Readonly<SelectedPick<Record, ['*']>> | null>>;\n  async read<K extends SelectableColumn<Record>>(\n    object: Identifiable,\n    columns: K[]\n  ): Promise<Readonly<SelectedPick<Record, typeof columns> | null>>;\n  async read(object: Identifiable): Promise<Readonly<SelectedPick<Record, ['*']> | null>>;\n  async read<K extends SelectableColumn<Record>>(\n    objects: Identifiable[],\n    columns: K[]\n  ): Promise<Array<Readonly<SelectedPick<Record, typeof columns>> | null>>;\n  async read(objects: Identifiable[]): Promise<Array<Readonly<SelectedPick<Record, ['*']>> | null>>;\n  async read<K extends SelectableColumn<Record>>(\n    a: Identifier | ReadonlyArray<Identifier> | Identifiable | Identifiable[],\n    b?: K[]\n  ): Promise<\n    | Readonly<SelectedPick<Record, ['*']>>\n    | Array<Readonly<SelectedPick<Record, ['*']>> | null>\n    | Readonly<SelectedPick<Record, K[]>>\n    | Array<Readonly<SelectedPick<Record, K[]>> | null>\n    | null\n  > {\n    return this.#trace('read', async () => {\n      const columns = isValidSelectableColumns(b) ? b : ['*' as const];\n\n      // Read many records\n      if (Array.isArray(a)) {\n        if (a.length === 0) return [];\n\n        const ids = a.map((item) => extractId(item));\n\n        const finalObjects = await this.getAll({ filter: { xata_id: { $any: compact(ids) } }, columns });\n\n        // Maintain order of objects\n        const dictionary = finalObjects.reduce((acc, object) => {\n          acc[object.xata_id] = object;\n          return acc;\n        }, {} as Dictionary<any>);\n\n        return ids.map((id) => dictionary[id ?? ''] ?? null);\n      }\n\n      // Read one record\n      const id = extractId(a);\n      if (id) {\n        try {\n          const response = await getRecord({\n            pathParams: {\n              workspace: '{workspaceId}',\n              dbBranchName: '{dbBranch}',\n              region: '{region}',\n              tableName: this.#table,\n              recordId: id\n            },\n            queryParams: { columns },\n            ...this.#getFetchProps()\n          });\n\n          const schemaTables = await this.#getSchemaTables();\n          return initObject<Record>(\n            this.#db,\n            schemaTables,\n            this.#table,\n            response,\n            columns as SelectableColumn<Record>[]\n          ) as any;\n        } catch (e) {\n          if (isObject(e) && e.status === 404) {\n            return null;\n          }\n\n          throw e;\n        }\n      }\n\n      return null;\n    });\n  }\n\n  async readOrThrow<K extends SelectableColumn<Record>>(\n    id: Identifier,\n    columns: K[]\n  ): Promise<Readonly<SelectedPick<Record, typeof columns>>>;\n  async readOrThrow(id: Identifier): Promise<Readonly<SelectedPick<Record, ['*']>>>;\n  async readOrThrow<K extends SelectableColumn<Record>>(\n    ids: ReadonlyArray<Identifier>,\n    columns: K[]\n  ): Promise<Array<Readonly<SelectedPick<Record, typeof columns>>>>;\n  async readOrThrow(ids: ReadonlyArray<Identifier>): Promise<Array<Readonly<SelectedPick<Record, ['*']>>>>;\n  async readOrThrow<K extends SelectableColumn<Record>>(\n    object: Identifiable,\n    columns: K[]\n  ): Promise<Readonly<SelectedPick<Record, typeof columns>>>;\n  async readOrThrow(object: Identifiable): Promise<Readonly<SelectedPick<Record, ['*']>>>;\n  async readOrThrow<K extends SelectableColumn<Record>>(\n    objects: Identifiable[],\n    columns: K[]\n  ): Promise<Array<Readonly<SelectedPick<Record, typeof columns>>>>;\n  async readOrThrow(objects: Identifiable[]): Promise<Array<Readonly<SelectedPick<Record, ['*']>>>>;\n  async readOrThrow<K extends SelectableColumn<Record>>(\n    a: Identifier | ReadonlyArray<Identifier> | Identifiable | Identifiable[],\n    b?: K[]\n  ): Promise<\n    | Readonly<SelectedPick<Record, ['*']>>\n    | Readonly<SelectedPick<Record, ['*']>>[]\n    | Readonly<SelectedPick<Record, K[]>>\n    | Readonly<SelectedPick<Record, K[]>>[]\n  > {\n    return this.#trace('readOrThrow', async () => {\n      const result = await this.read(a as any, b as any);\n\n      if (Array.isArray(result)) {\n        const missingIds = compact(\n          (a as Array<string | Identifiable>)\n            .filter((_item, index) => result[index] === null)\n            .map((item) => extractId(item))\n        );\n\n        if (missingIds.length > 0) {\n          throw new Error(`Could not find records with ids: ${missingIds.join(', ')}`);\n        }\n\n        return result as any;\n      }\n\n      if (result === null) {\n        const id = extractId(a) ?? 'unknown';\n        throw new Error(`Record with id ${id} not found`);\n      }\n\n      return result;\n    });\n  }\n\n  async update<K extends SelectableColumn<Record>>(\n    object: Partial<EditableData<Record>> & Identifiable,\n    columns: K[],\n    options?: { ifVersion?: number }\n  ): Promise<Readonly<SelectedPick<Record, typeof columns>> | null>;\n  async update(\n    object: Partial<EditableData<Record>> & Identifiable,\n    options?: { ifVersion?: number }\n  ): Promise<Readonly<SelectedPick<Record, ['*']>> | null>;\n  async update<K extends SelectableColumn<Record>>(\n    id: Identifier,\n    object: Partial<EditableData<Record>>,\n    columns: K[],\n    options?: { ifVersion?: number }\n  ): Promise<Readonly<SelectedPick<Record, typeof columns>> | null>;\n  async update(\n    id: Identifier,\n    object: Partial<EditableData<Record>>,\n    options?: { ifVersion?: number }\n  ): Promise<Readonly<SelectedPick<Record, ['*']>> | null>;\n  async update<K extends SelectableColumn<Record>>(\n    objects: Array<Partial<EditableData<Record>> & Identifiable>,\n    columns: K[]\n  ): Promise<Array<Readonly<SelectedPick<Record, typeof columns>> | null>>;\n  async update(\n    objects: Array<Partial<EditableData<Record>> & Identifiable>\n  ): Promise<Array<Readonly<SelectedPick<Record, ['*']>> | null>>;\n  async update<K extends SelectableColumn<Record>>(\n    a:\n      | Identifier\n      | (Partial<EditableData<Record>> & Identifiable)\n      | Array<Partial<EditableData<Record>> & Identifiable>,\n    b?: Partial<EditableData<Record>> | K[] | { ifVersion?: number },\n    c?: K[] | { ifVersion?: number },\n    d?: { ifVersion?: number }\n  ): Promise<\n    | Readonly<SelectedPick<Record, ['*']>>\n    | Array<Readonly<SelectedPick<Record, ['*']>> | null>\n    | Readonly<SelectedPick<Record, K[]>>\n    | Array<Readonly<SelectedPick<Record, K[]>> | null>\n    | null\n  > {\n    return this.#trace('update', async () => {\n      const ifVersion = parseIfVersion(b, c, d);\n\n      // Update many records\n      if (Array.isArray(a)) {\n        if (a.length === 0) return [];\n\n        // TODO: Transaction API fails fast if one of the records is not found\n        const existing = await this.read(a, ['xata_id'] as SelectableColumn<Record>[]);\n        const updates = a.filter((_item, index) => existing[index] !== null);\n\n        await this.#updateRecords(updates as Array<Partial<EditableData<Record>> & Identifiable>, {\n          ifVersion,\n          upsert: false\n        });\n\n        const columns = isValidSelectableColumns(b) ? b : (['*'] as K[]);\n\n        // TODO: Transaction API does not support column projection\n        const result = await this.read(a, columns);\n        return result;\n      }\n\n      try {\n        // Update one record with id as param\n        if (isString(a) && isObject(b)) {\n          const columns = isValidSelectableColumns(c) ? c : undefined;\n          return await this.#updateRecordWithID(a, b as EditableData<Record>, columns, { ifVersion });\n        }\n\n        // Update one record with id as property\n        if (isObject(a) && isString(a.xata_id)) {\n          const columns = isValidSelectableColumns(b) ? b : undefined;\n          return await this.#updateRecordWithID(a.xata_id, { ...a, xata_id: undefined }, columns, { ifVersion });\n        }\n      } catch (error: any) {\n        if (error.status === 422) return null;\n        throw error;\n      }\n\n      throw new Error('Invalid arguments for update method');\n    });\n  }\n\n  async updateOrThrow<K extends SelectableColumn<Record>>(\n    object: Partial<EditableData<Record>> & Identifiable,\n    columns: K[],\n    options?: { ifVersion?: number }\n  ): Promise<Readonly<SelectedPick<Record, typeof columns>>>;\n  async updateOrThrow(\n    object: Partial<EditableData<Record>> & Identifiable,\n    options?: { ifVersion?: number }\n  ): Promise<Readonly<SelectedPick<Record, ['*']>>>;\n  async updateOrThrow<K extends SelectableColumn<Record>>(\n    id: Identifier,\n    object: Partial<EditableData<Record>>,\n    columns: K[],\n    options?: { ifVersion?: number }\n  ): Promise<Readonly<SelectedPick<Record, typeof columns>>>;\n  async updateOrThrow(\n    id: Identifier,\n    object: Partial<EditableData<Record>>,\n    options?: { ifVersion?: number }\n  ): Promise<Readonly<SelectedPick<Record, ['*']>>>;\n  async updateOrThrow<K extends SelectableColumn<Record>>(\n    objects: Array<Partial<EditableData<Record>> & Identifiable>,\n    columns: K[]\n  ): Promise<Readonly<SelectedPick<Record, typeof columns>>[]>;\n  async updateOrThrow(\n    objects: Array<Partial<EditableData<Record>> & Identifiable>\n  ): Promise<Readonly<SelectedPick<Record, ['*']>>[]>;\n  async updateOrThrow<K extends SelectableColumn<Record>>(\n    a:\n      | Identifier\n      | (Partial<EditableData<Record>> & Identifiable)\n      | Array<Partial<EditableData<Record>> & Identifiable>,\n    b?: Partial<EditableData<Record>> | K[] | { ifVersion?: number },\n    c?: K[] | { ifVersion?: number },\n    d?: { ifVersion?: number }\n  ): Promise<\n    | Readonly<SelectedPick<Record, ['*']>>\n    | Array<Readonly<SelectedPick<Record, ['*']>>>\n    | Readonly<SelectedPick<Record, K[]>>\n    | Array<Readonly<SelectedPick<Record, K[]>>>\n  > {\n    return this.#trace('updateOrThrow', async () => {\n      const result = await this.update(a as any, b as any, c as any, d as any);\n\n      if (Array.isArray(result)) {\n        const missingIds = compact(\n          (a as Array<string | Identifiable>)\n            .filter((_item, index) => result[index] === null)\n            .map((item) => extractId(item))\n        );\n\n        if (missingIds.length > 0) {\n          throw new Error(`Could not find records with ids: ${missingIds.join(', ')}`);\n        }\n\n        return result as any;\n      }\n\n      if (result === null) {\n        const id = extractId(a) ?? 'unknown';\n        throw new Error(`Record with id ${id} not found`);\n      }\n\n      return result;\n    });\n  }\n\n  async #updateRecordWithID(\n    recordId: Identifier,\n    object: Partial<EditableData<Record>>,\n    columns: SelectableColumn<Record>[] = ['*'],\n    { ifVersion }: { ifVersion?: number }\n  ) {\n    if (!recordId) return null;\n\n    // Ensure id is not present in the update payload\n    const { xata_id: _id, ...record } = await this.#transformObjectToApi(object);\n\n    try {\n      const response = await updateRecordWithID({\n        pathParams: {\n          workspace: '{workspaceId}',\n          dbBranchName: '{dbBranch}',\n          region: '{region}',\n          tableName: this.#table,\n          recordId\n        },\n        queryParams: { columns, ifVersion },\n        body: record,\n        ...this.#getFetchProps()\n      });\n\n      const schemaTables = await this.#getSchemaTables();\n      return initObject(this.#db, schemaTables, this.#table, response, columns) as any;\n    } catch (e) {\n      if (isObject(e) && e.status === 404) {\n        return null;\n      }\n\n      throw e;\n    }\n  }\n\n  async #updateRecords(\n    objects: Array<Partial<EditableData<Record>> & Identifiable>,\n    { ifVersion, upsert }: { ifVersion?: number; upsert: boolean }\n  ) {\n    const operations = await promiseMap(objects, async ({ xata_id, ...object }) => {\n      const fields = await this.#transformObjectToApi(object);\n      return { update: { table: this.#table, id: xata_id, ifVersion, upsert, fields } };\n    });\n\n    const chunkedOperations: TransactionOperation[][] = chunk(operations, BULK_OPERATION_MAX_SIZE);\n\n    const ids = [];\n\n    for (const operations of chunkedOperations) {\n      const { results } = await branchTransaction({\n        pathParams: {\n          workspace: '{workspaceId}',\n          dbBranchName: '{dbBranch}',\n          region: '{region}'\n        },\n        body: { operations },\n        ...this.#getFetchProps()\n      });\n\n      for (const result of results) {\n        if (result.operation === 'update') {\n          ids.push(result.id);\n        } else {\n          ids.push(null);\n        }\n      }\n    }\n\n    return ids;\n  }\n\n  async createOrUpdate<K extends SelectableColumn<Record>>(\n    object: EditableData<Record> & Partial<Identifiable>,\n    columns: K[],\n    options?: { ifVersion?: number }\n  ): Promise<Readonly<SelectedPick<Record, typeof columns>>>;\n  async createOrUpdate(\n    object: EditableData<Record> & Partial<Identifiable>,\n    options?: { ifVersion?: number }\n  ): Promise<Readonly<SelectedPick<Record, ['*']>>>;\n  async createOrUpdate<K extends SelectableColumn<Record>>(\n    id: Identifier,\n    object: Omit<EditableData<Record>, 'xata_id'>,\n    columns: K[],\n    options?: { ifVersion?: number }\n  ): Promise<Readonly<SelectedPick<Record, typeof columns>>>;\n  async createOrUpdate(\n    id: Identifier,\n    object: Omit<EditableData<Record>, 'xata_id'>,\n    options?: { ifVersion?: number }\n  ): Promise<Readonly<SelectedPick<Record, ['*']>>>;\n  async createOrUpdate<K extends SelectableColumn<Record>>(\n    objects: Array<EditableData<Record> & Partial<Identifiable>>,\n    columns: K[]\n  ): Promise<Readonly<SelectedPick<Record, typeof columns>>[]>;\n  async createOrUpdate(\n    objects: Array<EditableData<Record> & Partial<Identifiable>>\n  ): Promise<Readonly<SelectedPick<Record, ['*']>>[]>;\n  async createOrUpdate<K extends SelectableColumn<Record>>(\n    a: Identifier | EditableData<Record> | EditableData<Record>[],\n    b?: EditableData<Record> | Omit<EditableData<Record>, 'xata_id'> | K[] | { ifVersion?: number },\n    c?: K[] | { ifVersion?: number },\n    d?: { ifVersion?: number }\n  ): Promise<\n    | Readonly<SelectedPick<Record, ['*']>>\n    | Array<Readonly<SelectedPick<Record, ['*']>>>\n    | Readonly<SelectedPick<Record, K[]>>\n    | Array<Readonly<SelectedPick<Record, K[]>>>\n  > {\n    return this.#trace('createOrUpdate', async () => {\n      const ifVersion = parseIfVersion(b, c, d);\n\n      // Create or update many records\n      if (Array.isArray(a)) {\n        if (a.length === 0) return [];\n\n        await this.#updateRecords(a as Array<Partial<EditableData<Record>> & Identifiable>, {\n          ifVersion,\n          upsert: true\n        });\n\n        const columns = isValidSelectableColumns(b) ? b : (['*'] as K[]);\n\n        // TODO: Transaction API does not support column projection\n        const result = await this.read(a as any[], columns);\n        return result;\n      }\n\n      // Create or update one record with id as param\n      if (isString(a) && isObject(b)) {\n        if (a === '') throw new Error(\"The id can't be empty\");\n\n        const columns = isValidSelectableColumns(c) ? c : undefined;\n        return await this.#upsertRecordWithID(a, b as EditableData<Record>, columns, { ifVersion });\n      }\n\n      // Create or update one record with id as property\n      if (isObject(a) && isString(a.xata_id)) {\n        if (a.xata_id === '') throw new Error(\"The id can't be empty\");\n\n        const columns = isValidSelectableColumns(c) ? c : undefined;\n        return await this.#upsertRecordWithID(a.xata_id, { ...a, xata_id: undefined }, columns, { ifVersion });\n      }\n\n      // Create with undefined id as param\n      if (!isDefined(a) && isObject(b)) {\n        return await this.create(b as EditableData<Record>, c as K[]);\n      }\n\n      // Create with undefined id as property\n      if (isObject(a) && !isDefined(a.xata_id)) {\n        return await this.create(a as EditableData<Record>, b as K[]);\n      }\n\n      throw new Error('Invalid arguments for createOrUpdate method');\n    });\n  }\n\n  async #upsertRecordWithID(\n    recordId: Identifier,\n    object: Omit<EditableData<Record>, 'xata_id'>,\n    columns: SelectableColumn<Record>[] = ['*'],\n    { ifVersion }: { ifVersion?: number }\n  ) {\n    if (!recordId) return null;\n\n    const response = await upsertRecordWithID({\n      pathParams: {\n        workspace: '{workspaceId}',\n        dbBranchName: '{dbBranch}',\n        region: '{region}',\n        tableName: this.#table,\n        recordId\n      },\n      queryParams: { columns, ifVersion },\n      body: object as Schemas.DataInputRecord,\n      ...this.#getFetchProps()\n    });\n\n    const schemaTables = await this.#getSchemaTables();\n    return initObject(this.#db, schemaTables, this.#table, response, columns) as any;\n  }\n\n  async createOrReplace<K extends SelectableColumn<Record>>(\n    object: EditableData<Record> & Partial<Identifiable>,\n    columns: K[],\n    options?: { ifVersion?: number }\n  ): Promise<Readonly<SelectedPick<Record, typeof columns>>>;\n  async createOrReplace(\n    object: EditableData<Record> & Partial<Identifiable>,\n    options?: { ifVersion?: number }\n  ): Promise<Readonly<SelectedPick<Record, ['*']>>>;\n  async createOrReplace<K extends SelectableColumn<Record>>(\n    id: Identifier | undefined,\n    object: Omit<EditableData<Record>, 'xata_id'>,\n    columns: K[],\n    options?: { ifVersion?: number }\n  ): Promise<Readonly<SelectedPick<Record, typeof columns>>>;\n  async createOrReplace(\n    id: Identifier | undefined,\n    object: Omit<EditableData<Record>, 'xata_id'>,\n    options?: { ifVersion?: number }\n  ): Promise<Readonly<SelectedPick<Record, ['*']>>>;\n  async createOrReplace<K extends SelectableColumn<Record>>(\n    objects: Array<EditableData<Record> & Partial<Identifiable>>,\n    columns: K[]\n  ): Promise<Readonly<SelectedPick<Record, typeof columns>>[]>;\n  async createOrReplace(\n    objects: Array<EditableData<Record> & Partial<Identifiable>>\n  ): Promise<Readonly<SelectedPick<Record, ['*']>>[]>;\n  async createOrReplace<K extends SelectableColumn<Record>>(\n    a: Identifier | EditableData<Record> | EditableData<Record>[] | undefined,\n    b?: EditableData<Record> | Omit<EditableData<Record>, 'xata_id'> | K[] | { ifVersion?: number },\n    c?: K[] | { ifVersion?: number },\n    d?: { ifVersion?: number }\n  ): Promise<\n    | Readonly<SelectedPick<Record, ['*']>>\n    | Array<Readonly<SelectedPick<Record, ['*']>>>\n    | Readonly<SelectedPick<Record, K[]>>\n    | Array<Readonly<SelectedPick<Record, K[]>>>\n  > {\n    return this.#trace('createOrReplace', async () => {\n      const ifVersion = parseIfVersion(b, c, d);\n\n      // Create or replace many records\n      if (Array.isArray(a)) {\n        if (a.length === 0) return [];\n\n        const ids = await this.#insertRecords(a, { ifVersion, createOnly: false });\n\n        const columns = isValidSelectableColumns(b) ? b : (['*'] as K[]);\n\n        // TODO: Transaction API does not support column projection\n        const result = await this.read(ids as string[], columns);\n        return result;\n      }\n\n      // Create or replace one record with id as param\n      if (isString(a) && isObject(b)) {\n        if (a === '') throw new Error(\"The id can't be empty\");\n\n        const columns = isValidSelectableColumns(c) ? c : undefined;\n        return await this.#insertRecordWithId(a, b as EditableData<Record>, columns, { createOnly: false, ifVersion });\n      }\n\n      // Create or replace one record with id as property\n      if (isObject(a) && isString(a.xata_id)) {\n        if (a.xata_id === '') throw new Error(\"The id can't be empty\");\n\n        const columns = isValidSelectableColumns(c) ? c : undefined;\n        return await this.#insertRecordWithId(a.xata_id, { ...a, xata_id: undefined }, columns, {\n          createOnly: false,\n          ifVersion\n        });\n      }\n\n      // Create with undefined id as param\n      if (!isDefined(a) && isObject(b)) {\n        return await this.create(b as EditableData<Record>, c as K[]);\n      }\n\n      // Create with undefined id as property\n      if (isObject(a) && !isDefined(a.xata_id)) {\n        return await this.create(a as EditableData<Record>, b as K[]);\n      }\n\n      throw new Error('Invalid arguments for createOrReplace method');\n    });\n  }\n\n  async delete<K extends SelectableColumn<Record>>(\n    object: Identifiable,\n    columns: K[]\n  ): Promise<Readonly<SelectedPick<Record, typeof columns>> | null>;\n  async delete(object: Identifiable): Promise<Readonly<SelectedPick<Record, ['*']>> | null>;\n  async delete<K extends SelectableColumn<Record>>(\n    id: Identifier,\n    columns: K[]\n  ): Promise<Readonly<SelectedPick<Record, typeof columns>> | null>;\n  async delete(id: Identifier): Promise<Readonly<SelectedPick<Record, ['*']>> | null>;\n  async delete<K extends SelectableColumn<Record>>(\n    objects: Array<Partial<EditableData<Record>> & Identifiable>,\n    columns: K[]\n  ): Promise<Array<Readonly<SelectedPick<Record, typeof columns>> | null>>;\n  async delete(\n    objects: Array<Partial<EditableData<Record>> & Identifiable>\n  ): Promise<Array<Readonly<SelectedPick<Record, ['*']>> | null>>;\n  async delete<K extends SelectableColumn<Record>>(\n    objects: Identifier[],\n    columns: K[]\n  ): Promise<Array<Readonly<SelectedPick<Record, typeof columns>> | null>>;\n  async delete(objects: Identifier[]): Promise<Array<Readonly<SelectedPick<Record, ['*']>> | null>>;\n  async delete<K extends SelectableColumn<Record>>(\n    a: Identifier | Identifiable | Array<Identifier | Identifiable>,\n    b?: K[]\n  ): Promise<\n    | Readonly<SelectedPick<Record, ['*']>>\n    | Array<Readonly<SelectedPick<Record, ['*']>> | null>\n    | Readonly<SelectedPick<Record, K[]>>\n    | Array<Readonly<SelectedPick<Record, K[]>> | null>\n    | null\n  > {\n    return this.#trace('delete', async () => {\n      // Delete many records\n      if (Array.isArray(a)) {\n        if (a.length === 0) return [];\n\n        const ids = a.map((o) => {\n          if (isString(o)) return o;\n          if (isString(o.xata_id)) return o.xata_id;\n          throw new Error('Invalid arguments for delete method');\n        });\n\n        const columns = isValidSelectableColumns(b) ? b : (['*'] as K[]);\n\n        // TODO: Transaction API does not support column projection\n        const result = await this.read(a as any, columns);\n\n        await this.#deleteRecords(ids);\n\n        return result;\n      }\n\n      // Delete one record with id as param\n      if (isString(a)) {\n        return this.#deleteRecord(a, b);\n      }\n\n      // Delete one record with id as property\n      if (isObject(a) && isString(a.xata_id)) {\n        return this.#deleteRecord(a.xata_id, b);\n      }\n\n      throw new Error('Invalid arguments for delete method');\n    });\n  }\n\n  async deleteOrThrow<K extends SelectableColumn<Record>>(\n    object: Identifiable,\n    columns: K[]\n  ): Promise<Readonly<SelectedPick<Record, typeof columns>>>;\n  async deleteOrThrow(object: Identifiable): Promise<Readonly<SelectedPick<Record, ['*']>>>;\n  async deleteOrThrow<K extends SelectableColumn<Record>>(\n    id: Identifier,\n    columns: K[]\n  ): Promise<Readonly<SelectedPick<Record, typeof columns>>>;\n  async deleteOrThrow(id: Identifier): Promise<Readonly<SelectedPick<Record, ['*']>>>;\n  async deleteOrThrow<K extends SelectableColumn<Record>>(\n    objects: Array<Partial<EditableData<Record>> & Identifiable>,\n    columns: K[]\n  ): Promise<Array<Readonly<SelectedPick<Record, typeof columns>>>>;\n  async deleteOrThrow(\n    objects: Array<Partial<EditableData<Record>> & Identifiable>\n  ): Promise<Array<Readonly<SelectedPick<Record, ['*']>>>>;\n  async deleteOrThrow<K extends SelectableColumn<Record>>(\n    objects: Identifier[],\n    columns: K[]\n  ): Promise<Array<Readonly<SelectedPick<Record, typeof columns>>>>;\n  async deleteOrThrow(objects: Identifier[]): Promise<Array<Readonly<SelectedPick<Record, ['*']>>>>;\n  async deleteOrThrow<K extends SelectableColumn<Record>>(\n    a: Identifier | Identifiable | Array<Identifier | Identifiable>,\n    b?: K[]\n  ): Promise<\n    | Readonly<SelectedPick<Record, ['*']>>\n    | Array<Readonly<SelectedPick<Record, ['*']>>>\n    | Readonly<SelectedPick<Record, K[]>>\n    | Array<Readonly<SelectedPick<Record, K[]>>>\n  > {\n    return this.#trace('deleteOrThrow', async () => {\n      const result = await this.delete(a as any, b as any);\n\n      if (Array.isArray(result)) {\n        const missingIds = compact(\n          (a as Array<string | Identifiable>)\n            .filter((_item, index) => result[index] === null)\n            .map((item) => extractId(item))\n        );\n\n        if (missingIds.length > 0) {\n          throw new Error(`Could not find records with ids: ${missingIds.join(', ')}`);\n        }\n\n        return result as any;\n      } else if (result === null) {\n        const id = extractId(a) ?? 'unknown';\n        throw new Error(`Record with id ${id} not found`);\n      }\n\n      return result;\n    });\n  }\n\n  async #deleteRecord(recordId: Identifier, columns: SelectableColumn<Record>[] = ['*']) {\n    if (!recordId) return null;\n\n    try {\n      const response = await deleteRecord({\n        pathParams: {\n          workspace: '{workspaceId}',\n          dbBranchName: '{dbBranch}',\n          region: '{region}',\n          tableName: this.#table,\n          recordId\n        },\n        queryParams: { columns },\n        ...this.#getFetchProps()\n      });\n\n      const schemaTables = await this.#getSchemaTables();\n      return initObject(this.#db, schemaTables, this.#table, response, columns) as any;\n    } catch (e) {\n      if (isObject(e) && e.status === 404) {\n        return null;\n      }\n\n      throw e;\n    }\n  }\n\n  async #deleteRecords(recordIds: Identifier[]) {\n    const chunkedOperations: TransactionOperation[][] = chunk(\n      compact(recordIds).map((id) => ({ delete: { table: this.#table, id } })),\n      BULK_OPERATION_MAX_SIZE\n    );\n\n    for (const operations of chunkedOperations) {\n      await branchTransaction({\n        pathParams: {\n          workspace: '{workspaceId}',\n          dbBranchName: '{dbBranch}',\n          region: '{region}'\n        },\n        body: { operations },\n        ...this.#getFetchProps()\n      });\n    }\n  }\n\n  async search(\n    query: string,\n    options: {\n      fuzziness?: FuzzinessExpression;\n      prefix?: PrefixExpression;\n      highlight?: HighlightExpression;\n      filter?: Filter<Record>;\n      boosters?: Boosters<Record>[];\n      page?: SearchPageConfig;\n      target?: TargetColumn<Record>[];\n    } = {}\n  ) {\n    return this.#trace('search', async () => {\n      const { records, totalCount } = await searchTable({\n        pathParams: {\n          workspace: '{workspaceId}',\n          dbBranchName: '{dbBranch}',\n          region: '{region}',\n          tableName: this.#table\n        },\n        body: {\n          query,\n          fuzziness: options.fuzziness,\n          prefix: options.prefix,\n          highlight: options.highlight,\n          filter: options.filter as Schemas.FilterExpression,\n          boosters: options.boosters as Schemas.BoosterExpression[],\n          page: options.page,\n          target: options.target as Schemas.TargetExpression\n        },\n        ...this.#getFetchProps()\n      });\n\n      const schemaTables = await this.#getSchemaTables();\n\n      // TODO - Column selection not supported by search endpoint yet\n      return {\n        records: records.map((item) => initObject(this.#db, schemaTables, this.#table, item, ['*'])) as any,\n        totalCount\n      };\n    });\n  }\n\n  async vectorSearch<F extends ColumnsByValue<Record, number[]>>(\n    column: F,\n    query: number[],\n    options?:\n      | {\n          similarityFunction?: string | undefined;\n          size?: number | undefined;\n          filter?: Filter<Record> | undefined;\n        }\n      | undefined\n  ): Promise<{ records: SearchXataRecord<SelectedPick<Record, ['*']>>[] } & TotalCount> {\n    return this.#trace('vectorSearch', async () => {\n      const { records, totalCount } = await vectorSearchTable({\n        pathParams: {\n          workspace: '{workspaceId}',\n          dbBranchName: '{dbBranch}',\n          region: '{region}',\n          tableName: this.#table\n        },\n        body: {\n          column,\n          queryVector: query,\n          similarityFunction: options?.similarityFunction,\n          size: options?.size,\n          filter: options?.filter as Schemas.FilterExpression\n        },\n        ...this.#getFetchProps()\n      });\n\n      const schemaTables = await this.#getSchemaTables();\n\n      // TODO - Column selection not supported by search endpoint yet\n      return {\n        records: records.map((item) => initObject(this.#db, schemaTables, this.#table, item, ['*'])),\n        totalCount\n      } as any;\n    });\n  }\n\n  async aggregate<Expression extends Dictionary<AggregationExpression<Record>>>(\n    aggs?: Expression,\n    filter?: Filter<Record>\n  ) {\n    return this.#trace('aggregate', async () => {\n      const result = await aggregateTable({\n        pathParams: {\n          workspace: '{workspaceId}',\n          dbBranchName: '{dbBranch}',\n          region: '{region}',\n          tableName: this.#table\n        },\n        body: { aggs, filter: filter as Schemas.FilterExpression },\n        ...this.#getFetchProps()\n      });\n\n      return result as any;\n    });\n  }\n\n  async query<Result extends XataRecord>(query: Query<Record, Result>): Promise<Page<Record, Result>> {\n    return this.#trace('query', async () => {\n      const data = query.getQueryOptions();\n\n      const { meta, records: objects } = await queryTable({\n        pathParams: {\n          workspace: '{workspaceId}',\n          dbBranchName: '{dbBranch}',\n          region: '{region}',\n          tableName: this.#table\n        },\n        body: {\n          filter: cleanFilter(data.filter),\n          sort: data.sort !== undefined ? buildSortFilter(data.sort) : undefined,\n          page: data.pagination,\n          columns: data.columns ?? ['*'],\n          consistency: data.consistency\n        },\n        fetchOptions: data.fetchOptions,\n        ...this.#getFetchProps()\n      });\n\n      const schemaTables = await this.#getSchemaTables();\n      const records = objects.map((record) =>\n        initObject<Result>(\n          this.#db,\n          schemaTables,\n          this.#table,\n          record,\n          (data.columns as SelectableColumn<Result>[]) ?? ['*']\n        )\n      );\n\n      return new Page<Record, Result>(query, meta, records);\n    });\n  }\n\n  async summarizeTable<Result extends XataRecord>(\n    query: Query<Record, Result>,\n    summaries?: Dictionary<SummarizeExpression<Record>>,\n    summariesFilter?: Schemas.FilterExpression\n  ) {\n    return this.#trace('summarize', async () => {\n      const data = query.getQueryOptions();\n\n      const result = await summarizeTable({\n        pathParams: {\n          workspace: '{workspaceId}',\n          dbBranchName: '{dbBranch}',\n          region: '{region}',\n          tableName: this.#table\n        },\n        body: {\n          filter: cleanFilter(data.filter),\n          sort: data.sort !== undefined ? buildSortFilter(data.sort) : undefined,\n          columns: data.columns as SelectableColumn<Record>[],\n          consistency: data.consistency,\n          page: data.pagination?.size !== undefined ? { size: data.pagination?.size } : undefined,\n          summaries,\n          summariesFilter\n        },\n        ...this.#getFetchProps()\n      });\n      const schemaTables = await this.#getSchemaTables();\n      return {\n        ...result,\n        summaries: result.summaries.map((summary) =>\n          initObject(this.#db, schemaTables, this.#table, summary, data.columns ?? [])\n        )\n      };\n    });\n  }\n\n  ask(question: string, options?: AskOptions<Record> & { onMessage?: (message: AskResult) => void }): any {\n    // Ask with session uses message, ask without session uses question param\n    const questionParam = options?.sessionId ? { message: question } : { question };\n    const params = {\n      pathParams: {\n        workspace: '{workspaceId}',\n        dbBranchName: '{dbBranch}',\n        region: '{region}',\n        tableName: this.#table,\n        sessionId: options?.sessionId\n      },\n      body: {\n        ...questionParam,\n        rules: options?.rules,\n        searchType: options?.searchType,\n        search: options?.searchType === 'keyword' ? options?.search : undefined,\n        vectorSearch: options?.searchType === 'vector' ? options?.vectorSearch : undefined\n      },\n      ...this.#getFetchProps()\n    };\n\n    if (options?.onMessage) {\n      fetchSSERequest({\n        endpoint: 'dataPlane',\n        url: '/db/{dbBranchName}/tables/{tableName}/ask/{sessionId}',\n        method: 'POST',\n        onMessage: (message: { text: string; records: string[] }) => {\n          options.onMessage?.({ answer: message.text, records: message.records });\n        },\n        ...params\n      });\n    } else {\n      return askTableSession(params as any);\n    }\n  }\n\n  async #getSchemaTables(): Promise<Schemas.Table[]> {\n    if (this.#schemaTables) return this.#schemaTables;\n\n    const { schema } = await getBranchDetails({\n      pathParams: { workspace: '{workspaceId}', dbBranchName: '{dbBranch}', region: '{region}' },\n      ...this.#getFetchProps()\n    });\n\n    this.#schemaTables = schema.tables;\n    return schema.tables;\n  }\n\n  async #transformObjectToApi(object: any): Promise<Schemas.DataInputRecord> {\n    const schemaTables = await this.#getSchemaTables();\n    const schema = schemaTables.find((table) => table.name === this.#table);\n    if (!schema) throw new Error(`Table ${this.#table} not found in schema`);\n\n    const result: Dictionary<any> = {};\n\n    for (const [key, value] of Object.entries(object)) {\n      // Ignore internal properties\n      if (['xata_version', 'xata_createdat', 'xata_updatedat'].includes(key)) continue;\n\n      const type = schema.columns.find((column) => column.name === key)?.type;\n\n      switch (type) {\n        case 'link': {\n          result[key] = isIdentifiable(value) ? value.xata_id : value;\n          break;\n        }\n        case 'datetime': {\n          result[key] = value instanceof Date ? value.toISOString() : value;\n          break;\n        }\n        case `file`:\n          result[key] = await parseInputFileEntry(value as InputXataFile);\n          break;\n        case 'file[]':\n          result[key] = await promiseMap(value as InputXataFile[], (item) => parseInputFileEntry(item));\n          break;\n        case 'json':\n          result[key] = stringifyJson(value as any);\n          break;\n        default:\n          result[key] = value;\n      }\n    }\n\n    return result;\n  }\n}\n\nexport const initObject = <T>(\n  db: Record<string, Repository<any>>,\n  schemaTables: Schemas.Table[],\n  table: string,\n  object: Record<string, any>,\n  selectedColumns: SelectableColumn<T>[] | SelectableColumnWithObjectNotation<T>[]\n) => {\n  const data: Dictionary<unknown> = {};\n  Object.assign(data, { ...object });\n\n  const { columns } = schemaTables.find(({ name }) => name === table) ?? {};\n  if (!columns) console.error(`Table ${table} not found in schema`);\n\n  for (const column of columns ?? []) {\n    // Ignore columns not selected\n    if (!isValidColumn(selectedColumns, column)) continue;\n\n    const value = data[column.name];\n\n    switch (column.type) {\n      case 'datetime': {\n        const date = value !== undefined ? new Date(value as string) : null;\n\n        if (date !== null && isNaN(date.getTime())) {\n          console.error(`Failed to parse date ${value} for field ${column.name}`);\n        } else {\n          data[column.name] = date;\n        }\n\n        break;\n      }\n      case 'link': {\n        const linkTable = column.link?.table;\n\n        if (!linkTable) {\n          console.error(`Failed to parse link for field ${column.name}`);\n        } else if (isObject(value)) {\n          const selectedLinkColumns = (selectedColumns as string[]).reduce((acc, item) => {\n            if (item === column.name) {\n              return [...acc, '*'];\n            }\n\n            if (isString(item) && item.startsWith(`${column.name}.`)) {\n              const [, ...path] = item.split('.');\n              return [...acc, path.join('.')];\n            }\n\n            return acc;\n          }, [] as string[]);\n\n          data[column.name] = initObject(\n            db,\n            schemaTables,\n            linkTable,\n            value,\n            selectedLinkColumns as SelectableColumn<unknown>[]\n          );\n        } else {\n          data[column.name] = null;\n        }\n\n        break;\n      }\n      case 'file':\n        data[column.name] = isDefined(value) ? new XataFile(value as any) : null;\n        break;\n      case 'file[]':\n        data[column.name] = (value as XataArrayFile[])?.map((item) => new XataFile(item)) ?? null;\n        break;\n      case 'json':\n        data[column.name] = parseJson(value as string);\n        break;\n      default:\n        data[column.name] = value ?? null;\n\n        if (column.notNull === true && value === null) {\n          console.error(`Parse error, column ${column.name} is non nullable and value resolves null`);\n        }\n        break;\n    }\n  }\n\n  const record = { ...data };\n\n  record.read = function (columns?: any) {\n    return db[table].read(record['xata_id'] as string, columns);\n  };\n\n  record.update = function (data: any, b?: any, c?: any) {\n    const columns = isValidSelectableColumns(b) ? b : ['*'];\n    const ifVersion = parseIfVersion(b, c);\n\n    return db[table].update(record['xata_id'] as string, data, columns, { ifVersion });\n  };\n\n  record.replace = function (data: any, b?: any, c?: any) {\n    const columns = isValidSelectableColumns(b) ? b : ['*'];\n    const ifVersion = parseIfVersion(b, c);\n\n    return db[table].createOrReplace(record['xata_id'] as string, data, columns, { ifVersion });\n  };\n\n  record.delete = function () {\n    return db[table].delete(record['xata_id'] as string);\n  };\n\n  record.toSerializable = function () {\n    return JSON.parse(JSON.stringify(record));\n  };\n\n  record.toString = function () {\n    return JSON.stringify(record);\n  };\n\n  for (const prop of ['read', 'update', 'replace', 'delete', 'toSerializable', 'toString']) {\n    Object.defineProperty(record, prop, { enumerable: false });\n  }\n\n  Object.freeze(record);\n  // `as unkwnown` to avoid TS error on versions prior to 4.9 (can be removed once we drop support for older versions)\n  return record as unknown as T;\n};\n\nfunction extractId(value: any): Identifier | undefined {\n  if (isString(value)) return value;\n  if (isObject(value) && isString(value.xata_id)) return value.xata_id;\n  return undefined;\n}\n\nfunction isValidColumn(\n  columns: SelectableColumn<any>[] | SelectableColumnWithObjectNotation<any>[],\n  column: Schemas.Column\n) {\n  // Every column alias\n  if (columns.includes('*')) return true;\n\n  // Match column name and all its children (foo, foo.bar, foo.bar.baz)\n  return columns.filter((item) => isString(item) && item.startsWith(column.name)).length > 0;\n}\n\nfunction parseIfVersion(...args: any[]): number | undefined {\n  for (const arg of args) {\n    if (isObject(arg) && isNumber(arg.ifVersion)) {\n      return arg.ifVersion;\n    }\n  }\n\n  return undefined;\n}\n","import {\n  ArrayFilter,\n  ComparableType,\n  ComparableTypeFilter,\n  ExistanceFilter,\n  FilterColumns,\n  PropertyFilter,\n  StringTypeFilter\n} from './filters';\n\n/**\n * Operator to restrict results to only values that are greater than the given value.\n */\nexport const greaterThan = <T extends ComparableType>(value: T): ComparableTypeFilter<T> => ({ $gt: value });\n\n/**\n * Operator to restrict results to only values that are greater than the given value.\n */\nexport const gt = greaterThan;\n\n/**\n * Operator to restrict results to only values that are greater than or equal to the given value.\n */\nexport const greaterThanEquals = <T extends ComparableType>(value: T): ComparableTypeFilter<T> => ({ $ge: value });\n\n/**\n * Operator to restrict results to only values that are greater than or equal to the given value.\n */\nexport const greaterEquals = greaterThanEquals;\n\n/**\n * Operator to restrict results to only values that are greater than or equal to the given value.\n */\nexport const gte = greaterThanEquals;\n\n/**\n * Operator to restrict results to only values that are greater than or equal to the given value.\n */\nexport const ge = greaterThanEquals;\n\n/**\n * Operator to restrict results to only values that are lower than the given value.\n */\nexport const lessThan = <T extends ComparableType>(value: T): ComparableTypeFilter<T> => ({ $lt: value });\n\n/**\n * Operator to restrict results to only values that are lower than the given value.\n */\nexport const lt = lessThan;\n\n/**\n * Operator to restrict results to only values that are lower than or equal to the given value.\n */\nexport const lessThanEquals = <T extends ComparableType>(value: T): ComparableTypeFilter<T> => ({ $le: value });\n\n/**\n * Operator to restrict results to only values that are lower than or equal to the given value.\n */\nexport const lessEquals = lessThanEquals;\n\n/**\n * Operator to restrict results to only values that are lower than or equal to the given value.\n */\nexport const lte = lessThanEquals;\n\n/**\n * Operator to restrict results to only values that are lower than or equal to the given value.\n */\nexport const le = lessThanEquals;\n\n/**\n * Operator to restrict results to only values that are not null.\n */\nexport const exists = <T>(column?: FilterColumns<T>): ExistanceFilter<T> => ({ $exists: column });\n\n/**\n * Operator to restrict results to only values that are null.\n */\nexport const notExists = <T>(column?: FilterColumns<T>): ExistanceFilter<T> => ({ $notExists: column });\n\n/**\n * Operator to restrict results to only values that start with the given prefix.\n */\nexport const startsWith = (value: string): StringTypeFilter => ({ $startsWith: value });\n\n/**\n * Operator to restrict results to only values that end with the given suffix.\n */\nexport const endsWith = (value: string): StringTypeFilter => ({ $endsWith: value });\n\n/**\n * Operator to restrict results to only values that match the given pattern.\n */\nexport const pattern = (value: string): StringTypeFilter => ({ $pattern: value });\n\n/**\n * Operator to restrict results to only values that match the given pattern (case insensitive).\n */\nexport const iPattern = (value: string): StringTypeFilter => ({ $iPattern: value });\n\n/**\n * Operator to restrict results to only values that are equal to the given value.\n */\nexport const is = <T>(value: T): PropertyFilter<T> => ({ $is: value });\n\n/**\n * Operator to restrict results to only values that are equal to the given value.\n */\nexport const equals = is;\n\n/**\n * Operator to restrict results to only values that are not equal to the given value.\n */\nexport const isNot = <T>(value: T): PropertyFilter<T> => ({ $isNot: value });\n\n/**\n * Operator to restrict results to only values that contain the given value.\n */\nexport const contains = (value: string): StringTypeFilter => ({ $contains: value });\n\n/**\n * Operator to restrict results to only values that contain the given value (case insensitive).\n */\nexport const iContains = (value: string): StringTypeFilter => ({ $iContains: value });\n\n/**\n * Operator to restrict results if some array items match the predicate.\n */\nexport const includes = <T>(value: T): ArrayFilter<T> => ({ $includes: value });\n\n/**\n * Operator to restrict results if all array items match the predicate.\n */\nexport const includesAll = <T>(value: T): ArrayFilter<T> => ({ $includesAll: value });\n\n/**\n * Operator to restrict results if none array items match the predicate.\n */\nexport const includesNone = <T>(value: T): ArrayFilter<T> => ({ $includesNone: value });\n\n/**\n * Operator to restrict results if some array items match the predicate.\n */\nexport const includesAny = <T>(value: T): ArrayFilter<T> => ({ $includesAny: value });\n","import { XataPlugin, XataPluginOptions } from '../plugins';\nimport { isString } from '../util/lang';\nimport { XataRecord } from './record';\nimport { Repository, RestRepository } from './repository';\n\nexport * from './ask';\nexport { XataFile } from './files';\nexport type { XataArrayFile } from './files';\nexport * from './inference';\nexport * from './operators';\nexport * from './pagination';\nexport { Query } from './query';\nexport { RecordColumnTypes, isIdentifiable } from './record';\nexport type { BaseData, EditableData, Identifiable, JSONData, Link, XataRecord } from './record';\nexport { Repository, RestRepository } from './repository';\nexport * from './selection';\n\nexport type SchemaDefinition = {\n  table: string;\n};\n\nexport type SchemaPluginResult<Schemas extends Record<string, XataRecord>> = {\n  [Key in keyof Schemas]: Repository<Schemas[Key]>;\n};\n\nexport class SchemaPlugin<Schemas extends Record<string, XataRecord>> extends XataPlugin {\n  #tables: Record<string, Repository<any>> = {};\n\n  constructor() {\n    super();\n  }\n\n  build(pluginOptions: XataPluginOptions): SchemaPluginResult<Schemas> {\n    const db: any = new Proxy(\n      {},\n      {\n        get: (_target, table) => {\n          if (!isString(table)) throw new Error('Invalid table name');\n          if (this.#tables[table] === undefined) {\n            this.#tables[table] = new RestRepository({ db, pluginOptions, table, schemaTables: pluginOptions.tables });\n          }\n\n          return this.#tables[table];\n        }\n      }\n    );\n\n    // Inject generated tables for shell to auto-complete\n    const tableNames = pluginOptions.tables?.map(({ name }) => name) ?? [];\n    for (const table of tableNames) {\n      db[table] = new RestRepository({ db, pluginOptions, table, schemaTables: pluginOptions.tables });\n    }\n\n    return db;\n  }\n}\n","import { deleteFileItem, getFileItem, putFileItem } from '../api';\nimport { FileResponse } from '../api/dataPlaneSchemas';\nimport { XataPlugin, XataPluginOptions } from '../plugins';\nimport { ColumnsByValue, XataArrayFile, XataFile } from '../schema';\nimport { BaseData, XataRecord } from '../schema/record';\nimport { isBlob } from '../util/lang';\nimport { GetArrayInnerType, StringKeys, Values } from '../util/types';\n\nexport type BinaryFile = string | Blob | ArrayBuffer | XataFile | Promise<XataFile>;\n\nexport type FilesPluginResult<Schemas extends Record<string, BaseData>> = {\n  download: <Tables extends StringKeys<Schemas>>(location: DownloadDestination<Schemas, Tables>) => Promise<Blob>;\n  upload: <Tables extends StringKeys<Schemas>>(\n    location: UploadDestination<Schemas, Tables>,\n    file: BinaryFile,\n    options?: { mediaType?: string }\n  ) => Promise<FileResponse>;\n  delete: <Tables extends StringKeys<Schemas>>(location: DownloadDestination<Schemas, Tables>) => Promise<FileResponse>;\n};\n\nexport type UploadDestination<Schemas extends Record<string, BaseData>, Tables extends StringKeys<Schemas>> = Values<{\n  [Model in GetArrayInnerType<NonNullable<Tables[]>>]:\n    | {\n        table: Model;\n        column: ColumnsByValue<Schemas[Model], XataFile>;\n        record: string;\n      }\n    | {\n        table: Model;\n        column: ColumnsByValue<Schemas[Model], XataArrayFile[]>;\n        record: string;\n        fileId?: string;\n      };\n}>;\n\nexport type DownloadDestination<Schemas extends Record<string, BaseData>, Tables extends StringKeys<Schemas>> = Values<{\n  [Model in GetArrayInnerType<NonNullable<Tables[]>>]:\n    | {\n        table: Model;\n        column: ColumnsByValue<Schemas[Model], XataFile>;\n        record: string;\n      }\n    | {\n        table: Model;\n        column: ColumnsByValue<Schemas[Model], XataArrayFile[]>;\n        record: string;\n        fileId: string;\n      };\n}>;\n\nexport class FilesPlugin<Schemas extends Record<string, XataRecord>> extends XataPlugin {\n  build(pluginOptions: XataPluginOptions): FilesPluginResult<Schemas> {\n    return {\n      download: async (location: Record<string, string | undefined>) => {\n        const { table, record, column, fileId = '' } = location ?? {};\n\n        return await getFileItem({\n          pathParams: {\n            workspace: '{workspaceId}',\n            dbBranchName: '{dbBranch}',\n            region: '{region}',\n            tableName: table ?? '',\n            recordId: record ?? '',\n            columnName: column ?? '',\n            fileId\n          },\n          ...pluginOptions,\n          rawResponse: true\n        });\n      },\n      upload: async (\n        location: Record<string, string | undefined>,\n        file: BinaryFile,\n        options?: { mediaType?: string }\n      ) => {\n        const { table, record, column, fileId = '' } = location ?? {};\n        const resolvedFile = await file;\n        const contentType = options?.mediaType || getContentType(resolvedFile);\n        const body = resolvedFile instanceof XataFile ? resolvedFile.toBlob() : (resolvedFile as Blob);\n\n        return await putFileItem({\n          ...pluginOptions,\n          pathParams: {\n            workspace: '{workspaceId}',\n            dbBranchName: '{dbBranch}',\n            region: '{region}',\n            tableName: table ?? '',\n            recordId: record ?? '',\n            columnName: column ?? '',\n            fileId\n          },\n          body,\n          headers: { 'Content-Type': contentType }\n        });\n      },\n      delete: async (location: Record<string, string | undefined>) => {\n        const { table, record, column, fileId = '' } = location ?? {};\n\n        return await deleteFileItem({\n          pathParams: {\n            workspace: '{workspaceId}',\n            dbBranchName: '{dbBranch}',\n            region: '{region}',\n            tableName: table ?? '',\n            recordId: record ?? '',\n            columnName: column ?? '',\n            fileId\n          },\n          ...pluginOptions\n        });\n      }\n    };\n  }\n}\n\nfunction getContentType(file: BinaryFile): string {\n  if (typeof file === 'string') {\n    return 'text/plain';\n  }\n\n  // Check for XataFile\n  if ('mediaType' in file && file.mediaType !== undefined) {\n    return file.mediaType;\n  }\n\n  if (isBlob(file)) {\n    return file.type;\n  }\n\n  try {\n    // Check for Blobs that are not instances of Blob\n    return (file as any).type;\n  } catch (e) {\n    // ignore\n  }\n\n  return 'application/octet-stream';\n}\n","import { Responses, searchBranch } from '../api';\nimport { FuzzinessExpression, HighlightExpression, PrefixExpression, SearchPageConfig } from '../api/schemas';\nimport { XataPlugin, XataPluginOptions } from '../plugins';\nimport { SchemaPluginResult } from '../schema';\nimport { Filter } from '../schema/filters';\nimport { BaseData, XataRecord } from '../schema/record';\nimport { initObject } from '../schema/repository';\nimport { SelectedPick } from '../schema/selection';\nimport { GetArrayInnerType, StringKeys, Values } from '../util/types';\nimport { Boosters } from './boosters';\nimport { TargetColumn } from './target';\n\nexport type SearchOptions<Schemas extends Record<string, BaseData>, Tables extends StringKeys<Schemas>> = {\n  fuzziness?: FuzzinessExpression;\n  prefix?: PrefixExpression;\n  highlight?: HighlightExpression;\n  tables?: Array<\n    | Tables\n    | Values<{\n        [Model in GetArrayInnerType<NonNullable<Tables[]>>]: {\n          table: Model;\n          target?: TargetColumn<Schemas[Model] & XataRecord>[];\n          filter?: Filter<SelectedPick<Schemas[Model] & XataRecord, ['*']>>;\n          boosters?: Boosters<Schemas[Model] & XataRecord>[];\n        };\n      }>\n  >;\n  page?: SearchPageConfig;\n};\n\nexport type TotalCount = Pick<Responses.SearchResponse, 'totalCount'>;\n\nexport type SearchPluginResult<Schemas extends Record<string, BaseData>> = {\n  all: <Tables extends StringKeys<Schemas>>(\n    query: string,\n    options?: SearchOptions<Schemas, Tables>\n  ) => Promise<\n    TotalCount & {\n      records: Values<{\n        [Model in ExtractTables<\n          Schemas,\n          Tables,\n          GetArrayInnerType<NonNullable<NonNullable<typeof options>['tables']>>\n        >]: {\n          table: Model;\n          record: Awaited<SearchXataRecord<SelectedPick<Schemas[Model] & XataRecord, ['*']>>>;\n        };\n      }>[];\n    }\n  >;\n  byTable: <Tables extends StringKeys<Schemas>>(\n    query: string,\n    options?: SearchOptions<Schemas, Tables>\n  ) => Promise<\n    TotalCount & {\n      records: {\n        [Model in ExtractTables<\n          Schemas,\n          Tables,\n          GetArrayInnerType<NonNullable<NonNullable<typeof options>['tables']>>\n        >]?: Awaited<SearchXataRecord<SelectedPick<Schemas[Model] & XataRecord, ['*']>>[]>;\n      };\n    }\n  >;\n};\n\nexport class SearchPlugin<Schemas extends Record<string, XataRecord>> extends XataPlugin {\n  constructor(private db: SchemaPluginResult<Schemas>) {\n    super();\n  }\n\n  build(pluginOptions: XataPluginOptions): SearchPluginResult<Schemas> {\n    return {\n      all: async <Tables extends StringKeys<Schemas>>(query: string, options: SearchOptions<Schemas, Tables> = {}) => {\n        const { records, totalCount } = await this.#search(query, options, pluginOptions);\n\n        return {\n          totalCount,\n          records: records.map((record) => {\n            const table = record.xata_table;\n\n            // TODO: Search endpoint doesn't support column selection\n            return { table, record: initObject(this.db, pluginOptions.tables, table, record, ['*']) } as any;\n          })\n        };\n      },\n      byTable: async <Tables extends StringKeys<Schemas>>(\n        query: string,\n        options: SearchOptions<Schemas, Tables> = {}\n      ) => {\n        const { records: rawRecords, totalCount } = await this.#search(query, options, pluginOptions);\n\n        const records = rawRecords.reduce((acc, record) => {\n          const table = record.xata_table;\n\n          const items = acc[table] ?? [];\n          // TODO: Search endpoint doesn't support column selection\n          const item = initObject(this.db, pluginOptions.tables, table, record, ['*']);\n\n          return { ...acc, [table]: [...items, item] };\n        }, {} as any);\n        return { totalCount, records };\n      }\n    };\n  }\n\n  async #search<Tables extends StringKeys<Schemas>>(\n    query: string,\n    options: SearchOptions<Schemas, Tables>,\n    pluginOptions: XataPluginOptions\n  ) {\n    const { tables, fuzziness, highlight, prefix, page } = options ?? {};\n\n    const { records, totalCount } = await searchBranch({\n      pathParams: { workspace: '{workspaceId}', dbBranchName: '{dbBranch}', region: '{region}' },\n      // @ts-expect-error Filter properties do not match inferred type\n      body: { tables, query, fuzziness, prefix, highlight, page },\n      ...pluginOptions\n    });\n\n    return { records, totalCount };\n  }\n}\n\nexport type SearchXataRecord<Record extends XataRecord> = Record & SearchExtraProperties;\n\ntype SearchExtraProperties = {\n  /*\n   * The record's table name. APIs that return records from multiple tables will set this field accordingly.\n   */\n  xata_table: string;\n  /*\n   * Highlights of the record. This is used by the search APIs to indicate which fields and parts of the fields have matched the search.\n   */\n  xata_highlight?: {\n    [key: string]:\n      | string[]\n      | {\n          [key: string]: any;\n        };\n  };\n  /*\n   * The record's relevancy score. This is returned by the search APIs.\n   */\n  xata_score?: number;\n};\n\ntype ReturnTable<Table, Tables> = Table extends Tables ? Table : never;\n\ntype ExtractTables<\n  Schemas extends Record<string, BaseData>,\n  Tables extends StringKeys<Schemas>,\n  TableOptions extends GetArrayInnerType<NonNullable<NonNullable<SearchOptions<Schemas, Tables>>['tables']>>\n> = TableOptions extends `${infer Table}`\n  ? ReturnTable<Table, Tables>\n  : TableOptions extends { table: infer Table }\n  ? ReturnTable<Table, Tables>\n  : never;\n","import { SQLQuery } from '.';\nimport { isDefined, isObject, isString, isStringArray } from '../util/lang';\nimport { Buffer } from '../util/buffer';\n\nfunction escapeElement(elementRepresentation: string) {\n  const escaped = elementRepresentation.replace(/\\\\/g, '\\\\\\\\').replace(/\"/g, '\\\\\"');\n\n  return '\"' + escaped + '\"';\n}\n\nfunction arrayString<T extends any[]>(val: T) {\n  let result = '{';\n  for (let i = 0; i < val.length; i++) {\n    if (i > 0) {\n      result = result + ',';\n    }\n    if (val[i] === null || typeof val[i] === 'undefined') {\n      result = result + 'NULL';\n    } else if (Array.isArray(val[i])) {\n      result = result + arrayString(val[i]);\n    } else if (val[i] instanceof Buffer) {\n      result += '\\\\\\\\x' + val[i].toString('hex');\n    } else {\n      result += escapeElement(prepareValue(val[i]));\n    }\n  }\n  result = result + '}';\n  return result;\n}\n\n// Code distilled from pg/lib/utils.js\nfunction prepareValue(value: unknown) {\n  // null and undefined are both NULL in postgres\n  if (!isDefined(value)) return null;\n\n  // Convert JS Date to Postgres timestamp type\n  if (value instanceof Date) {\n    return value.toISOString();\n  }\n\n  // Convert arrays to postgres array syntax\n  if (Array.isArray(value)) {\n    return arrayString(value);\n  }\n\n  // Convert objects to JSON strings\n  if (isObject(value)) {\n    return JSON.stringify(value);\n  }\n\n  try {\n    // @ts-expect-error - Unknown type, attempt to coerce to string\n    return value.toString();\n  } catch (e) {\n    return value;\n  }\n}\n\nexport function prepareParams(param1: SQLQuery | string, param2?: any[]) {\n  if (isString(param1)) {\n    return { statement: param1, params: param2?.map((value) => prepareValue(value)) };\n  }\n\n  if (isStringArray(param1)) {\n    const statement = param1.reduce((acc, curr, index) => {\n      return acc + curr + (index < (param2?.length ?? 0) ? '$' + (index + 1) : '');\n    }, '');\n\n    return { statement, params: param2?.map((value) => prepareValue(value)) };\n  }\n\n  if (isObject(param1)) {\n    const { statement, params, consistency, responseType } = param1;\n\n    return { statement, params: params?.map((value) => prepareValue(value)), consistency, responseType };\n  }\n\n  throw new Error('Invalid query');\n}\n","import { HostProvider, parseWorkspacesUrlParts, sqlBatchQuery, sqlQuery } from '../api';\nimport { XataPlugin, XataPluginOptions } from '../plugins';\nimport { isObject, isString } from '../util/lang';\nimport { prepareParams } from './parameters';\n\nexport type SQLQueryParams<T = any[]> = {\n  /**\n   * The SQL statement to execute.\n   * @example\n   * ```ts\n   * const { records } = await xata.sql<TeamsRecord>({\n   *  statement: `SELECT * FROM teams WHERE name = $1`,\n   *  params: ['A name']\n   * });\n   * ```\n   *\n   * Be careful when using this with user input and use parametrized statements to avoid SQL injection.\n   */\n  statement: string;\n  /**\n   * The parameters to pass to the SQL statement.\n   */\n  params?: T;\n  /**\n   * The consistency level to use when executing the query.\n   * @default 'strong'\n   */\n  consistency?: 'strong' | 'eventual';\n  /**\n   * The response type to use when executing the query.\n   * @default 'json'\n   */\n  responseType?: 'json' | 'array';\n};\n\nexport type SQLBatchQuery = {\n  /**\n   * The SQL statements to execute.\n   */\n  statements: {\n    /**\n     * The SQL statement to execute.\n     */\n    statement: string;\n    /**\n     * The parameters to pass to the SQL statement.\n     */\n    params?: any[];\n  }[];\n  /**\n   * The consistency level to use when executing the queries.\n   * @default 'strong'\n   */\n  consistency?: 'strong' | 'eventual';\n  /**\n   * The response type to use when executing the queries.\n   * @default 'json'\n   */\n  responseType?: 'json' | 'array';\n};\n\nexport type SQLQuery = TemplateStringsArray | SQLQueryParams;\n\ntype SQLResponseType = 'json' | 'array';\n\ntype SQLQueryResultJSON<T> = {\n  /**\n   * The records returned by the query.\n   */\n  records: T[];\n  /**\n   * The columns metadata returned by the query.\n   */\n  columns: Array<{ name: string; type: string }>;\n  /**\n   * Optional warning message returned by the query.\n   */\n  warning?: string;\n};\n\ntype SQLQueryResultArray = {\n  /**\n   * The records returned by the query.\n   */\n  rows: any[][];\n  /**\n   * The columns metadata returned by the query.\n   */\n  columns: Array<{ name: string; type: string }>;\n  /**\n   * Optional warning message returned by the query.\n   */\n  warning?: string;\n};\n\nexport type SQLQueryResult<T, Mode extends SQLResponseType = 'json'> = Mode extends 'json'\n  ? SQLQueryResultJSON<T>\n  : Mode extends 'array'\n  ? SQLQueryResultArray\n  : never;\n\ntype SQLPluginFunction = <T, Query extends SQLQuery = SQLQuery>(\n  query: Query,\n  ...parameters: any[]\n) => Promise<\n  SQLQueryResult<\n    T,\n    Query extends SQLQueryParams<any>\n      ? Query['responseType'] extends SQLResponseType\n        ? NonNullable<Query['responseType']>\n        : 'json'\n      : 'json'\n  >\n>;\n\nexport type SQLPluginResult = SQLPluginFunction & {\n  /**\n   * Connection string to use when connecting to the database.\n   * It includes the workspace, region, database and branch.\n   * Connects with the same credentials as the Xata client.\n   */\n  connectionString: string;\n\n  /**\n   * Executes a batch of SQL statements.\n   * @param query The batch of SQL statements to execute.\n   */\n  batch: <Query extends SQLBatchQuery = SQLBatchQuery>(\n    query: Query\n  ) => Promise<{\n    results: Array<\n      SQLQueryResult<\n        any,\n        Query extends SQLBatchQuery\n          ? Query['responseType'] extends SQLResponseType\n            ? NonNullable<Query['responseType']>\n            : 'json'\n          : 'json'\n      >\n    >;\n  }>;\n};\n\nexport class SQLPlugin extends XataPlugin {\n  build(pluginOptions: XataPluginOptions): SQLPluginResult {\n    const sqlFunction = async (query: SQLQuery, ...parameters: any[]) => {\n      if (!isParamsObject(query) && (!isTemplateStringsArray(query) || !Array.isArray(parameters))) {\n        throw new Error('Invalid usage of `xata.sql`. Please use it as a tagged template or with an object.');\n      }\n\n      const { statement, params, consistency, responseType } = prepareParams(query, parameters);\n\n      const { warning, columns, ...response } = await sqlQuery({\n        pathParams: { workspace: '{workspaceId}', dbBranchName: '{dbBranch}', region: '{region}' },\n        body: { statement, params, consistency, responseType },\n        ...pluginOptions\n      });\n\n      const records = 'records' in response ? response.records : undefined;\n      const rows = 'rows' in response ? response.rows : undefined;\n\n      return { records, rows, warning, columns } as any;\n    };\n\n    sqlFunction.connectionString = buildConnectionString(pluginOptions);\n    sqlFunction.batch = async (query: SQLBatchQuery) => {\n      const { results } = await sqlBatchQuery({\n        pathParams: { workspace: '{workspaceId}', dbBranchName: '{dbBranch}', region: '{region}' },\n        body: {\n          statements: query.statements.map(({ statement, params }) => ({ statement, params })),\n          consistency: query.consistency,\n          responseType: query.responseType\n        },\n        ...pluginOptions\n      });\n\n      return { results } as any;\n    };\n\n    return sqlFunction;\n  }\n}\n\nfunction isTemplateStringsArray(strings: unknown): strings is TemplateStringsArray {\n  // @ts-ignore TS prior to 4.9 don't have this type\n  return Array.isArray(strings) && 'raw' in strings && Array.isArray(strings.raw);\n}\n\nfunction isParamsObject(params: unknown): params is SQLQueryParams {\n  return isObject(params) && 'statement' in params;\n}\n\nfunction buildDomain(host: HostProvider, region: string): string {\n  switch (host) {\n    case 'production':\n      return `${region}.sql.xata.sh`;\n    case 'staging':\n      return `${region}.sql.staging-xata.dev`;\n    case 'dev':\n      return `${region}.sql.dev-xata.dev`;\n    case 'local':\n      return 'localhost:7654';\n    default:\n      throw new Error('Invalid host provider');\n  }\n}\n\nfunction buildConnectionString({ apiKey, workspacesApiUrl, branch }: XataPluginOptions): string {\n  const url = isString(workspacesApiUrl) ? workspacesApiUrl : workspacesApiUrl('', {});\n  const parts = parseWorkspacesUrlParts(url);\n  if (!parts) throw new Error('Invalid workspaces URL');\n\n  const { workspace: workspaceSlug, region, database, host } = parts;\n  const domain = buildDomain(host, region);\n  const workspace = workspaceSlug.split('-').pop();\n\n  if (!workspace || !region || !database || !apiKey || !branch) {\n    throw new Error('Unable to build xata connection string');\n  }\n\n  return `postgresql://${workspace}:${apiKey}@${domain}/${database}:${branch}?sslmode=require`;\n}\n","import { branchTransaction } from '../api';\nimport { XataPlugin, XataPluginOptions } from '../plugins';\nimport { XataRecord } from '../schema/record';\nimport { Narrow, StringKeys } from '../util/types';\nimport { TransactionOperation, TransactionResults } from './operations';\n\nexport type TransactionPluginResult<Schemas extends Record<string, XataRecord>> = {\n  run: <Tables extends StringKeys<Schemas>, Operations extends TransactionOperation<Schemas, Tables>[]>(\n    operations: Narrow<Operations>\n  ) => Promise<TransactionResults<Schemas, Tables, Operations>>;\n};\n\nexport class TransactionPlugin<Schemas extends Record<string, XataRecord>> extends XataPlugin {\n  build(pluginOptions: XataPluginOptions): TransactionPluginResult<Schemas> {\n    return {\n      run: async (operations: any) => {\n        const response = await branchTransaction({\n          pathParams: { workspace: '{workspaceId}', dbBranchName: '{dbBranch}', region: '{region}' },\n          body: { operations: operations as any },\n          ...pluginOptions\n        });\n\n        return response as any;\n      }\n    };\n  }\n}\n\nexport * from './operations';\n","import { ApiExtraProps, HostProvider, Schemas } from './api';\nimport { FilesPlugin, FilesPluginResult } from './files';\nimport { XataPlugin, XataPluginOptions } from './plugins';\nimport { BaseSchema, SchemaPlugin, SchemaPluginResult, XataRecord } from './schema';\nimport { defaultTrace, TraceFunction } from './schema/tracing';\nimport { SearchPlugin, SearchPluginResult } from './search';\nimport { SQLPlugin, SQLPluginResult } from './sql';\nimport { TransactionPlugin, TransactionPluginResult } from './transaction';\nimport { FetchImpl, getFetchImplementation } from './util/fetch';\nimport { AllRequired, StringKeys } from './util/types';\nimport { generateUUID } from './util/uuid';\n\nexport type BaseClientOptions = {\n  fetch?: FetchImpl;\n  host?: HostProvider;\n  apiKey?: string;\n  databaseURL?: string;\n  branch?: string;\n  trace?: TraceFunction;\n  enableBrowser?: boolean;\n  clientName?: string;\n  xataAgentExtra?: Record<string, string>;\n};\n\ntype SafeOptions = AllRequired<Omit<BaseClientOptions, 'clientName' | 'xataAgentExtra'>> & {\n  host: HostProvider;\n  clientID: string;\n  clientName?: string;\n  xataAgentExtra?: Record<string, string>;\n};\n\nexport const buildClient = <Plugins extends Record<string, XataPlugin> = {}>(plugins?: Plugins) =>\n  class {\n    #options: SafeOptions;\n\n    schema: Schemas.Schema;\n    db: SchemaPluginResult<any>;\n    search: SearchPluginResult<any>;\n    transactions: TransactionPluginResult<any>;\n    sql: SQLPluginResult;\n    files: FilesPluginResult<any>;\n\n    constructor(options: BaseClientOptions = {}, tables: Schemas.Table[]) {\n      const safeOptions = this.#parseOptions(options);\n      this.#options = safeOptions;\n\n      const pluginOptions: XataPluginOptions = {\n        ...this.#getFetchProps(safeOptions),\n        host: safeOptions.host,\n        tables,\n        branch: safeOptions.branch\n      };\n\n      const db = new SchemaPlugin().build(pluginOptions);\n      const search = new SearchPlugin(db).build(pluginOptions);\n      const transactions = new TransactionPlugin().build(pluginOptions);\n      const sql = new SQLPlugin().build(pluginOptions);\n      const files = new FilesPlugin().build(pluginOptions);\n\n      // We assign the namespaces after creating in case the user overrides the db plugin\n      this.schema = { tables };\n      this.db = db;\n      this.search = search;\n      this.transactions = transactions;\n      this.sql = sql;\n      this.files = files;\n\n      for (const [key, namespace] of Object.entries(plugins ?? {})) {\n        if (namespace === undefined) continue;\n\n        // @ts-ignore\n        this[key] = namespace.build(pluginOptions);\n      }\n    }\n\n    public async getConfig() {\n      const databaseURL = this.#options.databaseURL;\n      const branch = this.#options.branch;\n\n      return { databaseURL, branch };\n    }\n\n    #parseOptions(options?: BaseClientOptions): SafeOptions {\n      // If is running from the browser and the user didn't pass `enableBrowser` we throw an error\n      const enableBrowser = options?.enableBrowser ?? false;\n      // @ts-ignore Window, Deno are not globals\n      const isBrowser = typeof window !== 'undefined' && typeof Deno === 'undefined';\n      if (isBrowser && !enableBrowser) {\n        throw new Error(\n          'You are trying to use Xata from the browser, which is potentially a non-secure environment. How to fix: https://xata.io/docs/messages/api-key-browser-error'\n        );\n      }\n\n      const fetch = getFetchImplementation(options?.fetch);\n      const databaseURL = options?.databaseURL;\n      const apiKey = options?.apiKey;\n      const branch = options?.branch;\n      const trace = options?.trace ?? defaultTrace;\n      const clientName = options?.clientName;\n      const host = options?.host ?? 'production';\n      const xataAgentExtra = options?.xataAgentExtra;\n\n      if (!apiKey) {\n        throw new Error('Option apiKey is required');\n      }\n\n      if (!databaseURL) {\n        throw new Error('Option databaseURL is required');\n      }\n\n      if (!branch) {\n        throw new Error('Option branch is required');\n      }\n\n      return {\n        fetch,\n        databaseURL,\n        apiKey,\n        branch,\n        trace,\n        host,\n        clientID: generateUUID(),\n        enableBrowser,\n        clientName,\n        xataAgentExtra\n      };\n    }\n\n    #getFetchProps({\n      fetch,\n      apiKey,\n      databaseURL,\n      branch,\n      trace,\n      clientID,\n      clientName,\n      xataAgentExtra\n    }: SafeOptions): ApiExtraProps {\n      return {\n        fetch,\n        apiKey,\n        apiUrl: '',\n        // Instead of using workspace and dbBranch, we inject a probably CNAME'd URL\n        workspacesApiUrl: (path, params) => {\n          const hasBranch = params.dbBranchName ?? params.branch;\n          const newPath = path.replace(/^\\/db\\/[^/]+/, hasBranch !== undefined ? `:${branch}` : '');\n          return databaseURL + newPath;\n        },\n        trace,\n        clientID,\n        clientName,\n        xataAgentExtra\n      };\n    }\n  } as unknown as ClientConstructor<Plugins>;\n\nexport interface ClientConstructor<Plugins extends Record<string, XataPlugin>> {\n  new <Schemas extends Record<string, XataRecord> = {}>(\n    options?: Partial<BaseClientOptions>,\n    schemaTables?: readonly BaseSchema[]\n  ): Omit<\n    {\n      db: Awaited<ReturnType<SchemaPlugin<Schemas>['build']>>;\n      search: Awaited<ReturnType<SearchPlugin<Schemas>['build']>>;\n      transactions: Awaited<ReturnType<TransactionPlugin<Schemas>['build']>>;\n      sql: Awaited<ReturnType<SQLPlugin['build']>>;\n      files: Awaited<ReturnType<FilesPlugin<Schemas>['build']>>;\n    },\n    keyof Plugins\n  > & {\n    [Key in StringKeys<NonNullable<Plugins>>]: Awaited<ReturnType<NonNullable<Plugins>[Key]['build']>>;\n  } & {\n    getConfig(): Promise<{\n      databaseURL: string;\n      branch: string;\n    }>;\n  };\n}\n\nexport class BaseClient extends buildClient()<Record<string, any>> {}\n","import { Identifiable, XataRecord } from '../schema/record';\n\n// These will be used to set special fields to serialized objects.\n// So objects should not use this field names. I think that's fine. Another approach would be to generate two objects:\n// One containing the \"data tree\" and another containing the a tree with the type information.\nconst META = '__';\nconst VALUE = '___';\n\n// TODO: Add types for the serializer\nexport class Serializer {\n  classes: Record<string, any> = {};\n\n  add(clazz: any) {\n    this.classes[clazz.name] = clazz;\n  }\n\n  toJSON<T>(data: T): string {\n    // We are not using JSON.stringify() and the replacer function here, because the replacer receives\n    // the result of toJSON() if the object has a toJSON() method. This is a problem for the Date type:\n    // we get a string, because Date.toJSON() returns the date formatted into a ISO string alreayd,\n    // so it's not possible to guess the type of the original object.\n    function visit(obj: any): any {\n      if (Array.isArray(obj)) return obj.map(visit);\n\n      const type = typeof obj;\n      if (type === 'undefined') return { [META]: 'undefined' };\n      if (type === 'bigint') return { [META]: 'bigint', [VALUE]: obj.toString() };\n      if (obj === null || type !== 'object') return obj;\n\n      const constructor = obj.constructor;\n      const o: Record<string, any> = { [META]: constructor.name };\n      for (const [key, value] of Object.entries(obj)) {\n        o[key] = visit(value);\n      }\n      if (constructor === Date) o[VALUE] = obj.toISOString();\n      if (constructor === Map) o[VALUE] = Object.fromEntries(obj);\n      if (constructor === Set) o[VALUE] = [...obj];\n      return o;\n    }\n\n    return JSON.stringify(visit(data));\n  }\n\n  fromJSON<T>(json: string): T {\n    return JSON.parse(json, (key, value) => {\n      if (value && typeof value === 'object' && !Array.isArray(value)) {\n        const { [META]: clazz, [VALUE]: val, ...rest } = value;\n        const constructor = this.classes[clazz];\n\n        if (constructor) {\n          return Object.assign(Object.create(constructor.prototype), rest);\n        }\n        if (clazz === 'Date') return new Date(val);\n        if (clazz === 'Set') return new Set(val);\n        if (clazz === 'Map') return new Map(Object.entries(val));\n        if (clazz === 'bigint') return BigInt(val);\n        // TODO: this is ignored. In order to support undefined we'd need to traverse the JSON tree ourselves.\n        // Instead of using the JSON.parse() reviver argument.\n        if (clazz === 'undefined') return undefined;\n        return rest;\n      }\n      return value;\n    });\n  }\n}\n\nconst defaultSerializer = new Serializer();\n\nexport type SerializedString<T> = string | (string & { __type: T });\nexport type DeserializedType<T> = T extends SerializedString<infer U> ? U : T;\n\nexport const serialize = <T>(data: T): SerializedString<T> => {\n  return defaultSerializer.toJSON(data) as SerializedString<T>;\n};\n\nexport const deserialize = <T extends SerializedString<any>>(json: T): SerializerResult<DeserializedType<T>> => {\n  return defaultSerializer.fromJSON(json);\n};\n\nexport type SerializerResult<T> = T extends XataRecord\n  ? Identifiable &\n      Omit<\n        {\n          [K in keyof T]: SerializerResult<T[K]>;\n        },\n        keyof XataRecord\n      >\n  : T extends any[]\n  ? SerializerResult<T[number]>[]\n  : T;\n","import { isObject } from './lang';\n\nfunction parseEnvironment(environment: any): Record<string, string> {\n  try {\n    if (typeof environment === 'function') {\n      return new Proxy(\n        {},\n        {\n          get(target) {\n            return environment(target);\n          }\n        }\n      ) as Record<string, string>;\n    }\n\n    if (isObject(environment)) {\n      return environment as Record<string, string>;\n    }\n  } catch (error) {\n    // noop\n  }\n\n  return {};\n}\n\nexport function buildPreviewBranchName({ org, branch }: { org: string; branch: string }) {\n  return `preview-${org}-${branch}`;\n}\n\nexport function getDeployPreviewBranch(environment: any) {\n  try {\n    const { deployPreview, deployPreviewBranch, vercelGitCommitRef, vercelGitRepoOwner } =\n      parseEnvironment(environment);\n    if (deployPreviewBranch) return deployPreviewBranch;\n\n    switch (deployPreview) {\n      case 'vercel': {\n        if (!vercelGitCommitRef || !vercelGitRepoOwner) {\n          console.warn('XATA_PREVIEW=vercel but VERCEL_GIT_COMMIT_REF or VERCEL_GIT_REPO_OWNER is not valid');\n          return undefined;\n        }\n\n        return buildPreviewBranchName({ org: vercelGitRepoOwner, branch: vercelGitCommitRef });\n      }\n    }\n\n    return undefined;\n  } catch (err) {\n    return undefined;\n  }\n}\n","export class XataError extends Error {\n  readonly status: number;\n\n  constructor(message: string, status: number) {\n    super(message);\n    this.status = status;\n  }\n}\n\nexport * from './api';\nexport * from './client';\nexport * from './plugins';\nexport * from './schema';\nexport * from './search';\nexport * from './sql';\nexport * from './serializer';\nexport * from './files';\nexport * from './transaction';\nexport { transformImage } from './files/transformations';\nexport type { ImageTransformations } from './files/transformations';\nexport { buildPreviewBranchName, getDeployPreviewBranch } from './util/environment';\nexport { Buffer } from './util/buffer';\n"],"names":["length","base64.toByteArray","base64.fromByteArray","i","__privateAdd","__privateSet","fetch","__privateGet","__privateMethod","match","operationsByTag","dataPlaneOperations","controlPlaneOperations","_target","_table","options","id","operations","columns","data"],"mappings":"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"}